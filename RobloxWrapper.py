
import typing
import inspect
import enum
import requests
from typing import get_type_hints

class RobloxClient:
    def __init__(self, RobloSecurity: str):
        self._RobloxSession = requests.session()
        self._RobloxSession.cookies.update({".ROBLOSECURITY": RobloSecurity})

        response = self._RobloxSession.post("https://auth.roblox.com/v2/logout")
        csrf_token = response.headers.get("x-csrf-token")
        self._RobloxSession.headers.update({"x-csrf-token": csrf_token})

    def _MakeRequest(self, method: str, url: str, Dictinary) -> requests.Response:
        Request = self._RobloxSession.request(method=method,url=url,**Dictinary)
        return Request

    def _SyncSchema(self, Schema: object, Json: dict):
        ClassObject = Schema.__class__
        TypeHints = get_type_hints(ClassObject.__init__)

        for ArgumentName, ArgumentType in TypeHints.items():
            if ArgumentName == "self": continue

            Value = Json.get(ArgumentName)

            if Value is not None:
                # Check if the ArgumentType is a list and contains another custom class
                if hasattr(ArgumentType, "__origin__") and ArgumentType.__origin__ is list:
                    ItemType = ArgumentType.__args__[0]  # Get the type of items in the list
                    if isinstance(Value, list):
                        Value = [ItemType(**Item) if isinstance(Item, dict) else Item for Item in Value]

                # Check if the ArgumentType is a custom class (like FriendRequest)
                elif hasattr(ArgumentType, "__annotations__"):
                    Value = ArgumentType(**Value) if isinstance(Value, dict) else Value
            setattr(Schema, ArgumentName, Value)

    class Users:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class Int64Extra:
            def __init__(ClassObject, key: int = None, sortOrder: enum.Enum = None, pagingDirection: enum.Enum = None, pageNumber: int = None, discriminator: str = None, count: int = None):
                ClassObject.key = key
                ClassObject.sortOrder = sortOrder
                ClassObject.pagingDirection = pagingDirection
                ClassObject.pageNumber = pageNumber
                ClassObject.discriminator = discriminator
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class StartIndexCursor:
            def __init__(ClassObject, startIndex: int = None, discriminator: str = None, count: int = None):
                ClassObject.startIndex = startIndex
                ClassObject.discriminator = discriminator
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class AuthenticatedUserResponse:
            def __init__(ClassObject, id: int = None, name: str = None, displayName: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class BirthdateRequest:
            def __init__(ClassObject, birthMonth: int = None, birthDay: int = None, birthYear: int = None, password: str = None):
                ClassObject.birthMonth = birthMonth
                ClassObject.birthDay = birthDay
                ClassObject.birthYear = birthYear
                ClassObject.password = password
                ClassObject.response: requests.Response = None


        class BirthdateResponse:
            def __init__(ClassObject, birthMonth: int = None, birthDay: int = None, birthYear: int = None):
                ClassObject.birthMonth = birthMonth
                ClassObject.birthDay = birthDay
                ClassObject.birthYear = birthYear
                ClassObject.response: requests.Response = None


        class DescriptionRequest:
            def __init__(ClassObject, description: str = None):
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class DescriptionResponse:
            def __init__(ClassObject, description: str = None):
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class GenderRequest:
            def __init__(ClassObject, gender: str = None):
                ClassObject.gender = gender
                ClassObject.response: requests.Response = None


        class GenderResponse:
            def __init__(ClassObject, gender: int = None):
                ClassObject.gender = gender
                ClassObject.response: requests.Response = None


        class GetUserResponse:
            def __init__(ClassObject, description: str = None, created: str = None, isBanned: bool = None, externalAppDisplayName: str = None, hasVerifiedBadge: bool = None, id: int = None, name: str = None, displayName: str = None):
                ClassObject.description = description
                ClassObject.created = created
                ClassObject.isBanned = isBanned
                ClassObject.externalAppDisplayName = externalAppDisplayName
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class MultiGetByUserIdRequest:
            def __init__(ClassObject, userIds: list[int] = None, excludeBannedUsers: bool = None):
                ClassObject.userIds = userIds
                ClassObject.excludeBannedUsers = excludeBannedUsers
                ClassObject.response: requests.Response = None


        class MultiGetByUsernameRequest:
            def __init__(ClassObject, usernames: list[str] = None, excludeBannedUsers: bool = None):
                ClassObject.usernames = usernames
                ClassObject.excludeBannedUsers = excludeBannedUsers
                ClassObject.response: requests.Response = None


        class MultiGetUserByNameResponse:
            def __init__(ClassObject, requestedUsername: str = None, hasVerifiedBadge: bool = None, id: int = None, name: str = None, displayName: str = None):
                ClassObject.requestedUsername = requestedUsername
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class SetDisplayNameRequest:
            def __init__(ClassObject, newDisplayName: str = None):
                ClassObject.newDisplayName = newDisplayName
                ClassObject.response: requests.Response = None


        class UserAgeBracketResponse:
            def __init__(ClassObject, ageBracket: int = None):
                ClassObject.ageBracket = ageBracket
                ClassObject.response: requests.Response = None


        class UserCountryCodeResponse:
            def __init__(ClassObject, countryCode: str = None):
                ClassObject.countryCode = countryCode
                ClassObject.response: requests.Response = None


        class UserRolesResponse:
            def __init__(ClassObject, roles: list[str] = None):
                ClassObject.roles = roles
                ClassObject.response: requests.Response = None


        class UserSearchResponse:
            def __init__(ClassObject, previousUsernames: list[str] = None, hasVerifiedBadge: bool = None, id: int = None, name: str = None, displayName: str = None):
                ClassObject.previousUsernames = previousUsernames
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class UsernameHistoryResponse:
            def __init__(ClassObject, name: str = None):
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class VerifiedBadgeUserResponse:
            def __init__(ClassObject, hasVerifiedBadge: bool = None, id: int = None, name: str = None, displayName: str = None):
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class MultiGetUserByNameResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Users.MultiGetUserByNameResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class VerifiedBadgeUserResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Users.VerifiedBadgeUserResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class UserSearchResponseExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Users.UserSearchResponse"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class UsernameHistoryResponseExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Users.UsernameHistoryResponse"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetBirthdate(self) -> BirthdateResponse:
            """
            Get the user's birthdate
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.GetBirthdate()
        
            Args:
                
            Returns:
                Users.BirthdateResponse: Users.BirthdateResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetBirthdateRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Users.roblox.com/v1/birthdate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.BirthdateResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetBirthdateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetBirthdateRecivedData)
            
            return ResponseSchema
        
        def PostBirthdate(self, BirthdateRequest: BirthdateRequest) -> ApiEmptyResponseModel:
            """
            Update the user's birthdate
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.PostBirthdate(BirthdateRequest=Users.BirthdateRequest())
        
            Args:
                BirthdateRequest: BirthdateRequest
            Returns:
                Users.ApiEmptyResponseModel: Users.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'BirthdateRequest': 'json'}
            Arguments = inspect.signature(self.PostBirthdate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostBirthdateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Users.roblox.com/v1/birthdate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostBirthdateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostBirthdateRecivedData)
            
            return ResponseSchema
        
        def GetDescription(self) -> DescriptionResponse:
            """
            Get the user's description
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.GetDescription()
        
            Args:
                
            Returns:
                Users.DescriptionResponse: Users.DescriptionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetDescriptionRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Users.roblox.com/v1/description", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.DescriptionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetDescriptionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetDescriptionRecivedData)
            
            return ResponseSchema
        
        def PostDescription(self, DescriptionRequest: DescriptionRequest) -> DescriptionResponse:
            """
            Update the user's description
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.PostDescription(DescriptionRequest=Users.DescriptionRequest())
        
            Args:
                DescriptionRequest: DescriptionRequest
            Returns:
                Users.DescriptionResponse: Users.DescriptionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'DescriptionRequest': 'json'}
            Arguments = inspect.signature(self.PostDescription)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostDescriptionRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Users.roblox.com/v1/description", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.DescriptionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostDescriptionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostDescriptionRecivedData)
            
            return ResponseSchema
        
        def GetDisplayNamesValidate(self, displayName: str, birthdate: str) -> ApiEmptyResponseModel:
            """
            Validate a display name for a new user.
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.GetDisplayNamesValidate(displayName=string, birthdate=string)
        
            Args:
                displayName: str
            birthdate: str
            Returns:
                Users.ApiEmptyResponseModel: Users.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {"displayName": displayName, "birthdate": birthdate},"headers": {},"cookies": {}}
            
            GetDisplayNamesValidateRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Users.roblox.com/v1/display-names/validate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetDisplayNamesValidateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetDisplayNamesValidateRecivedData)
            
            return ResponseSchema
        
        def GetGender(self) -> GenderResponse:
            """
            Get the user's gender
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.GetGender()
        
            Args:
                
            Returns:
                Users.GenderResponse: Users.GenderResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGenderRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Users.roblox.com/v1/gender", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.GenderResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGenderRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGenderRecivedData)
            
            return ResponseSchema
        
        def PostGender(self, GenderRequest: GenderRequest) -> ApiEmptyResponseModel:
            """
            Update the user's gender
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.PostGender(GenderRequest=Users.GenderRequest())
        
            Args:
                GenderRequest: GenderRequest
            Returns:
                Users.ApiEmptyResponseModel: Users.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'GenderRequest': 'json'}
            Arguments = inspect.signature(self.PostGender)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGenderRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Users.roblox.com/v1/gender", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGenderRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGenderRecivedData)
            
            return ResponseSchema
        
        def GetUsersUserid(self, userId: int) -> GetUserResponse:
            """
            Gets detailed user information by id.
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.GetUsersUserid(userId=integer)
        
            Args:
                userId: int
            Returns:
                Users.GetUserResponse: Users.GetUserResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Users.roblox.com/v1/users/{userId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.GetUserResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridDisplayNamesValidate(self, displayName: str, userId: int) -> ApiEmptyResponseModel:
            """
            Validate a display name for an existing user.
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.GetUsersUseridDisplayNamesValidate(displayName=string, userId=integer)
        
            Args:
                displayName: str
            userId: int
            Returns:
                Users.ApiEmptyResponseModel: Users.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {"displayName": displayName},"headers": {},"cookies": {}}
            
            GetUsersUseridDisplayNamesValidateRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Users.roblox.com/v1/users/{userId}/display-names/validate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridDisplayNamesValidateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridDisplayNamesValidateRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridUsernameHistory(self, limit: int, cursor: str, sortOrder: str, userId: int) -> UsernameHistoryResponseExtra:
            """
            Retrieves the username history for a particular user.
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.GetUsersUseridUsernameHistory(limit=integer, cursor=string, sortOrder=string, userId=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            userId: int
            Returns:
                Users.UsernameHistoryResponseExtra: Users.UsernameHistoryResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetUsersUseridUsernameHistoryRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Users.roblox.com/v1/users/{userId}/username-history", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.UsernameHistoryResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridUsernameHistoryRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridUsernameHistoryRecivedData)
            
            return ResponseSchema
        
        def GetUsersAuthenticated(self) -> AuthenticatedUserResponse:
            """
            Gets the minimal authenticated user.
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.GetUsersAuthenticated()
        
            Args:
                
            Returns:
                Users.AuthenticatedUserResponse: Users.AuthenticatedUserResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersAuthenticatedRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Users.roblox.com/v1/users/authenticated", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.AuthenticatedUserResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersAuthenticatedRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersAuthenticatedRecivedData)
            
            return ResponseSchema
        
        def GetUsersAuthenticatedAgeBracket(self) -> UserAgeBracketResponse:
            """
            Gets the age bracket of the authenticated user.
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.GetUsersAuthenticatedAgeBracket()
        
            Args:
                
            Returns:
                Users.UserAgeBracketResponse: Users.UserAgeBracketResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersAuthenticatedAgeBracketRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Users.roblox.com/v1/users/authenticated/age-bracket", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.UserAgeBracketResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersAuthenticatedAgeBracketRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersAuthenticatedAgeBracketRecivedData)
            
            return ResponseSchema
        
        def GetUsersAuthenticatedCountryCode(self) -> UserCountryCodeResponse:
            """
            Gets the country code of the authenticated user.
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.GetUsersAuthenticatedCountryCode()
        
            Args:
                
            Returns:
                Users.UserCountryCodeResponse: Users.UserCountryCodeResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersAuthenticatedCountryCodeRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Users.roblox.com/v1/users/authenticated/country-code", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.UserCountryCodeResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersAuthenticatedCountryCodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersAuthenticatedCountryCodeRecivedData)
            
            return ResponseSchema
        
        def GetUsersAuthenticatedRoles(self) -> UserRolesResponse:
            """
            Gets the (public) roles of the authenticated user, such as `"Soothsayer"` and `"BetaTester"`.
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.GetUsersAuthenticatedRoles()
        
            Args:
                
            Returns:
                Users.UserRolesResponse: Users.UserRolesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersAuthenticatedRolesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Users.roblox.com/v1/users/authenticated/roles", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.UserRolesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersAuthenticatedRolesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersAuthenticatedRolesRecivedData)
            
            return ResponseSchema
        
        def GetUsersSearch(self, keyword: str, sessionId: str, limit: int, cursor: str) -> UserSearchResponseExtra:
            """
            Searches for users by keyword.
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.GetUsersSearch(keyword=string, sessionId=string, limit=integer, cursor=string)
        
            Args:
                keyword: str
            sessionId: str
            limit: int
            cursor: str
            Returns:
                Users.UserSearchResponseExtra: Users.UserSearchResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"keyword": keyword, "sessionId": sessionId, "limit": limit, "cursor": cursor},"headers": {},"cookies": {}}
            
            GetUsersSearchRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Users.roblox.com/v1/users/search", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.UserSearchResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersSearchRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersSearchRecivedData)
            
            return ResponseSchema
        
        def PostUsernamesUsers(self, MultiGetByUsernameRequest: MultiGetByUsernameRequest) -> MultiGetUserByNameResponseExtra:
            """
            Get users by usernames.
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.PostUsernamesUsers(MultiGetByUsernameRequest=Users.MultiGetByUsernameRequest())
        
            Args:
                MultiGetByUsernameRequest: MultiGetByUsernameRequest
            Returns:
                Users.MultiGetUserByNameResponseExtra: Users.MultiGetUserByNameResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'MultiGetByUsernameRequest': 'json'}
            Arguments = inspect.signature(self.PostUsernamesUsers)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsernamesUsersRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Users.roblox.com/v1/usernames/users", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.MultiGetUserByNameResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsernamesUsersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsernamesUsersRecivedData)
            
            return ResponseSchema
        
        def PostUsers(self, MultiGetByUserIdRequest: MultiGetByUserIdRequest) -> VerifiedBadgeUserResponseExtra:
            """
            Get users by ids.
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.PostUsers(MultiGetByUserIdRequest=Users.MultiGetByUserIdRequest())
        
            Args:
                MultiGetByUserIdRequest: MultiGetByUserIdRequest
            Returns:
                Users.VerifiedBadgeUserResponseExtra: Users.VerifiedBadgeUserResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'MultiGetByUserIdRequest': 'json'}
            Arguments = inspect.signature(self.PostUsers)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Users.roblox.com/v1/users", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.VerifiedBadgeUserResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersRecivedData)
            
            return ResponseSchema
        
        def PatchUsersUseridDisplayNames(self, userId: int, SetDisplayNameRequest: SetDisplayNameRequest) -> ApiEmptyResponseModel:
            """
            Set the display name for the authorized user.
            
            Usage:
                import Users
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                UsersApi = Users.UsersApi(RobloxClient=RobloxClient)
                Response = UsersApi.PatchUsersUseridDisplayNames(userId=integer, SetDisplayNameRequest=Users.SetDisplayNameRequest())
        
            Args:
                userId: int
            SetDisplayNameRequest: SetDisplayNameRequest
            Returns:
                Users.ApiEmptyResponseModel: Users.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SetDisplayNameRequest': 'json'}
            Arguments = inspect.signature(self.PatchUsersUseridDisplayNames)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchUsersUseridDisplayNamesRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Users.roblox.com/v1/users/{userId}/display-names", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Users.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchUsersUseridDisplayNamesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchUsersUseridDisplayNamesRecivedData)
            
            return ResponseSchema
        
    class TwoStepVerification:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class ClearRecoveryCodesRequest:
            def __init__(ClassObject, password: str = None):
                ClassObject.password = password
                ClassObject.response: requests.Response = None


        class DisableSecurityKeyRequest:
            def __init__(ClassObject, credentialNicknames: list[str] = None):
                ClassObject.credentialNicknames = credentialNicknames
                ClassObject.response: requests.Response = None


        class DisableTwoStepVerificationRequest:
            def __init__(ClassObject, password: str = None, reauthenticationToken: str = None):
                ClassObject.password = password
                ClassObject.reauthenticationToken = reauthenticationToken
                ClassObject.response: requests.Response = None


        class EnableAuthenticatorResponse:
            def __init__(ClassObject, setupToken: str = None, qrCodeImageUrl: str = None, manualEntryKey: str = None):
                ClassObject.setupToken = setupToken
                ClassObject.qrCodeImageUrl = qrCodeImageUrl
                ClassObject.manualEntryKey = manualEntryKey
                ClassObject.response: requests.Response = None


        class EnableSecurityKeyResponse:
            def __init__(ClassObject, creationOptions: str = None, sessionId: str = None):
                ClassObject.creationOptions = creationOptions
                ClassObject.sessionId = sessionId
                ClassObject.response: requests.Response = None


        class SecureAuthenticationIntentModel:
            def __init__(ClassObject, clientPublicKey: str = None, clientEpochTimestamp: int = None, saiSignature: str = None, serverNonce: str = None):
                ClassObject.clientPublicKey = clientPublicKey
                ClassObject.clientEpochTimestamp = clientEpochTimestamp
                ClassObject.saiSignature = saiSignature
                ClassObject.serverNonce = serverNonce
                ClassObject.response: requests.Response = None


        class EnableTwoStepVerificationRequest:
            def __init__(ClassObject, password: str = None, secureAuthenticationIntent: "RobloxClient.TwoStepVerification.SecureAuthenticationIntentModel" = None):
                ClassObject.password = password
                ClassObject.secureAuthenticationIntent = secureAuthenticationIntent
                ClassObject.response: requests.Response = None


        class EnableVerifyAuthenticatorRequest:
            def __init__(ClassObject, setupToken: str = None, code: str = None, password: str = None, secureAuthenticationIntent: "RobloxClient.TwoStepVerification.SecureAuthenticationIntentModel" = None):
                ClassObject.setupToken = setupToken
                ClassObject.code = code
                ClassObject.password = password
                ClassObject.secureAuthenticationIntent = secureAuthenticationIntent
                ClassObject.response: requests.Response = None


        class EnableVerifyAuthenticatorResponse:
            def __init__(ClassObject, recoveryCodes: list[str] = None):
                ClassObject.recoveryCodes = recoveryCodes
                ClassObject.response: requests.Response = None


        class EnableVerifySecurityKeyRequest:
            def __init__(ClassObject, sessionId: str = None, credentialNickname: str = None, attestationResponse: str = None):
                ClassObject.sessionId = sessionId
                ClassObject.credentialNickname = credentialNickname
                ClassObject.attestationResponse = attestationResponse
                ClassObject.response: requests.Response = None


        class SecurityKeyCredential:
            def __init__(ClassObject, nickname: str = None):
                ClassObject.nickname = nickname
                ClassObject.response: requests.Response = None


        class ListSecurityKeyResponse:
            def __init__(ClassObject, credentials: list["RobloxClient.TwoStepVerification.SecurityKeyCredential"] = None):
                ClassObject.credentials = credentials
                ClassObject.response: requests.Response = None


        class MetadataResponse:
            def __init__(ClassObject, twoStepVerificationEnabled: bool = None, authenticatorQrCodeSize: str = None, emailCodeLength: int = None, authenticatorCodeLength: int = None, authenticatorHelpSiteAddress: str = None, isPasswordRequiredForEnablingAuthenticator: bool = None, isPasswordRequiredForEnablingEmailTwoStepVerification: bool = None, isUsingTwoStepWebviewComponent: bool = None, isTwoStepEnabledRequiredForEmailPasswordRequirement: bool = None, isTwoStepEnabledRequiredForAuthenticatorPasswordRequirement: bool = None, isSingleMethodEnforcementEnabled: bool = None, isSmsTwoStepVerificationAvailable: bool = None, isSecurityKeyTwoStepVerificationAvailable: bool = None, isAuthenticatorWithVerifiedPhoneEnabled: bool = None, isPasswordRequiredForEnablingSecurityKey: bool = None, isPasswordRequiredForEnablingSms2SV: bool = None, isPasswordRequiredForChangingRecoveryCodes: bool = None, isPasswordRequiredForDisablingAuthenticator: bool = None, isPasswordRequiredForDisablingEmailTwoStepVerification: bool = None, isPasswordRequiredForDisablingSms2SV: bool = None, isRecoveryCodeGenerationForAuthenticatorSetupEnabled: bool = None, isSecurityKeyOnAllPlatformsEnabled: bool = None, receiveWarningsOnDisableTwoStep: bool = None, isAndroidSecurityKeyEnabled: bool = None):
                ClassObject.twoStepVerificationEnabled = twoStepVerificationEnabled
                ClassObject.authenticatorQrCodeSize = authenticatorQrCodeSize
                ClassObject.emailCodeLength = emailCodeLength
                ClassObject.authenticatorCodeLength = authenticatorCodeLength
                ClassObject.authenticatorHelpSiteAddress = authenticatorHelpSiteAddress
                ClassObject.isPasswordRequiredForEnablingAuthenticator = isPasswordRequiredForEnablingAuthenticator
                ClassObject.isPasswordRequiredForEnablingEmailTwoStepVerification = isPasswordRequiredForEnablingEmailTwoStepVerification
                ClassObject.isUsingTwoStepWebviewComponent = isUsingTwoStepWebviewComponent
                ClassObject.isTwoStepEnabledRequiredForEmailPasswordRequirement = isTwoStepEnabledRequiredForEmailPasswordRequirement
                ClassObject.isTwoStepEnabledRequiredForAuthenticatorPasswordRequirement = isTwoStepEnabledRequiredForAuthenticatorPasswordRequirement
                ClassObject.isSingleMethodEnforcementEnabled = isSingleMethodEnforcementEnabled
                ClassObject.isSmsTwoStepVerificationAvailable = isSmsTwoStepVerificationAvailable
                ClassObject.isSecurityKeyTwoStepVerificationAvailable = isSecurityKeyTwoStepVerificationAvailable
                ClassObject.isAuthenticatorWithVerifiedPhoneEnabled = isAuthenticatorWithVerifiedPhoneEnabled
                ClassObject.isPasswordRequiredForEnablingSecurityKey = isPasswordRequiredForEnablingSecurityKey
                ClassObject.isPasswordRequiredForEnablingSms2SV = isPasswordRequiredForEnablingSms2SV
                ClassObject.isPasswordRequiredForChangingRecoveryCodes = isPasswordRequiredForChangingRecoveryCodes
                ClassObject.isPasswordRequiredForDisablingAuthenticator = isPasswordRequiredForDisablingAuthenticator
                ClassObject.isPasswordRequiredForDisablingEmailTwoStepVerification = isPasswordRequiredForDisablingEmailTwoStepVerification
                ClassObject.isPasswordRequiredForDisablingSms2SV = isPasswordRequiredForDisablingSms2SV
                ClassObject.isRecoveryCodeGenerationForAuthenticatorSetupEnabled = isRecoveryCodeGenerationForAuthenticatorSetupEnabled
                ClassObject.isSecurityKeyOnAllPlatformsEnabled = isSecurityKeyOnAllPlatformsEnabled
                ClassObject.receiveWarningsOnDisableTwoStep = receiveWarningsOnDisableTwoStep
                ClassObject.isAndroidSecurityKeyEnabled = isAndroidSecurityKeyEnabled
                ClassObject.response: requests.Response = None


        class RecoveryCodesStatusResponse:
            def __init__(ClassObject, activeCount: int = None, created: str = None):
                ClassObject.activeCount = activeCount
                ClassObject.created = created
                ClassObject.response: requests.Response = None


        class RegenerateRecoveryCodesRequest:
            def __init__(ClassObject, password: str = None):
                ClassObject.password = password
                ClassObject.response: requests.Response = None


        class RegenerateRecoveryCodesResponse:
            def __init__(ClassObject, recoveryCodes: list[str] = None):
                ClassObject.recoveryCodes = recoveryCodes
                ClassObject.response: requests.Response = None


        class RetractDialogRequest:
            def __init__(ClassObject, challengeId: str = None, actionType: enum.Enum = None):
                ClassObject.challengeId = challengeId
                ClassObject.actionType = actionType
                ClassObject.response: requests.Response = None


        class RetractDialogResponse:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class RetryApprovalRequest:
            def __init__(ClassObject, challengeId: str = None, actionType: enum.Enum = None):
                ClassObject.challengeId = challengeId
                ClassObject.actionType = actionType
                ClassObject.response: requests.Response = None


        class RetryApprovalResponse:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class SendCodeRequest:
            def __init__(ClassObject, challengeId: str = None, actionType: enum.Enum = None):
                ClassObject.challengeId = challengeId
                ClassObject.actionType = actionType
                ClassObject.response: requests.Response = None


        class UserConfigurationMethod:
            def __init__(ClassObject, mediaType: enum.Enum = None, enabled: bool = None, updated: str = None):
                ClassObject.mediaType = mediaType
                ClassObject.enabled = enabled
                ClassObject.updated = updated
                ClassObject.response: requests.Response = None


        class UserConfiguration:
            def __init__(ClassObject, primaryMediaType: enum.Enum = None, methods: list["RobloxClient.TwoStepVerification.UserConfigurationMethod"] = None):
                ClassObject.primaryMediaType = primaryMediaType
                ClassObject.methods = methods
                ClassObject.response: requests.Response = None


        class VerifyApprovalRequest:
            def __init__(ClassObject, challengeId: str = None, actionType: enum.Enum = None):
                ClassObject.challengeId = challengeId
                ClassObject.actionType = actionType
                ClassObject.response: requests.Response = None


        class VerifyApprovalResponse:
            def __init__(ClassObject, verificationToken: str = None):
                ClassObject.verificationToken = verificationToken
                ClassObject.response: requests.Response = None


        class VerifyCodeRequest:
            def __init__(ClassObject, challengeId: str = None, actionType: enum.Enum = None, code: str = None):
                ClassObject.challengeId = challengeId
                ClassObject.actionType = actionType
                ClassObject.code = code
                ClassObject.response: requests.Response = None


        class VerifyCodeResponse:
            def __init__(ClassObject, verificationToken: str = None):
                ClassObject.verificationToken = verificationToken
                ClassObject.response: requests.Response = None


        class VerifyStartSecurityKeyResponse:
            def __init__(ClassObject, authenticationOptions: str = None, sessionId: str = None):
                ClassObject.authenticationOptions = authenticationOptions
                ClassObject.sessionId = sessionId
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass


        
        def GetMetadata(self, userId: int, challengeId: str, actionType: int) -> MetadataResponse:
            """
            Gets two step verification system metadata.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.GetMetadata(userId=integer, challengeId=string, actionType=integer)
        
            Args:
                userId: int
            challengeId: str
            actionType: int
            Returns:
                TwoStepVerification.MetadataResponse: TwoStepVerification.MetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"userId": userId, "challengeId": challengeId, "actionType": actionType},"headers": {},"cookies": {}}
            
            GetMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://TwoStepVerification.roblox.com/v1/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.MetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetMetadataRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridConfiguration(self, challengeId: str, actionType: int, userId: int) -> UserConfiguration:
            """
            Gets two step verification configuration for the specified user.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.GetUsersUseridConfiguration(challengeId=string, actionType=integer, userId=integer)
        
            Args:
                challengeId: str
            actionType: int
            userId: int
            Returns:
                TwoStepVerification.UserConfiguration: TwoStepVerification.UserConfiguration
            """
        
            Dictinary = {"json": {},"data": {},"params": {"challengeId": challengeId, "actionType": actionType},"headers": {},"cookies": {}}
            
            GetUsersUseridConfigurationRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/configuration", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.UserConfiguration()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridConfigurationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridConfigurationRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridRecoveryCodes(self, userId: int) -> RecoveryCodesStatusResponse:
            """
            Gets the current status of recovery codes for a user.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.GetUsersUseridRecoveryCodes(userId=integer)
        
            Args:
                userId: int
            Returns:
                TwoStepVerification.RecoveryCodesStatusResponse: TwoStepVerification.RecoveryCodesStatusResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridRecoveryCodesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/recovery-codes", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.RecoveryCodesStatusResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridRecoveryCodesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridRecoveryCodesRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridChallengesAuthenticatorVerify(self, userId: int, VerifyCodeRequest: VerifyCodeRequest) -> VerifyCodeResponse:
            """
            Verifies a two step verification challenge code via authenticator app.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridChallengesAuthenticatorVerify(userId=integer, VerifyCodeRequest=TwoStepVerification.VerifyCodeRequest())
        
            Args:
                userId: int
            VerifyCodeRequest: VerifyCodeRequest
            Returns:
                TwoStepVerification.VerifyCodeResponse: TwoStepVerification.VerifyCodeResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VerifyCodeRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridChallengesAuthenticatorVerify)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridChallengesAuthenticatorVerifyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/challenges/authenticator/verify", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.VerifyCodeResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridChallengesAuthenticatorVerifyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridChallengesAuthenticatorVerifyRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridChallengesCrossDeviceRetract(self, userId: int, RetractDialogRequest: RetractDialogRequest) -> RetractDialogResponse:
            """
            Reverts a user's dialog state from ACTIVE to PENDING.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridChallengesCrossDeviceRetract(userId=integer, RetractDialogRequest=TwoStepVerification.RetractDialogRequest())
        
            Args:
                userId: int
            RetractDialogRequest: RetractDialogRequest
            Returns:
                TwoStepVerification.RetractDialogResponse: TwoStepVerification.RetractDialogResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RetractDialogRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridChallengesCrossDeviceRetract)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridChallengesCrossDeviceRetractRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/challenges/cross-device/retract", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.RetractDialogResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridChallengesCrossDeviceRetractRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridChallengesCrossDeviceRetractRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridChallengesCrossDeviceRetry(self, userId: int, RetryApprovalRequest: RetryApprovalRequest) -> RetryApprovalResponse:
            """
            Retry a Cross Device two step verification approval.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridChallengesCrossDeviceRetry(userId=integer, RetryApprovalRequest=TwoStepVerification.RetryApprovalRequest())
        
            Args:
                userId: int
            RetryApprovalRequest: RetryApprovalRequest
            Returns:
                TwoStepVerification.RetryApprovalResponse: TwoStepVerification.RetryApprovalResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RetryApprovalRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridChallengesCrossDeviceRetry)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridChallengesCrossDeviceRetryRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/challenges/cross-device/retry", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.RetryApprovalResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridChallengesCrossDeviceRetryRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridChallengesCrossDeviceRetryRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridChallengesCrossDeviceVerify(self, userId: int, VerifyApprovalRequest: VerifyApprovalRequest) -> VerifyApprovalResponse:
            """
            Verifies a two step verification approval via Cross Device. Cross Device approval does not use a verification code.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridChallengesCrossDeviceVerify(userId=integer, VerifyApprovalRequest=TwoStepVerification.VerifyApprovalRequest())
        
            Args:
                userId: int
            VerifyApprovalRequest: VerifyApprovalRequest
            Returns:
                TwoStepVerification.VerifyApprovalResponse: TwoStepVerification.VerifyApprovalResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VerifyApprovalRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridChallengesCrossDeviceVerify)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridChallengesCrossDeviceVerifyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/challenges/cross-device/verify", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.VerifyApprovalResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridChallengesCrossDeviceVerifyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridChallengesCrossDeviceVerifyRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridChallengesEmailSendCode(self, userId: int, SendCodeRequest: SendCodeRequest) -> ApiEmptyResponseModel:
            """
            Sends a two step verification challenge code via email.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridChallengesEmailSendCode(userId=integer, SendCodeRequest=TwoStepVerification.SendCodeRequest())
        
            Args:
                userId: int
            SendCodeRequest: SendCodeRequest
            Returns:
                TwoStepVerification.ApiEmptyResponseModel: TwoStepVerification.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SendCodeRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridChallengesEmailSendCode)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridChallengesEmailSendCodeRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/challenges/email/send-code", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridChallengesEmailSendCodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridChallengesEmailSendCodeRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridChallengesEmailVerify(self, userId: int, VerifyCodeRequest: VerifyCodeRequest) -> VerifyCodeResponse:
            """
            Verifies a two step verification challenge with a code sent via email.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridChallengesEmailVerify(userId=integer, VerifyCodeRequest=TwoStepVerification.VerifyCodeRequest())
        
            Args:
                userId: int
            VerifyCodeRequest: VerifyCodeRequest
            Returns:
                TwoStepVerification.VerifyCodeResponse: TwoStepVerification.VerifyCodeResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VerifyCodeRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridChallengesEmailVerify)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridChallengesEmailVerifyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/challenges/email/verify", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.VerifyCodeResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridChallengesEmailVerifyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridChallengesEmailVerifyRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridChallengesRecoveryCodesVerify(self, userId: int, VerifyCodeRequest: VerifyCodeRequest) -> VerifyCodeResponse:
            """
            Verifies a two step verification challenge via a recovery code.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridChallengesRecoveryCodesVerify(userId=integer, VerifyCodeRequest=TwoStepVerification.VerifyCodeRequest())
        
            Args:
                userId: int
            VerifyCodeRequest: VerifyCodeRequest
            Returns:
                TwoStepVerification.VerifyCodeResponse: TwoStepVerification.VerifyCodeResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VerifyCodeRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridChallengesRecoveryCodesVerify)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridChallengesRecoveryCodesVerifyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/challenges/recovery-codes/verify", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.VerifyCodeResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridChallengesRecoveryCodesVerifyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridChallengesRecoveryCodesVerifyRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridChallengesSecurityKeyVerifyFinish(self, userId: int, VerifyCodeRequest: VerifyCodeRequest) -> VerifyCodeResponse:
            """
            Validates the assertion data returned by the security key.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridChallengesSecurityKeyVerifyFinish(userId=integer, VerifyCodeRequest=TwoStepVerification.VerifyCodeRequest())
        
            Args:
                userId: int
            VerifyCodeRequest: VerifyCodeRequest
            Returns:
                TwoStepVerification.VerifyCodeResponse: TwoStepVerification.VerifyCodeResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VerifyCodeRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridChallengesSecurityKeyVerifyFinish)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridChallengesSecurityKeyVerifyFinishRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/challenges/security-key/verify-finish", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.VerifyCodeResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridChallengesSecurityKeyVerifyFinishRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridChallengesSecurityKeyVerifyFinishRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridChallengesSecurityKeyVerifyStart(self, userId: int, SendCodeRequest: SendCodeRequest) -> VerifyStartSecurityKeyResponse:
            """
            Provides a challenge for the security key to authenticate.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridChallengesSecurityKeyVerifyStart(userId=integer, SendCodeRequest=TwoStepVerification.SendCodeRequest())
        
            Args:
                userId: int
            SendCodeRequest: SendCodeRequest
            Returns:
                TwoStepVerification.VerifyStartSecurityKeyResponse: TwoStepVerification.VerifyStartSecurityKeyResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SendCodeRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridChallengesSecurityKeyVerifyStart)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridChallengesSecurityKeyVerifyStartRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/challenges/security-key/verify-start", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.VerifyStartSecurityKeyResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridChallengesSecurityKeyVerifyStartRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridChallengesSecurityKeyVerifyStartRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridChallengesSmsSendCode(self, userId: int, SendCodeRequest: SendCodeRequest) -> ApiEmptyResponseModel:
            """
            Sends a two step verification code via SMS for the specified user.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridChallengesSmsSendCode(userId=integer, SendCodeRequest=TwoStepVerification.SendCodeRequest())
        
            Args:
                userId: int
            SendCodeRequest: SendCodeRequest
            Returns:
                TwoStepVerification.ApiEmptyResponseModel: TwoStepVerification.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SendCodeRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridChallengesSmsSendCode)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridChallengesSmsSendCodeRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/challenges/sms/send-code", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridChallengesSmsSendCodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridChallengesSmsSendCodeRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridChallengesSmsVerify(self, userId: int, VerifyCodeRequest: VerifyCodeRequest) -> VerifyCodeResponse:
            """
            Verifies a two step verification challenge with a code sent via SMS.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridChallengesSmsVerify(userId=integer, VerifyCodeRequest=TwoStepVerification.VerifyCodeRequest())
        
            Args:
                userId: int
            VerifyCodeRequest: VerifyCodeRequest
            Returns:
                TwoStepVerification.VerifyCodeResponse: TwoStepVerification.VerifyCodeResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VerifyCodeRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridChallengesSmsVerify)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridChallengesSmsVerifyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/challenges/sms/verify", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.VerifyCodeResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridChallengesSmsVerifyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridChallengesSmsVerifyRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridConfigurationAuthenticatorDisable(self, userId: int, DisableTwoStepVerificationRequest: DisableTwoStepVerificationRequest) -> ApiEmptyResponseModel:
            """
            Disables two step verification via authenticator for the specified user.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridConfigurationAuthenticatorDisable(userId=integer, DisableTwoStepVerificationRequest=TwoStepVerification.DisableTwoStepVerificationRequest())
        
            Args:
                userId: int
            DisableTwoStepVerificationRequest: DisableTwoStepVerificationRequest
            Returns:
                TwoStepVerification.ApiEmptyResponseModel: TwoStepVerification.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'DisableTwoStepVerificationRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridConfigurationAuthenticatorDisable)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridConfigurationAuthenticatorDisableRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/configuration/authenticator/disable", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridConfigurationAuthenticatorDisableRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridConfigurationAuthenticatorDisableRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridConfigurationAuthenticatorEnable(self, userId: int, EnableTwoStepVerificationRequest: EnableTwoStepVerificationRequest) -> EnableAuthenticatorResponse:
            """
            Initiates enabling authenticator-based two step verification for the specified user.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridConfigurationAuthenticatorEnable(userId=integer, EnableTwoStepVerificationRequest=TwoStepVerification.EnableTwoStepVerificationRequest())
        
            Args:
                userId: int
            EnableTwoStepVerificationRequest: EnableTwoStepVerificationRequest
            Returns:
                TwoStepVerification.EnableAuthenticatorResponse: TwoStepVerification.EnableAuthenticatorResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'EnableTwoStepVerificationRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridConfigurationAuthenticatorEnable)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridConfigurationAuthenticatorEnableRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/configuration/authenticator/enable", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.EnableAuthenticatorResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridConfigurationAuthenticatorEnableRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridConfigurationAuthenticatorEnableRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridConfigurationAuthenticatorEnableVerify(self, userId: int, EnableVerifyAuthenticatorRequest: EnableVerifyAuthenticatorRequest) -> EnableVerifyAuthenticatorResponse:
            """
            Finishes enabling authenticator-based two step verification for the specified user.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridConfigurationAuthenticatorEnableVerify(userId=integer, EnableVerifyAuthenticatorRequest=TwoStepVerification.EnableVerifyAuthenticatorRequest())
        
            Args:
                userId: int
            EnableVerifyAuthenticatorRequest: EnableVerifyAuthenticatorRequest
            Returns:
                TwoStepVerification.EnableVerifyAuthenticatorResponse: TwoStepVerification.EnableVerifyAuthenticatorResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'EnableVerifyAuthenticatorRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridConfigurationAuthenticatorEnableVerify)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridConfigurationAuthenticatorEnableVerifyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/configuration/authenticator/enable-verify", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.EnableVerifyAuthenticatorResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridConfigurationAuthenticatorEnableVerifyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridConfigurationAuthenticatorEnableVerifyRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridConfigurationEmailDisable(self, userId: int, DisableTwoStepVerificationRequest: DisableTwoStepVerificationRequest) -> ApiEmptyResponseModel:
            """
            Disables two step verification via email for the specified user.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridConfigurationEmailDisable(userId=integer, DisableTwoStepVerificationRequest=TwoStepVerification.DisableTwoStepVerificationRequest())
        
            Args:
                userId: int
            DisableTwoStepVerificationRequest: DisableTwoStepVerificationRequest
            Returns:
                TwoStepVerification.ApiEmptyResponseModel: TwoStepVerification.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'DisableTwoStepVerificationRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridConfigurationEmailDisable)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridConfigurationEmailDisableRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/configuration/email/disable", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridConfigurationEmailDisableRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridConfigurationEmailDisableRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridConfigurationEmailEnable(self, userId: int, EnableTwoStepVerificationRequest: EnableTwoStepVerificationRequest) -> ApiEmptyResponseModel:
            """
            Enables two step verification via email for the specified user.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridConfigurationEmailEnable(userId=integer, EnableTwoStepVerificationRequest=TwoStepVerification.EnableTwoStepVerificationRequest())
        
            Args:
                userId: int
            EnableTwoStepVerificationRequest: EnableTwoStepVerificationRequest
            Returns:
                TwoStepVerification.ApiEmptyResponseModel: TwoStepVerification.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'EnableTwoStepVerificationRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridConfigurationEmailEnable)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridConfigurationEmailEnableRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/configuration/email/enable", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridConfigurationEmailEnableRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridConfigurationEmailEnableRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridConfigurationSecurityKeyDisable(self, userId: int, DisableSecurityKeyRequest: DisableSecurityKeyRequest) -> ApiEmptyResponseModel:
            """
            Disables a batch of credentials for the specified user.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridConfigurationSecurityKeyDisable(userId=integer, DisableSecurityKeyRequest=TwoStepVerification.DisableSecurityKeyRequest())
        
            Args:
                userId: int
            DisableSecurityKeyRequest: DisableSecurityKeyRequest
            Returns:
                TwoStepVerification.ApiEmptyResponseModel: TwoStepVerification.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'DisableSecurityKeyRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridConfigurationSecurityKeyDisable)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridConfigurationSecurityKeyDisableRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/configuration/security-key/disable", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridConfigurationSecurityKeyDisableRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridConfigurationSecurityKeyDisableRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridConfigurationSecurityKeyEnable(self, userId: int, EnableTwoStepVerificationRequest: EnableTwoStepVerificationRequest) -> EnableSecurityKeyResponse:
            """
            Initiates security key registration by providing credential creation options.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridConfigurationSecurityKeyEnable(userId=integer, EnableTwoStepVerificationRequest=TwoStepVerification.EnableTwoStepVerificationRequest())
        
            Args:
                userId: int
            EnableTwoStepVerificationRequest: EnableTwoStepVerificationRequest
            Returns:
                TwoStepVerification.EnableSecurityKeyResponse: TwoStepVerification.EnableSecurityKeyResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'EnableTwoStepVerificationRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridConfigurationSecurityKeyEnable)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridConfigurationSecurityKeyEnableRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/configuration/security-key/enable", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.EnableSecurityKeyResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridConfigurationSecurityKeyEnableRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridConfigurationSecurityKeyEnableRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridConfigurationSecurityKeyEnableVerify(self, userId: int, EnableVerifySecurityKeyRequest: EnableVerifySecurityKeyRequest) -> ApiEmptyResponseModel:
            """
            Finishes security key registration and stores credential. Enables security key as a 2sv media type if it is a user's first key.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridConfigurationSecurityKeyEnableVerify(userId=integer, EnableVerifySecurityKeyRequest=TwoStepVerification.EnableVerifySecurityKeyRequest())
        
            Args:
                userId: int
            EnableVerifySecurityKeyRequest: EnableVerifySecurityKeyRequest
            Returns:
                TwoStepVerification.ApiEmptyResponseModel: TwoStepVerification.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'EnableVerifySecurityKeyRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridConfigurationSecurityKeyEnableVerify)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridConfigurationSecurityKeyEnableVerifyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/configuration/security-key/enable-verify", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridConfigurationSecurityKeyEnableVerifyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridConfigurationSecurityKeyEnableVerifyRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridConfigurationSecurityKeyList(self, userId: int) -> ListSecurityKeyResponse:
            """
            List a user's registered security keys.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridConfigurationSecurityKeyList(userId=integer)
        
            Args:
                userId: int
            Returns:
                TwoStepVerification.ListSecurityKeyResponse: TwoStepVerification.ListSecurityKeyResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostUsersUseridConfigurationSecurityKeyListRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/configuration/security-key/list", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.ListSecurityKeyResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridConfigurationSecurityKeyListRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridConfigurationSecurityKeyListRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridConfigurationSmsDisable(self, userId: int, DisableTwoStepVerificationRequest: DisableTwoStepVerificationRequest) -> ApiEmptyResponseModel:
            """
            Disables two step verification via SMS for the specified user.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridConfigurationSmsDisable(userId=integer, DisableTwoStepVerificationRequest=TwoStepVerification.DisableTwoStepVerificationRequest())
        
            Args:
                userId: int
            DisableTwoStepVerificationRequest: DisableTwoStepVerificationRequest
            Returns:
                TwoStepVerification.ApiEmptyResponseModel: TwoStepVerification.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'DisableTwoStepVerificationRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridConfigurationSmsDisable)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridConfigurationSmsDisableRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/configuration/sms/disable", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridConfigurationSmsDisableRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridConfigurationSmsDisableRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridConfigurationSmsEnable(self, userId: int, EnableTwoStepVerificationRequest: EnableTwoStepVerificationRequest) -> ApiEmptyResponseModel:
            """
            Enables two step verification via SMS for the specified user.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridConfigurationSmsEnable(userId=integer, EnableTwoStepVerificationRequest=TwoStepVerification.EnableTwoStepVerificationRequest())
        
            Args:
                userId: int
            EnableTwoStepVerificationRequest: EnableTwoStepVerificationRequest
            Returns:
                TwoStepVerification.ApiEmptyResponseModel: TwoStepVerification.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'EnableTwoStepVerificationRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridConfigurationSmsEnable)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridConfigurationSmsEnableRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/configuration/sms/enable", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridConfigurationSmsEnableRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridConfigurationSmsEnableRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridRecoveryCodesClear(self, userId: int, ClearRecoveryCodesRequest: ClearRecoveryCodesRequest) -> ApiEmptyResponseModel:
            """
            Clears any existing recovery codes for the user.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridRecoveryCodesClear(userId=integer, ClearRecoveryCodesRequest=TwoStepVerification.ClearRecoveryCodesRequest())
        
            Args:
                userId: int
            ClearRecoveryCodesRequest: ClearRecoveryCodesRequest
            Returns:
                TwoStepVerification.ApiEmptyResponseModel: TwoStepVerification.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'ClearRecoveryCodesRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridRecoveryCodesClear)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridRecoveryCodesClearRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/recovery-codes/clear", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridRecoveryCodesClearRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridRecoveryCodesClearRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridRecoveryCodesRegenerate(self, userId: int, RegenerateRecoveryCodesRequest: RegenerateRecoveryCodesRequest) -> RegenerateRecoveryCodesResponse:
            """
            Clears any existing recovery codes and generates a new batch of recovery codes.
            
            Usage:
                import TwoStepVerification
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TwoStepVerificationApi = TwoStepVerification.TwoStepVerificationApi(RobloxClient=RobloxClient)
                Response = TwoStepVerificationApi.PostUsersUseridRecoveryCodesRegenerate(userId=integer, RegenerateRecoveryCodesRequest=TwoStepVerification.RegenerateRecoveryCodesRequest())
        
            Args:
                userId: int
            RegenerateRecoveryCodesRequest: RegenerateRecoveryCodesRequest
            Returns:
                TwoStepVerification.RegenerateRecoveryCodesResponse: TwoStepVerification.RegenerateRecoveryCodesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RegenerateRecoveryCodesRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersUseridRecoveryCodesRegenerate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersUseridRecoveryCodesRegenerateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://TwoStepVerification.roblox.com/v1/users/{userId}/recovery-codes/regenerate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TwoStepVerification.RegenerateRecoveryCodesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridRecoveryCodesRegenerateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridRecoveryCodesRegenerateRecivedData)
            
            return ResponseSchema
        
    class TranslationRoles:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class Assignee:
            def __init__(ClassObject, assigneeType: enum.Enum = None, id: int = None):
                ClassObject.assigneeType = assigneeType
                ClassObject.id = id
                ClassObject.response: requests.Response = None


        class GameLocalizationRoleAssignment:
            def __init__(ClassObject, gameId: int = None, assignee: "RobloxClient.TranslationRoles.Assignee" = None):
                ClassObject.gameId = gameId
                ClassObject.assignee = assignee
                ClassObject.response: requests.Response = None


        class GetGameLocalizationRoleAssignmentsForUserResponse:
            def __init__(ClassObject, games: list["RobloxClient.TranslationRoles.GameLocalizationRoleAssignment"] = None, previousPageCursor: str = None, nextPageCursor: str = None):
                ClassObject.games = games
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.response: requests.Response = None


        class UpdateRoleRequest:
            def __init__(ClassObject, assigneeId: int = None, assigneeType: enum.Enum = None, role: enum.Enum = None, revoke: bool = None):
                ClassObject.assigneeId = assigneeId
                ClassObject.assigneeType = assigneeType
                ClassObject.role = role
                ClassObject.revoke = revoke
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class AssigneeExtra:
            def __init__(ClassObject, data: list["RobloxClient.TranslationRoles.Assignee"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class StringExtra:
            def __init__(ClassObject, data: list[str] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetGameLocalizationRolesGamesGameidCurrentUserRoles(self, gameId: int) -> StringExtra:
            """
            Retrieves the list of roles granted to current logged-in user
            
            Usage:
                import TranslationRoles
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TranslationRolesApi = TranslationRoles.TranslationRolesApi(RobloxClient=RobloxClient)
                Response = TranslationRolesApi.GetGameLocalizationRolesGamesGameidCurrentUserRoles(gameId=integer)
        
            Args:
                gameId: int
            Returns:
                TranslationRoles.StringExtra: TranslationRoles.StringExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGameLocalizationRolesGamesGameidCurrentUserRolesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://TranslationRoles.roblox.com/v1/game-localization-roles/games/{gameId}/current-user/roles", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TranslationRoles.StringExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGameLocalizationRolesGamesGameidCurrentUserRolesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGameLocalizationRolesGamesGameidCurrentUserRolesRecivedData)
            
            return ResponseSchema
        
        def GetGameLocalizationRolesGamesGameidRolesRoleAssignees(self, gameId: int, role: str) -> AssigneeExtra:
            """
            Gets list of users assigned a specific role in a game.
            
            Usage:
                import TranslationRoles
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TranslationRolesApi = TranslationRoles.TranslationRolesApi(RobloxClient=RobloxClient)
                Response = TranslationRolesApi.GetGameLocalizationRolesGamesGameidRolesRoleAssignees(gameId=integer, role=string)
        
            Args:
                gameId: int
            role: str
            Returns:
                TranslationRoles.AssigneeExtra: TranslationRoles.AssigneeExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGameLocalizationRolesGamesGameidRolesRoleAssigneesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://TranslationRoles.roblox.com/v1/game-localization-roles/games/{gameId}/roles/{role}/assignees", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TranslationRoles.AssigneeExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGameLocalizationRolesGamesGameidRolesRoleAssigneesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGameLocalizationRolesGamesGameidRolesRoleAssigneesRecivedData)
            
            return ResponseSchema
        
        def GetGameLocalizationRolesRolesRoleCurrentUser(self, exclusiveStartKey: str, pageSize: int, groupId: int, role: str) -> GetGameLocalizationRoleAssignmentsForUserResponse:
            """
            Gets the list of games and associated role assignment info for the requested user and role.
            
            Usage:
                import TranslationRoles
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TranslationRolesApi = TranslationRoles.TranslationRolesApi(RobloxClient=RobloxClient)
                Response = TranslationRolesApi.GetGameLocalizationRolesRolesRoleCurrentUser(exclusiveStartKey=string, pageSize=integer, groupId=integer, role=string)
        
            Args:
                exclusiveStartKey: str
            pageSize: int
            groupId: int
            role: str
            Returns:
                TranslationRoles.GetGameLocalizationRoleAssignmentsForUserResponse: TranslationRoles.GetGameLocalizationRoleAssignmentsForUserResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"exclusiveStartKey": exclusiveStartKey, "pageSize": pageSize, "groupId": groupId},"headers": {},"cookies": {}}
            
            GetGameLocalizationRolesRolesRoleCurrentUserRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://TranslationRoles.roblox.com/v1/game-localization-roles/roles/{role}/current-user", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TranslationRoles.GetGameLocalizationRoleAssignmentsForUserResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGameLocalizationRolesRolesRoleCurrentUserRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGameLocalizationRolesRolesRoleCurrentUserRecivedData)
            
            return ResponseSchema
        
        def PatchGameLocalizationRolesGamesGameid(self, gameId: int, UpdateRoleRequest: UpdateRoleRequest) -> ApiEmptyResponseModel:
            """
            Assigns or revokes a role
            
            Usage:
                import TranslationRoles
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TranslationRolesApi = TranslationRoles.TranslationRolesApi(RobloxClient=RobloxClient)
                Response = TranslationRolesApi.PatchGameLocalizationRolesGamesGameid(gameId=integer, UpdateRoleRequest=TranslationRoles.UpdateRoleRequest())
        
            Args:
                gameId: int
            UpdateRoleRequest: UpdateRoleRequest
            Returns:
                TranslationRoles.ApiEmptyResponseModel: TranslationRoles.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateRoleRequest': 'json'}
            Arguments = inspect.signature(self.PatchGameLocalizationRolesGamesGameid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGameLocalizationRolesGamesGameidRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://TranslationRoles.roblox.com/v1/game-localization-roles/games/{gameId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.TranslationRoles.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGameLocalizationRolesGamesGameidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGameLocalizationRolesGamesGameidRecivedData)
            
            return ResponseSchema
        
    class Trades:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class Int64Extra:
            def __init__(ClassObject, SortOrder: enum.Enum = None, PagingDirection: enum.Enum = None, Count: int = None):
                ClassObject.SortOrder = SortOrder
                ClassObject.PagingDirection = PagingDirection
                ClassObject.Count = Count
                ClassObject.response: requests.Response = None


        class CanTradeResponse:
            def __init__(ClassObject, canTrade: bool = None, status: enum.Enum = None):
                ClassObject.canTrade = canTrade
                ClassObject.status = status
                ClassObject.response: requests.Response = None


        class NewTradeResponse:
            def __init__(ClassObject, id: int = None):
                ClassObject.id = id
                ClassObject.response: requests.Response = None


        class TradeCountResponse:
            def __init__(ClassObject, count: int = None):
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class SkinnyUserResponse:
            def __init__(ClassObject, id: int = None, name: str = None, displayName: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class UserAssetResponse:
            def __init__(ClassObject, id: int = None, serialNumber: int = None, assetId: int = None, name: str = None, recentAveragePrice: int = None, originalPrice: int = None, assetStock: int = None, membershipType: enum.Enum = None):
                ClassObject.id = id
                ClassObject.serialNumber = serialNumber
                ClassObject.assetId = assetId
                ClassObject.name = name
                ClassObject.recentAveragePrice = recentAveragePrice
                ClassObject.originalPrice = originalPrice
                ClassObject.assetStock = assetStock
                ClassObject.membershipType = membershipType
                ClassObject.response: requests.Response = None


        class TradeOfferResponse:
            def __init__(ClassObject, user: "RobloxClient.Trades.SkinnyUserResponse" = None, userAssets: list["RobloxClient.Trades.UserAssetResponse"] = None, robux: int = None):
                ClassObject.user = user
                ClassObject.userAssets = userAssets
                ClassObject.robux = robux
                ClassObject.response: requests.Response = None


        class TradeDetailResponse:
            def __init__(ClassObject, offers: list["RobloxClient.Trades.TradeOfferResponse"] = None, id: int = None, user: "RobloxClient.Trades.SkinnyUserResponse" = None, created: str = None, expiration: str = None, isActive: bool = None, status: enum.Enum = None):
                ClassObject.offers = offers
                ClassObject.id = id
                ClassObject.user = user
                ClassObject.created = created
                ClassObject.expiration = expiration
                ClassObject.isActive = isActive
                ClassObject.status = status
                ClassObject.response: requests.Response = None


        class TradeMetadata:
            def __init__(ClassObject, maxItemsPerSide: int = None, minValueRatio: float = None, tradeSystemMaxRobuxPercent: float = None, tradeSystemRobuxFee: float = None):
                ClassObject.maxItemsPerSide = maxItemsPerSide
                ClassObject.minValueRatio = minValueRatio
                ClassObject.tradeSystemMaxRobuxPercent = tradeSystemMaxRobuxPercent
                ClassObject.tradeSystemRobuxFee = tradeSystemRobuxFee
                ClassObject.response: requests.Response = None


        class TradeOfferRequest:
            def __init__(ClassObject, userId: int = None, userAssetIds: list[int] = None, robux: int = None):
                ClassObject.userId = userId
                ClassObject.userAssetIds = userAssetIds
                ClassObject.robux = robux
                ClassObject.response: requests.Response = None


        class TradeRequest:
            def __init__(ClassObject, offers: list["RobloxClient.Trades.TradeOfferRequest"] = None):
                ClassObject.offers = offers
                ClassObject.response: requests.Response = None


        class TradeResponse:
            def __init__(ClassObject, id: int = None, user: "RobloxClient.Trades.SkinnyUserResponse" = None, created: str = None, expiration: str = None, isActive: bool = None, status: enum.Enum = None):
                ClassObject.id = id
                ClassObject.user = user
                ClassObject.created = created
                ClassObject.expiration = expiration
                ClassObject.isActive = isActive
                ClassObject.status = status
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class TradeResponseExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Trades.TradeResponse"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetTradesTradeid(self, tradeId: int) -> TradeDetailResponse:
            """
            Gets detailed information about a trade.
            
            Usage:
                import Trades
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TradesApi = Trades.TradesApi(RobloxClient=RobloxClient)
                Response = TradesApi.GetTradesTradeid(tradeId=integer)
        
            Args:
                tradeId: int
            Returns:
                Trades.TradeDetailResponse: Trades.TradeDetailResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetTradesTradeidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Trades.roblox.com/v1/trades/{tradeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Trades.TradeDetailResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetTradesTradeidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetTradesTradeidRecivedData)
            
            return ResponseSchema
        
        def GetTradesTradestatustype(self, limit: int, cursor: str, sortOrder: str, tradeStatusType: int) -> TradeResponseExtra:
            """
            Fetches a list of the authenticated user's trades.
            
            Usage:
                import Trades
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TradesApi = Trades.TradesApi(RobloxClient=RobloxClient)
                Response = TradesApi.GetTradesTradestatustype(limit=integer, cursor=string, sortOrder=string, tradeStatusType=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            tradeStatusType: int
            Returns:
                Trades.TradeResponseExtra: Trades.TradeResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetTradesTradestatustypeRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Trades.roblox.com/v1/trades/{tradeStatusType}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Trades.TradeResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetTradesTradestatustypeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetTradesTradestatustypeRecivedData)
            
            return ResponseSchema
        
        def GetTradesTradestatustypeCount(self, tradeStatusType: int) -> TradeCountResponse:
            """
            Gets the total number of pending trades for the authenticated user.

Inbound is the only accepted tradeStatusType.
            
            Usage:
                import Trades
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TradesApi = Trades.TradesApi(RobloxClient=RobloxClient)
                Response = TradesApi.GetTradesTradestatustypeCount(tradeStatusType=integer)
        
            Args:
                tradeStatusType: int
            Returns:
                Trades.TradeCountResponse: Trades.TradeCountResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetTradesTradestatustypeCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Trades.roblox.com/v1/trades/{tradeStatusType}/count", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Trades.TradeCountResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetTradesTradestatustypeCountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetTradesTradestatustypeCountRecivedData)
            
            return ResponseSchema
        
        def GetTradesMetadata(self) -> TradeMetadata:
            """
            Gets metadata about the trade system.
            
            Usage:
                import Trades
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TradesApi = Trades.TradesApi(RobloxClient=RobloxClient)
                Response = TradesApi.GetTradesMetadata()
        
            Args:
                
            Returns:
                Trades.TradeMetadata: Trades.TradeMetadata
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetTradesMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Trades.roblox.com/v1/trades/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Trades.TradeMetadata()
        
            ReturnedJson = None
            try: ReturnedJson = GetTradesMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetTradesMetadataRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridCanTradeWith(self, userId: int) -> CanTradeResponse:
            """
            Returns whether you can trade with another user.
            
            Usage:
                import Trades
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TradesApi = Trades.TradesApi(RobloxClient=RobloxClient)
                Response = TradesApi.GetUsersUseridCanTradeWith(userId=integer)
        
            Args:
                userId: int
            Returns:
                Trades.CanTradeResponse: Trades.CanTradeResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridCanTradeWithRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Trades.roblox.com/v1/users/{userId}/can-trade-with", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Trades.CanTradeResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridCanTradeWithRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridCanTradeWithRecivedData)
            
            return ResponseSchema
        
        def PostTradesTradeidAccept(self, tradeId: int) -> ApiEmptyResponseModel:
            """
            Accepts a trade.
            
            Usage:
                import Trades
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TradesApi = Trades.TradesApi(RobloxClient=RobloxClient)
                Response = TradesApi.PostTradesTradeidAccept(tradeId=integer)
        
            Args:
                tradeId: int
            Returns:
                Trades.ApiEmptyResponseModel: Trades.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostTradesTradeidAcceptRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Trades.roblox.com/v1/trades/{tradeId}/accept", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Trades.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostTradesTradeidAcceptRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTradesTradeidAcceptRecivedData)
            
            return ResponseSchema
        
        def PostTradesTradeidCounter(self, tradeId: int, TradeRequest: TradeRequest) -> NewTradeResponse:
            """
            Counters a trade.
            
            Usage:
                import Trades
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TradesApi = Trades.TradesApi(RobloxClient=RobloxClient)
                Response = TradesApi.PostTradesTradeidCounter(tradeId=integer, TradeRequest=Trades.TradeRequest())
        
            Args:
                tradeId: int
            TradeRequest: TradeRequest
            Returns:
                Trades.NewTradeResponse: Trades.NewTradeResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'TradeRequest': 'json'}
            Arguments = inspect.signature(self.PostTradesTradeidCounter)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostTradesTradeidCounterRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Trades.roblox.com/v1/trades/{tradeId}/counter", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Trades.NewTradeResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostTradesTradeidCounterRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTradesTradeidCounterRecivedData)
            
            return ResponseSchema
        
        def PostTradesTradeidDecline(self, tradeId: int) -> ApiEmptyResponseModel:
            """
            Declines a trade.
            
            Usage:
                import Trades
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TradesApi = Trades.TradesApi(RobloxClient=RobloxClient)
                Response = TradesApi.PostTradesTradeidDecline(tradeId=integer)
        
            Args:
                tradeId: int
            Returns:
                Trades.ApiEmptyResponseModel: Trades.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostTradesTradeidDeclineRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Trades.roblox.com/v1/trades/{tradeId}/decline", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Trades.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostTradesTradeidDeclineRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTradesTradeidDeclineRecivedData)
            
            return ResponseSchema
        
        def PostTradesExpireOutdated(self) -> ApiEmptyResponseModel:
            """
            Deprecated. TradeSession are automatically set to expire while the inbound/outbound trades are fetched.

Expires Outdated Inbound Trades for User
            
            Usage:
                import Trades
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TradesApi = Trades.TradesApi(RobloxClient=RobloxClient)
                Response = TradesApi.PostTradesExpireOutdated()
        
            Args:
                
            Returns:
                Trades.ApiEmptyResponseModel: Trades.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostTradesExpireOutdatedRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Trades.roblox.com/v1/trades/expire-outdated", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Trades.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostTradesExpireOutdatedRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTradesExpireOutdatedRecivedData)
            
            return ResponseSchema
        
        def PostTradesSend(self, TradeRequest: TradeRequest) -> NewTradeResponse:
            """
            Sends a trade.
            
            Usage:
                import Trades
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                TradesApi = Trades.TradesApi(RobloxClient=RobloxClient)
                Response = TradesApi.PostTradesSend(TradeRequest=Trades.TradeRequest())
        
            Args:
                TradeRequest: TradeRequest
            Returns:
                Trades.NewTradeResponse: Trades.NewTradeResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'TradeRequest': 'json'}
            Arguments = inspect.signature(self.PostTradesSend)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostTradesSendRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Trades.roblox.com/v1/trades/send", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Trades.NewTradeResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostTradesSendRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTradesSendRecivedData)
            
            return ResponseSchema
        
    class ThumbnailsResizer:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient

        
        def GetResizeHashWidthHeightTypeFormatFiltertype(self, filterType: str, shouldModify: bool, hash: str, width: int, height: int, type: str, format: str) -> requests.Response:
            """
            Resizes larger thumbnails to specified size and format
            
            Usage:
                import ThumbnailsResizer
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsResizerApi = ThumbnailsResizer.ThumbnailsResizerApi(RobloxClient=RobloxClient)
                Response = ThumbnailsResizerApi.GetResizeHashWidthHeightTypeFormatFiltertype(filterType=string, shouldModify=boolean, hash=string, width=integer, height=integer, type=string, format=string)
        
            Args:
                filterType: str
            shouldModify: bool
            hash: str
            width: int
            height: int
            type: str
            format: str
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"filterType": filterType, "shouldModify": shouldModify},"headers": {},"cookies": {}}
            
            GetResizeHashWidthHeightTypeFormatFiltertypeRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ThumbnailsResizer.roblox.com/v1/resize/{hash}/{width}/{height}/{type}/{format}/{filterType}", Dictinary=Dictinary)
            return GetResizeHashWidthHeightTypeFormatFiltertypeRecivedData
        
        def GetSecureresizeThumbprintHashWidthHeightTypeFormatFiltertype(self, filterType: str, thumbPrint: str, hash: str, width: int, height: int, type: str, format: str) -> requests.Response:
            """
            Decrypts and Resizes larger thumbnails to specified size and format
            
            Usage:
                import ThumbnailsResizer
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsResizerApi = ThumbnailsResizer.ThumbnailsResizerApi(RobloxClient=RobloxClient)
                Response = ThumbnailsResizerApi.GetSecureresizeThumbprintHashWidthHeightTypeFormatFiltertype(filterType=string, thumbPrint=string, hash=string, width=integer, height=integer, type=string, format=string)
        
            Args:
                filterType: str
            thumbPrint: str
            hash: str
            width: int
            height: int
            type: str
            format: str
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"filterType": filterType},"headers": {},"cookies": {}}
            
            GetSecureresizeThumbprintHashWidthHeightTypeFormatFiltertypeRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ThumbnailsResizer.roblox.com/v1/secureresize/{thumbPrint}/{hash}/{width}/{height}/{type}/{format}/{filterType}", Dictinary=Dictinary)
            return GetSecureresizeThumbprintHashWidthHeightTypeFormatFiltertypeRecivedData
        
    class Thumbnails:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class ApiErrorModel:
            def __init__(ClassObject, code: int = None, message: str = None, userFacingMessage: str = None, field: str = None, fieldData: dict = None):
                ClassObject.code = code
                ClassObject.message = message
                ClassObject.userFacingMessage = userFacingMessage
                ClassObject.field = field
                ClassObject.fieldData = fieldData
                ClassObject.response: requests.Response = None


        class ThumbnailResponse:
            def __init__(ClassObject, targetId: int = None, state: enum.Enum = None, imageUrl: str = None, version: str = None):
                ClassObject.targetId = targetId
                ClassObject.state = state
                ClassObject.imageUrl = imageUrl
                ClassObject.version = version
                ClassObject.response: requests.Response = None


        class UniverseThumbnailsResponse:
            def __init__(ClassObject, universeId: int = None, error: "RobloxClient.Thumbnails.ApiErrorModel" = None, thumbnails: list["RobloxClient.Thumbnails.ThumbnailResponse"] = None):
                ClassObject.universeId = universeId
                ClassObject.error = error
                ClassObject.thumbnails = thumbnails
                ClassObject.response: requests.Response = None


        class ThumbnailBatchRequest:
            def __init__(ClassObject, requestId: str = None, targetId: int = None, token: str = None, alias: str = None, type: enum.Enum = None, size: str = None, format: str = None, isCircular: bool = None):
                ClassObject.requestId = requestId
                ClassObject.targetId = targetId
                ClassObject.token = token
                ClassObject.alias = alias
                ClassObject.type = type
                ClassObject.size = size
                ClassObject.format = format
                ClassObject.isCircular = isCircular
                ClassObject.response: requests.Response = None


        class FormatType:
            def __init__(ClassObject, Name: str = None, Value: int = None):
                ClassObject.Name = Name
                ClassObject.Value = Value
                ClassObject.response: requests.Response = None


        class ImageParameters:
            def __init__(ClassObject, Width: int = None, Height: int = None, Format: "RobloxClient.Thumbnails.FormatType" = None, IsCircular: bool = None, FileExtension: str = None, MimeType: str = None):
                ClassObject.Width = Width
                ClassObject.Height = Height
                ClassObject.Format = Format
                ClassObject.IsCircular = IsCircular
                ClassObject.FileExtension = FileExtension
                ClassObject.MimeType = MimeType
                ClassObject.response: requests.Response = None


        class ThumbnailBatchResponse:
            def __init__(ClassObject, requestId: str = None, errorCode: int = None, errorMessage: str = None, targetId: int = None, state: enum.Enum = None, imageUrl: str = None, version: str = None):
                ClassObject.requestId = requestId
                ClassObject.errorCode = errorCode
                ClassObject.errorMessage = errorMessage
                ClassObject.targetId = targetId
                ClassObject.state = state
                ClassObject.imageUrl = imageUrl
                ClassObject.version = version
                ClassObject.response: requests.Response = None


        class UniverseThumbnailsResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Thumbnails.UniverseThumbnailsResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class ThumbnailBatchResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Thumbnails.ThumbnailBatchResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class ThumbnailResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Thumbnails.ThumbnailResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetAssetThumbnailAnimated(self, assetId: int, Roblox_Place_Id: int) -> ThumbnailResponse:
            """
            Thumbnails asset animated.
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetAssetThumbnailAnimated(assetId=integer, Roblox_Place_Id=integer)
        
            Args:
                assetId: int
            Roblox_Place_Id: int
            Returns:
                Thumbnails.ThumbnailResponse: Thumbnails.ThumbnailResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"assetId": assetId},"headers": {"Roblox_Place_Id": Roblox_Place_Id},"cookies": {}}
            
            GetAssetThumbnailAnimatedRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/asset-thumbnail-animated", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAssetThumbnailAnimatedRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAssetThumbnailAnimatedRecivedData)
            
            return ResponseSchema
        
        def GetAssets(self, assetIds: list, returnPolicy: str, size: str, format: str, isCircular: bool, Roblox_Place_Id: int) -> ThumbnailResponseExtra:
            """
            Thumbnails assets.
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetAssets(assetIds=array, returnPolicy=string, size=string, format=string, isCircular=boolean, Roblox_Place_Id=integer)
        
            Args:
                assetIds: list
            returnPolicy: str
            size: str
            format: str
            isCircular: bool
            Roblox_Place_Id: int
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"assetIds": assetIds, "returnPolicy": returnPolicy, "size": size, "format": format, "isCircular": isCircular},"headers": {"Roblox_Place_Id": Roblox_Place_Id},"cookies": {}}
            
            GetAssetsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/assets", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetAssetsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAssetsRecivedData)
            
            return ResponseSchema
        
        def GetAssetsThumbnail3D(self, assetId: int, Roblox_Place_Id: int) -> ThumbnailResponse:
            """
            Thumbnails assets.
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetAssetsThumbnail3D(assetId=integer, Roblox_Place_Id=integer)
        
            Args:
                assetId: int
            Roblox_Place_Id: int
            Returns:
                Thumbnails.ThumbnailResponse: Thumbnails.ThumbnailResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"assetId": assetId},"headers": {"Roblox_Place_Id": Roblox_Place_Id},"cookies": {}}
            
            GetAssetsThumbnail3DRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/assets-thumbnail-3d", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAssetsThumbnail3DRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAssetsThumbnail3DRecivedData)
            
            return ResponseSchema
        
        def GetBadgesIcons(self, badgeIds: list, size: str, format: str, isCircular: bool) -> ThumbnailResponseExtra:
            """
            Thumbnails badge icons.
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetBadgesIcons(badgeIds=array, size=string, format=string, isCircular=boolean)
        
            Args:
                badgeIds: list
            size: str
            format: str
            isCircular: bool
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"badgeIds": badgeIds, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetBadgesIconsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/badges/icons", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetBadgesIconsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetBadgesIconsRecivedData)
            
            return ResponseSchema
        
        def GetBundlesThumbnails(self, bundleIds: list, size: str, format: str, isCircular: bool) -> ThumbnailResponseExtra:
            """
            Get bundle thumbnails for the given CSV of bundle ids
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetBundlesThumbnails(bundleIds=array, size=string, format=string, isCircular=boolean)
        
            Args:
                bundleIds: list
            size: str
            format: str
            isCircular: bool
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"bundleIds": bundleIds, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetBundlesThumbnailsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/bundles/thumbnails", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetBundlesThumbnailsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetBundlesThumbnailsRecivedData)
            
            return ResponseSchema
        
        def GetDeveloperProductsIcons(self, developerProductIds: list, size: str, format: str, isCircular: bool) -> ThumbnailResponseExtra:
            """
            Thumbnails developer product icons.
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetDeveloperProductsIcons(developerProductIds=array, size=string, format=string, isCircular=boolean)
        
            Args:
                developerProductIds: list
            size: str
            format: str
            isCircular: bool
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"developerProductIds": developerProductIds, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetDeveloperProductsIconsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/developer-products/icons", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetDeveloperProductsIconsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetDeveloperProductsIconsRecivedData)
            
            return ResponseSchema
        
        def GetGamePasses(self, gamePassIds: list, size: str, format: str, isCircular: bool) -> ThumbnailResponseExtra:
            """
            Thumbnails game pass icons.
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetGamePasses(gamePassIds=array, size=string, format=string, isCircular=boolean)
        
            Args:
                gamePassIds: list
            size: str
            format: str
            isCircular: bool
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"gamePassIds": gamePassIds, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetGamePassesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/game-passes", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamePassesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamePassesRecivedData)
            
            return ResponseSchema
        
        def GetGamesUniverseidThumbnails(self, thumbnailIds: list, size: str, format: str, isCircular: bool, universeId: int) -> ThumbnailResponseExtra:
            """
            Fetches game thumbnail URLs for a list of universes' thumbnail ids. Ids that do not correspond to a valid thumbnail will be filtered out.
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetGamesUniverseidThumbnails(thumbnailIds=array, size=string, format=string, isCircular=boolean, universeId=integer)
        
            Args:
                thumbnailIds: list
            size: str
            format: str
            isCircular: bool
            universeId: int
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"thumbnailIds": thumbnailIds, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetGamesUniverseidThumbnailsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/games/{universeId}/thumbnails", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesUniverseidThumbnailsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesUniverseidThumbnailsRecivedData)
            
            return ResponseSchema
        
        def GetGamesIcons(self, universeIds: list, returnPolicy: str, size: str, format: str, isCircular: bool) -> ThumbnailResponseExtra:
            """
            Fetches game icon URLs for a list of universes' root places. Ids that do not correspond to a valid universe will be filtered out.

The ordering of the results is not guaranteed to be the same as the inputs. In order to correlated inputs with outputs please

use the 'targetId' of the objects in the result array.
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetGamesIcons(universeIds=array, returnPolicy=string, size=string, format=string, isCircular=boolean)
        
            Args:
                universeIds: list
            returnPolicy: str
            size: str
            format: str
            isCircular: bool
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"universeIds": universeIds, "returnPolicy": returnPolicy, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetGamesIconsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/games/icons", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesIconsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesIconsRecivedData)
            
            return ResponseSchema
        
        def GetGamesMultigetThumbnails(self, universeIds: list, countPerUniverse: int, defaults: bool, size: str, format: str, isCircular: bool) -> UniverseThumbnailsResponseExtra:
            """
            Fetch game thumbnail URLs for a list of universe IDs.
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetGamesMultigetThumbnails(universeIds=array, countPerUniverse=integer, defaults=boolean, size=string, format=string, isCircular=boolean)
        
            Args:
                universeIds: list
            countPerUniverse: int
            defaults: bool
            size: str
            format: str
            isCircular: bool
            Returns:
                Thumbnails.UniverseThumbnailsResponseExtra: Thumbnails.UniverseThumbnailsResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"universeIds": universeIds, "countPerUniverse": countPerUniverse, "defaults": defaults, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetGamesMultigetThumbnailsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/games/multiget/thumbnails", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.UniverseThumbnailsResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesMultigetThumbnailsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesMultigetThumbnailsRecivedData)
            
            return ResponseSchema
        
        def GetGroupsIcons(self, groupIds: list, size: str, format: str, isCircular: bool) -> ThumbnailResponseExtra:
            """
            Fetches thumbnail URLs for a list of groups. Ids that do not correspond to groups will be filtered out.
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetGroupsIcons(groupIds=array, size=string, format=string, isCircular=boolean)
        
            Args:
                groupIds: list
            size: str
            format: str
            isCircular: bool
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"groupIds": groupIds, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetGroupsIconsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/groups/icons", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsIconsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsIconsRecivedData)
            
            return ResponseSchema
        
        def GetPlacesGameicons(self, placeIds: list, returnPolicy: str, size: str, format: str, isCircular: bool) -> ThumbnailResponseExtra:
            """
            Fetches game icon URLs for a list of places. Ids that do not correspond to a valid place will be filtered out.
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetPlacesGameicons(placeIds=array, returnPolicy=string, size=string, format=string, isCircular=boolean)
        
            Args:
                placeIds: list
            returnPolicy: str
            size: str
            format: str
            isCircular: bool
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"placeIds": placeIds, "returnPolicy": returnPolicy, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetPlacesGameiconsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/places/gameicons", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetPlacesGameiconsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPlacesGameiconsRecivedData)
            
            return ResponseSchema
        
        def GetUsersAvatar(self, userIds: list, size: str, format: str, isCircular: bool) -> ThumbnailResponseExtra:
            """
            Get Avatar Full body shots for the given CSV of userIds
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetUsersAvatar(userIds=array, size=string, format=string, isCircular=boolean)
        
            Args:
                userIds: list
            size: str
            format: str
            isCircular: bool
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"userIds": userIds, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetUsersAvatarRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/users/avatar", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersAvatarRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersAvatarRecivedData)
            
            return ResponseSchema
        
        def GetUsersAvatar3D(self, userId: int) -> ThumbnailResponse:
            """
            Get Avatar 3d object for a user
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetUsersAvatar3D(userId=integer)
        
            Args:
                userId: int
            Returns:
                Thumbnails.ThumbnailResponse: Thumbnails.ThumbnailResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"userId": userId},"headers": {},"cookies": {}}
            
            GetUsersAvatar3DRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/users/avatar-3d", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersAvatar3DRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersAvatar3DRecivedData)
            
            return ResponseSchema
        
        def GetUsersAvatarBust(self, userIds: list, size: str, format: str, isCircular: bool) -> ThumbnailResponseExtra:
            """
            Get Avatar Busts for the given CSV of userIds
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetUsersAvatarBust(userIds=array, size=string, format=string, isCircular=boolean)
        
            Args:
                userIds: list
            size: str
            format: str
            isCircular: bool
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"userIds": userIds, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetUsersAvatarBustRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/users/avatar-bust", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersAvatarBustRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersAvatarBustRecivedData)
            
            return ResponseSchema
        
        def GetUsersAvatarHeadshot(self, userIds: list, size: str, format: str, isCircular: bool) -> ThumbnailResponseExtra:
            """
            Get Avatar Headshots for the given CSV of userIds
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetUsersAvatarHeadshot(userIds=array, size=string, format=string, isCircular=boolean)
        
            Args:
                userIds: list
            size: str
            format: str
            isCircular: bool
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"userIds": userIds, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetUsersAvatarHeadshotRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/users/avatar-headshot", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersAvatarHeadshotRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersAvatarHeadshotRecivedData)
            
            return ResponseSchema
        
        def GetUsersOutfit3D(self, outfitId: int) -> ThumbnailResponse:
            """
            Get 3d object for an outfit
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetUsersOutfit3D(outfitId=integer)
        
            Args:
                outfitId: int
            Returns:
                Thumbnails.ThumbnailResponse: Thumbnails.ThumbnailResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"outfitId": outfitId},"headers": {},"cookies": {}}
            
            GetUsersOutfit3DRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/users/outfit-3d", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersOutfit3DRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersOutfit3DRecivedData)
            
            return ResponseSchema
        
        def GetUsersOutfits(self, userOutfitIds: list, size: str, format: str, isCircular: bool) -> ThumbnailResponseExtra:
            """
            Get outfits for the given CSV of userOutfitIds
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.GetUsersOutfits(userOutfitIds=array, size=string, format=string, isCircular=boolean)
        
            Args:
                userOutfitIds: list
            size: str
            format: str
            isCircular: bool
            Returns:
                Thumbnails.ThumbnailResponseExtra: Thumbnails.ThumbnailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"userOutfitIds": userOutfitIds, "size": size, "format": format, "isCircular": isCircular},"headers": {},"cookies": {}}
            
            GetUsersOutfitsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Thumbnails.roblox.com/v1/users/outfits", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersOutfitsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersOutfitsRecivedData)
            
            return ResponseSchema
        
        def PostBatch(self, Roblox_Place_Id: int, requests: None) -> ThumbnailBatchResponseExtra:
            """
            Returns a list of thumbnails with varying types and sizes
            
            Usage:
                import Thumbnails
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ThumbnailsApi = Thumbnails.ThumbnailsApi(RobloxClient=RobloxClient)
                Response = ThumbnailsApi.PostBatch(Roblox_Place_Id=integer, requests=Thumbnails.None())
        
            Args:
                Roblox_Place_Id: int
            requests: None
            Returns:
                Thumbnails.ThumbnailBatchResponseExtra: Thumbnails.ThumbnailBatchResponseExtra
            """
        
            Dictinary = {"json": {"requests": requests},"data": {},"params": {},"headers": {"Roblox_Place_Id": Roblox_Place_Id},"cookies": {}}
            
            PostBatchRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Thumbnails.roblox.com/v1/batch", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Thumbnails.ThumbnailBatchResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = PostBatchRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostBatchRecivedData)
            
            return ResponseSchema
        
    class Publish:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class AssetQuota:
            def __init__(ClassObject, duration: str = None, usage: int = None, capacity: int = None, expirationTime: str = None):
                ClassObject.duration = duration
                ClassObject.usage = usage
                ClassObject.capacity = capacity
                ClassObject.expirationTime = expirationTime
                ClassObject.response: requests.Response = None


        class AssetQuotasResponse:
            def __init__(ClassObject, quotas: list["RobloxClient.Publish.AssetQuota"] = None):
                ClassObject.quotas = quotas
                ClassObject.response: requests.Response = None


        class PublishAudioResponse:
            def __init__(ClassObject, Id: int = None, Name: str = None):
                ClassObject.Id = Id
                ClassObject.Name = Name
                ClassObject.response: requests.Response = None


        class UploadAudioRequest:
            def __init__(ClassObject, name: str = None, file: str = None, groupId: int = None, paymentSource: str = None, estimatedFileSize: int = None, estimatedDuration: float = None, assetPrivacy: enum.Enum = None):
                ClassObject.name = name
                ClassObject.file = file
                ClassObject.groupId = groupId
                ClassObject.paymentSource = paymentSource
                ClassObject.estimatedFileSize = estimatedFileSize
                ClassObject.estimatedDuration = estimatedDuration
                ClassObject.assetPrivacy = assetPrivacy
                ClassObject.response: requests.Response = None


        class UploadResponse:
            def __init__(ClassObject, targetId: int = None):
                ClassObject.targetId = targetId
                ClassObject.response: requests.Response = None


        class VerifyAudioRequest:
            def __init__(ClassObject, name: str = None, file: str = None, groupId: int = None, paymentSource: str = None, fileSize: int = None, duration: float = None):
                ClassObject.name = name
                ClassObject.file = file
                ClassObject.groupId = groupId
                ClassObject.paymentSource = paymentSource
                ClassObject.fileSize = fileSize
                ClassObject.duration = duration
                ClassObject.response: requests.Response = None


        class VerifyAudioResponse:
            def __init__(ClassObject, name: str = None, price: int = None, balance: int = None, canAfford: bool = None):
                ClassObject.name = name
                ClassObject.price = price
                ClassObject.balance = balance
                ClassObject.canAfford = canAfford
                ClassObject.response: requests.Response = None


        class Stream:
            def __init__(ClassObject, CanRead: bool = None, CanWrite: bool = None, CanSeek: bool = None, CanTimeout: bool = None, Length: int = None, Position: int = None, ReadTimeout: int = None, WriteTimeout: int = None):
                ClassObject.CanRead = CanRead
                ClassObject.CanWrite = CanWrite
                ClassObject.CanSeek = CanSeek
                ClassObject.CanTimeout = CanTimeout
                ClassObject.Length = Length
                ClassObject.Position = Position
                ClassObject.ReadTimeout = ReadTimeout
                ClassObject.WriteTimeout = WriteTimeout
                ClassObject.response: requests.Response = None


        class IUploadedFile:
            def __init__(ClassObject, Name: str = None, Stream: "RobloxClient.Publish.Stream" = None, ContentEncoding: enum.Enum = None):
                ClassObject.Name = Name
                ClassObject.Stream = Stream
                ClassObject.ContentEncoding = ContentEncoding
                ClassObject.response: requests.Response = None



        
        def GetAssetQuotas(self, resourceType: str, assetType: str, useDummyData: bool) -> AssetQuotasResponse:
            """
            List asset quotas of the given resource type and asset type.
            
            Usage:
                import Publish
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PublishApi = Publish.PublishApi(RobloxClient=RobloxClient)
                Response = PublishApi.GetAssetQuotas(resourceType=string, assetType=string, useDummyData=boolean)
        
            Args:
                resourceType: str
            assetType: str
            useDummyData: bool
            Returns:
                Publish.AssetQuotasResponse: Publish.AssetQuotasResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"resourceType": resourceType, "assetType": assetType, "useDummyData": useDummyData},"headers": {},"cookies": {}}
            
            GetAssetQuotasRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Publish.roblox.com/v1/asset-quotas", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Publish.AssetQuotasResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAssetQuotasRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAssetQuotasRecivedData)
            
            return ResponseSchema
        
        def PostAudio(self, UploadAudioRequest: UploadAudioRequest) -> PublishAudioResponse:
            """
            Published an audio file and returns the new asset info.
            
            Usage:
                import Publish
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PublishApi = Publish.PublishApi(RobloxClient=RobloxClient)
                Response = PublishApi.PostAudio(UploadAudioRequest=Publish.UploadAudioRequest())
        
            Args:
                UploadAudioRequest: UploadAudioRequest
            Returns:
                Publish.PublishAudioResponse: Publish.PublishAudioResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UploadAudioRequest': 'json'}
            Arguments = inspect.signature(self.PostAudio)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostAudioRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Publish.roblox.com/v1/audio", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Publish.PublishAudioResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAudioRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAudioRecivedData)
            
            return ResponseSchema
        
        def PostAudioVerify(self, VerifyAudioRequest: VerifyAudioRequest) -> VerifyAudioResponse:
            """
            Verifies an audio file and returns a product that you can purchase to publish the audio file.
            
            Usage:
                import Publish
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PublishApi = Publish.PublishApi(RobloxClient=RobloxClient)
                Response = PublishApi.PostAudioVerify(VerifyAudioRequest=Publish.VerifyAudioRequest())
        
            Args:
                VerifyAudioRequest: VerifyAudioRequest
            Returns:
                Publish.VerifyAudioResponse: Publish.VerifyAudioResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VerifyAudioRequest': 'json'}
            Arguments = inspect.signature(self.PostAudioVerify)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostAudioVerifyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Publish.roblox.com/v1/audio/verify", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Publish.VerifyAudioResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAudioVerifyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAudioVerifyRecivedData)
            
            return ResponseSchema
        
        def PostBadgesBadgeidIcon(self, badgeId: int, Files: typing.IO) -> UploadResponse:
            """
            Overwrites a badge icon with a new one.
            
            Usage:
                import Publish
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PublishApi = Publish.PublishApi(RobloxClient=RobloxClient)
                Response = PublishApi.PostBadgesBadgeidIcon(badgeId=integer, Files=file)
        
            Args:
                badgeId: int
            Files: typing.IO
            Returns:
                Publish.UploadResponse: Publish.UploadResponse
            """
        
            Dictinary = {"json": {},"data": {"Files": Files},"params": {},"headers": {},"cookies": {}}
            
            PostBadgesBadgeidIconRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Publish.roblox.com/v1/badges/{badgeId}/icon", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Publish.UploadResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostBadgesBadgeidIconRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostBadgesBadgeidIconRecivedData)
            
            return ResponseSchema
        
        def PostGamesGameidThumbnailImage(self, gameId: int, Files: typing.IO) -> UploadResponse:
            """
            Uploads a game thumbnail.
            
            Usage:
                import Publish
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PublishApi = Publish.PublishApi(RobloxClient=RobloxClient)
                Response = PublishApi.PostGamesGameidThumbnailImage(gameId=integer, Files=file)
        
            Args:
                gameId: int
            Files: typing.IO
            Returns:
                Publish.UploadResponse: Publish.UploadResponse
            """
        
            Dictinary = {"json": {},"data": {"Files": Files},"params": {},"headers": {},"cookies": {}}
            
            PostGamesGameidThumbnailImageRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Publish.roblox.com/v1/games/{gameId}/thumbnail/image", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Publish.UploadResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostGamesGameidThumbnailImageRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGamesGameidThumbnailImageRecivedData)
            
            return ResponseSchema
        
        def PostPluginsPluginidIcon(self, pluginId: int, Files: typing.IO) -> UploadResponse:
            """
            Overwrites a plugin icon with a new one.
            
            Usage:
                import Publish
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PublishApi = Publish.PublishApi(RobloxClient=RobloxClient)
                Response = PublishApi.PostPluginsPluginidIcon(pluginId=integer, Files=file)
        
            Args:
                pluginId: int
            Files: typing.IO
            Returns:
                Publish.UploadResponse: Publish.UploadResponse
            """
        
            Dictinary = {"json": {},"data": {"Files": Files},"params": {},"headers": {},"cookies": {}}
            
            PostPluginsPluginidIconRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Publish.roblox.com/v1/plugins/{pluginId}/icon", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Publish.UploadResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostPluginsPluginidIconRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPluginsPluginidIconRecivedData)
            
            return ResponseSchema
        
    class PrivateMessages:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class VerifiedSkinnyUserResponse:
            def __init__(ClassObject, hasVerifiedBadge: bool = None, id: int = None, name: str = None, displayName: str = None):
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class AnnouncementsDetailsResponse:
            def __init__(ClassObject, id: int = None, sender: "RobloxClient.PrivateMessages.VerifiedSkinnyUserResponse" = None, subject: str = None, body: str = None, created: str = None, updated: str = None):
                ClassObject.id = id
                ClassObject.sender = sender
                ClassObject.subject = subject
                ClassObject.body = body
                ClassObject.created = created
                ClassObject.updated = updated
                ClassObject.response: requests.Response = None


        class AnnouncementsMetadataResponse:
            def __init__(ClassObject, numOfAnnouncements: int = None):
                ClassObject.numOfAnnouncements = numOfAnnouncements
                ClassObject.response: requests.Response = None


        class BatchMessagesRequest:
            def __init__(ClassObject, messageIds: list[int] = None):
                ClassObject.messageIds = messageIds
                ClassObject.response: requests.Response = None


        class FailedMessageResponse:
            def __init__(ClassObject, messageId: int = None, errorMessage: str = None):
                ClassObject.messageId = messageId
                ClassObject.errorMessage = errorMessage
                ClassObject.response: requests.Response = None


        class BatchMessagesResponse:
            def __init__(ClassObject, failedMessages: list["RobloxClient.PrivateMessages.FailedMessageResponse"] = None):
                ClassObject.failedMessages = failedMessages
                ClassObject.response: requests.Response = None


        class GetAnnouncementsResponse:
            def __init__(ClassObject, collection: list["RobloxClient.PrivateMessages.AnnouncementsDetailsResponse"] = None, totalCollectionSize: int = None):
                ClassObject.collection = collection
                ClassObject.totalCollectionSize = totalCollectionSize
                ClassObject.response: requests.Response = None


        class MessageDetailsResponse:
            def __init__(ClassObject, id: int = None, sender: "RobloxClient.PrivateMessages.VerifiedSkinnyUserResponse" = None, recipient: "RobloxClient.PrivateMessages.VerifiedSkinnyUserResponse" = None, subject: str = None, body: str = None, created: str = None, updated: str = None, isRead: bool = None, isSystemMessage: bool = None, isReportAbuseDisplayed: bool = None):
                ClassObject.id = id
                ClassObject.sender = sender
                ClassObject.recipient = recipient
                ClassObject.subject = subject
                ClassObject.body = body
                ClassObject.created = created
                ClassObject.updated = updated
                ClassObject.isRead = isRead
                ClassObject.isSystemMessage = isSystemMessage
                ClassObject.isReportAbuseDisplayed = isReportAbuseDisplayed
                ClassObject.response: requests.Response = None


        class GetMessagesResponse:
            def __init__(ClassObject, collection: list["RobloxClient.PrivateMessages.MessageDetailsResponse"] = None, totalCollectionSize: int = None, totalPages: int = None, pageNumber: int = None):
                ClassObject.collection = collection
                ClassObject.totalCollectionSize = totalCollectionSize
                ClassObject.totalPages = totalPages
                ClassObject.pageNumber = pageNumber
                ClassObject.response: requests.Response = None


        class CanMessageResponse:
            def __init__(ClassObject, canMessage: bool = None):
                ClassObject.canMessage = canMessage
                ClassObject.response: requests.Response = None


        class SendMessageRequest:
            def __init__(ClassObject, userId: int = None, subject: str = None, body: str = None, recipientId: int = None, replyMessageId: int = None, includePreviousMessage: bool = None):
                ClassObject.userId = userId
                ClassObject.subject = subject
                ClassObject.body = body
                ClassObject.recipientId = recipientId
                ClassObject.replyMessageId = replyMessageId
                ClassObject.includePreviousMessage = includePreviousMessage
                ClassObject.response: requests.Response = None


        class SendMessageResponse:
            def __init__(ClassObject, success: bool = None, shortMessage: str = None, message: str = None):
                ClassObject.success = success
                ClassObject.shortMessage = shortMessage
                ClassObject.message = message
                ClassObject.response: requests.Response = None


        class UnreadMessagesCountResponse:
            def __init__(ClassObject, count: int = None):
                ClassObject.count = count
                ClassObject.response: requests.Response = None



        
        def GetAnnouncements(self) -> GetAnnouncementsResponse:
            """
            Migrate from RobloxWebsite project, return news notification for Private Message page
            
            Usage:
                import PrivateMessages
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PrivateMessagesApi = PrivateMessages.PrivateMessagesApi(RobloxClient=RobloxClient)
                Response = PrivateMessagesApi.GetAnnouncements()
        
            Args:
                
            Returns:
                PrivateMessages.GetAnnouncementsResponse: PrivateMessages.GetAnnouncementsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAnnouncementsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://PrivateMessages.roblox.com/v1/announcements", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.PrivateMessages.GetAnnouncementsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAnnouncementsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAnnouncementsRecivedData)
            
            return ResponseSchema
        
        def GetAnnouncementsMetadata(self) -> AnnouncementsMetadataResponse:
            """
            Unknown
            
            Usage:
                import PrivateMessages
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PrivateMessagesApi = PrivateMessages.PrivateMessagesApi(RobloxClient=RobloxClient)
                Response = PrivateMessagesApi.GetAnnouncementsMetadata()
        
            Args:
                
            Returns:
                PrivateMessages.AnnouncementsMetadataResponse: PrivateMessages.AnnouncementsMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAnnouncementsMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://PrivateMessages.roblox.com/v1/announcements/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.PrivateMessages.AnnouncementsMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAnnouncementsMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAnnouncementsMetadataRecivedData)
            
            return ResponseSchema
        
        def GetMessages(self, pageNumber: int, pageSize: int, messageTab: str) -> GetMessagesResponse:
            """
            Gets a user's messages.
            
            Usage:
                import PrivateMessages
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PrivateMessagesApi = PrivateMessages.PrivateMessagesApi(RobloxClient=RobloxClient)
                Response = PrivateMessagesApi.GetMessages(pageNumber=integer, pageSize=integer, messageTab=string)
        
            Args:
                pageNumber: int
            pageSize: int
            messageTab: str
            Returns:
                PrivateMessages.GetMessagesResponse: PrivateMessages.GetMessagesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"pageNumber": pageNumber, "pageSize": pageSize, "messageTab": messageTab},"headers": {},"cookies": {}}
            
            GetMessagesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://PrivateMessages.roblox.com/v1/messages", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.PrivateMessages.GetMessagesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetMessagesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetMessagesRecivedData)
            
            return ResponseSchema
        
        def GetMessagesMessageid(self, messageId: int) -> MessageDetailsResponse:
            """
            Gets a message's details.
            
            Usage:
                import PrivateMessages
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PrivateMessagesApi = PrivateMessages.PrivateMessagesApi(RobloxClient=RobloxClient)
                Response = PrivateMessagesApi.GetMessagesMessageid(messageId=integer)
        
            Args:
                messageId: int
            Returns:
                PrivateMessages.MessageDetailsResponse: PrivateMessages.MessageDetailsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetMessagesMessageidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://PrivateMessages.roblox.com/v1/messages/{messageId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.PrivateMessages.MessageDetailsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetMessagesMessageidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetMessagesMessageidRecivedData)
            
            return ResponseSchema
        
        def GetMessagesUseridCanMessage(self, userId: int) -> CanMessageResponse:
            """
            Gets whether the sender can send a message to the specified user.
            
            Usage:
                import PrivateMessages
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PrivateMessagesApi = PrivateMessages.PrivateMessagesApi(RobloxClient=RobloxClient)
                Response = PrivateMessagesApi.GetMessagesUseridCanMessage(userId=integer)
        
            Args:
                userId: int
            Returns:
                PrivateMessages.CanMessageResponse: PrivateMessages.CanMessageResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetMessagesUseridCanMessageRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://PrivateMessages.roblox.com/v1/messages/{userId}/can-message", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.PrivateMessages.CanMessageResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetMessagesUseridCanMessageRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetMessagesUseridCanMessageRecivedData)
            
            return ResponseSchema
        
        def GetMessagesUnreadCount(self) -> UnreadMessagesCountResponse:
            """
            Gets unread messages for the authenticated user.
            
            Usage:
                import PrivateMessages
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PrivateMessagesApi = PrivateMessages.PrivateMessagesApi(RobloxClient=RobloxClient)
                Response = PrivateMessagesApi.GetMessagesUnreadCount()
        
            Args:
                
            Returns:
                PrivateMessages.UnreadMessagesCountResponse: PrivateMessages.UnreadMessagesCountResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetMessagesUnreadCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://PrivateMessages.roblox.com/v1/messages/unread/count", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.PrivateMessages.UnreadMessagesCountResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetMessagesUnreadCountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetMessagesUnreadCountRecivedData)
            
            return ResponseSchema
        
        def PostMessagesArchive(self, BatchMessagesRequest: BatchMessagesRequest) -> BatchMessagesResponse:
            """
            Archives a batch of messages.
            
            Usage:
                import PrivateMessages
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PrivateMessagesApi = PrivateMessages.PrivateMessagesApi(RobloxClient=RobloxClient)
                Response = PrivateMessagesApi.PostMessagesArchive(BatchMessagesRequest=PrivateMessages.BatchMessagesRequest())
        
            Args:
                BatchMessagesRequest: BatchMessagesRequest
            Returns:
                PrivateMessages.BatchMessagesResponse: PrivateMessages.BatchMessagesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'BatchMessagesRequest': 'json'}
            Arguments = inspect.signature(self.PostMessagesArchive)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostMessagesArchiveRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://PrivateMessages.roblox.com/v1/messages/archive", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.PrivateMessages.BatchMessagesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostMessagesArchiveRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostMessagesArchiveRecivedData)
            
            return ResponseSchema
        
        def PostMessagesMarkRead(self, BatchMessagesRequest: BatchMessagesRequest) -> BatchMessagesResponse:
            """
            Marks a batch of messages as read.
            
            Usage:
                import PrivateMessages
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PrivateMessagesApi = PrivateMessages.PrivateMessagesApi(RobloxClient=RobloxClient)
                Response = PrivateMessagesApi.PostMessagesMarkRead(BatchMessagesRequest=PrivateMessages.BatchMessagesRequest())
        
            Args:
                BatchMessagesRequest: BatchMessagesRequest
            Returns:
                PrivateMessages.BatchMessagesResponse: PrivateMessages.BatchMessagesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'BatchMessagesRequest': 'json'}
            Arguments = inspect.signature(self.PostMessagesMarkRead)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostMessagesMarkReadRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://PrivateMessages.roblox.com/v1/messages/mark-read", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.PrivateMessages.BatchMessagesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostMessagesMarkReadRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostMessagesMarkReadRecivedData)
            
            return ResponseSchema
        
        def PostMessagesMarkUnread(self, BatchMessagesRequest: BatchMessagesRequest) -> BatchMessagesResponse:
            """
            Marks a batch of messages as unread.
            
            Usage:
                import PrivateMessages
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PrivateMessagesApi = PrivateMessages.PrivateMessagesApi(RobloxClient=RobloxClient)
                Response = PrivateMessagesApi.PostMessagesMarkUnread(BatchMessagesRequest=PrivateMessages.BatchMessagesRequest())
        
            Args:
                BatchMessagesRequest: BatchMessagesRequest
            Returns:
                PrivateMessages.BatchMessagesResponse: PrivateMessages.BatchMessagesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'BatchMessagesRequest': 'json'}
            Arguments = inspect.signature(self.PostMessagesMarkUnread)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostMessagesMarkUnreadRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://PrivateMessages.roblox.com/v1/messages/mark-unread", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.PrivateMessages.BatchMessagesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostMessagesMarkUnreadRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostMessagesMarkUnreadRecivedData)
            
            return ResponseSchema
        
        def PostMessagesSend(self, SendMessageRequest: SendMessageRequest) -> SendMessageResponse:
            """
            Sends a message to a specified user.
            
            Usage:
                import PrivateMessages
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PrivateMessagesApi = PrivateMessages.PrivateMessagesApi(RobloxClient=RobloxClient)
                Response = PrivateMessagesApi.PostMessagesSend(SendMessageRequest=PrivateMessages.SendMessageRequest())
        
            Args:
                SendMessageRequest: SendMessageRequest
            Returns:
                PrivateMessages.SendMessageResponse: PrivateMessages.SendMessageResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SendMessageRequest': 'json'}
            Arguments = inspect.signature(self.PostMessagesSend)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostMessagesSendRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://PrivateMessages.roblox.com/v1/messages/send", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.PrivateMessages.SendMessageResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostMessagesSendRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostMessagesSendRecivedData)
            
            return ResponseSchema
        
        def PostMessagesUnarchive(self, BatchMessagesRequest: BatchMessagesRequest) -> BatchMessagesResponse:
            """
            Unarchives a batch of messages.
            
            Usage:
                import PrivateMessages
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PrivateMessagesApi = PrivateMessages.PrivateMessagesApi(RobloxClient=RobloxClient)
                Response = PrivateMessagesApi.PostMessagesUnarchive(BatchMessagesRequest=PrivateMessages.BatchMessagesRequest())
        
            Args:
                BatchMessagesRequest: BatchMessagesRequest
            Returns:
                PrivateMessages.BatchMessagesResponse: PrivateMessages.BatchMessagesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'BatchMessagesRequest': 'json'}
            Arguments = inspect.signature(self.PostMessagesUnarchive)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostMessagesUnarchiveRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://PrivateMessages.roblox.com/v1/messages/unarchive", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.PrivateMessages.BatchMessagesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostMessagesUnarchiveRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostMessagesUnarchiveRecivedData)
            
            return ResponseSchema
        
    class Presence:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class LastOnlineRequest:
            def __init__(ClassObject, userIds: list[int] = None):
                ClassObject.userIds = userIds
                ClassObject.response: requests.Response = None


        class UserPresenceRequest:
            def __init__(ClassObject, userIds: list[int] = None):
                ClassObject.userIds = userIds
                ClassObject.response: requests.Response = None


        class LastOnline:
            def __init__(ClassObject, userId: int = None, lastOnline: str = None):
                ClassObject.userId = userId
                ClassObject.lastOnline = lastOnline
                ClassObject.response: requests.Response = None


        class LastOnlineResponse:
            def __init__(ClassObject, lastOnlineTimestamps: list["RobloxClient.Presence.LastOnline"] = None):
                ClassObject.lastOnlineTimestamps = lastOnlineTimestamps
                ClassObject.response: requests.Response = None


        class UserPresence:
            def __init__(ClassObject, userPresenceType: enum.Enum = None, lastLocation: str = None, placeId: int = None, rootPlaceId: int = None, gameId: str = None, universeId: int = None, userId: int = None, lastOnline: str = None, invisibleModeExpiry: str = None):
                ClassObject.userPresenceType = userPresenceType
                ClassObject.lastLocation = lastLocation
                ClassObject.placeId = placeId
                ClassObject.rootPlaceId = rootPlaceId
                ClassObject.gameId = gameId
                ClassObject.universeId = universeId
                ClassObject.userId = userId
                ClassObject.lastOnline = lastOnline
                ClassObject.invisibleModeExpiry = invisibleModeExpiry
                ClassObject.response: requests.Response = None


        class UserPresencesResponse:
            def __init__(ClassObject, userPresences: list["RobloxClient.Presence.UserPresence"] = None):
                ClassObject.userPresences = userPresences
                ClassObject.response: requests.Response = None



        
        def PostPresenceLastOnline(self, LastOnlineRequest: LastOnlineRequest) -> LastOnlineResponse:
            """
            Get last online timestamps for a list of users.
            
            Usage:
                import Presence
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PresenceApi = Presence.PresenceApi(RobloxClient=RobloxClient)
                Response = PresenceApi.PostPresenceLastOnline(LastOnlineRequest=Presence.LastOnlineRequest())
        
            Args:
                LastOnlineRequest: LastOnlineRequest
            Returns:
                Presence.LastOnlineResponse: Presence.LastOnlineResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'LastOnlineRequest': 'json'}
            Arguments = inspect.signature(self.PostPresenceLastOnline)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPresenceLastOnlineRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Presence.roblox.com/v1/presence/last-online", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Presence.LastOnlineResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostPresenceLastOnlineRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPresenceLastOnlineRecivedData)
            
            return ResponseSchema
        
        def PostPresenceUsers(self, UserPresenceRequest: UserPresenceRequest) -> UserPresencesResponse:
            """
            Get Presence for a list of users
            
            Usage:
                import Presence
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PresenceApi = Presence.PresenceApi(RobloxClient=RobloxClient)
                Response = PresenceApi.PostPresenceUsers(UserPresenceRequest=Presence.UserPresenceRequest())
        
            Args:
                UserPresenceRequest: UserPresenceRequest
            Returns:
                Presence.UserPresencesResponse: Presence.UserPresencesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UserPresenceRequest': 'json'}
            Arguments = inspect.signature(self.PostPresenceUsers)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPresenceUsersRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Presence.roblox.com/v1/presence/users", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Presence.UserPresencesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostPresenceUsersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPresenceUsersRecivedData)
            
            return ResponseSchema
        
    class PremiumFeatures:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient

        
        def GetUsersUseridPremiumUpsellPrecheck(self, universeId: int, placeId: int, userId: int) -> requests.Response:
            """
            Premium upsell precheck
            
            Usage:
                import PremiumFeatures
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PremiumFeaturesApi = PremiumFeatures.PremiumFeaturesApi(RobloxClient=RobloxClient)
                Response = PremiumFeaturesApi.GetUsersUseridPremiumUpsellPrecheck(universeId=integer, placeId=integer, userId=integer)
        
            Args:
                universeId: int
            placeId: int
            userId: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"universeId": universeId, "placeId": placeId},"headers": {},"cookies": {}}
            
            GetUsersUseridPremiumUpsellPrecheckRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://PremiumFeatures.roblox.com/v1/users/{userId}/premium-upsell-precheck", Dictinary=Dictinary)
            return GetUsersUseridPremiumUpsellPrecheckRecivedData
        
        def GetUsersUseridValidateMembership(self, userId: int) -> requests.Response:
            """
            Get if a user has a Premium membership
            
            Usage:
                import PremiumFeatures
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                PremiumFeaturesApi = PremiumFeatures.PremiumFeaturesApi(RobloxClient=RobloxClient)
                Response = PremiumFeaturesApi.GetUsersUseridValidateMembership(userId=integer)
        
            Args:
                userId: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridValidateMembershipRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://PremiumFeatures.roblox.com/v1/users/{userId}/validate-membership", Dictinary=Dictinary)
            return GetUsersUseridValidateMembershipRecivedData
        
    class Notifications:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class ChromeManifestModel:
            def __init__(ClassObject, name: str = None, gcmsenderid: str = None):
                ClassObject.name = name
                ClassObject.gcmsenderid = gcmsenderid
                ClassObject.response: requests.Response = None


        class GameUpdateNotificationModel:
            def __init__(ClassObject, universeId: int = None, rootPlaceId: int = None, createdOn: str = None, createdOnKey: str = None, content: str = None, universeName: str = None):
                ClassObject.universeId = universeId
                ClassObject.rootPlaceId = rootPlaceId
                ClassObject.createdOn = createdOn
                ClassObject.createdOnKey = createdOnKey
                ClassObject.content = content
                ClassObject.universeName = universeName
                ClassObject.response: requests.Response = None


        class GameUpdateNotificationReadRequestModel:
            def __init__(ClassObject, universeId: int = None, createdOn: str = None, currentUserId: int = None):
                ClassObject.universeId = universeId
                ClassObject.createdOn = createdOn
                ClassObject.currentUserId = currentUserId
                ClassObject.response: requests.Response = None


        class NotificationUser:
            def __init__(ClassObject, name: str = None, userId: int = None):
                ClassObject.name = name
                ClassObject.userId = userId
                ClassObject.response: requests.Response = None


        class UserPushDestination:
            def __init__(ClassObject, user: "RobloxClient.Notifications.NotificationUser" = None, name: str = None, notificationToken: str = None, supportsUpdateNotifications: bool = None, userPushNotificationDestinationId: int = None, application: str = None, platform: enum.Enum = None):
                ClassObject.user = user
                ClassObject.name = name
                ClassObject.notificationToken = notificationToken
                ClassObject.supportsUpdateNotifications = supportsUpdateNotifications
                ClassObject.userPushNotificationDestinationId = userPushNotificationDestinationId
                ClassObject.application = application
                ClassObject.platform = platform
                ClassObject.response: requests.Response = None


        class GetCurrentPushDestinationResponseModel:
            def __init__(ClassObject, destination: "RobloxClient.Notifications.UserPushDestination" = None, statusMessage: str = None):
                ClassObject.destination = destination
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class PushNotificationClientMetadata:
            def __init__(ClassObject, notificationId: str = None, type: str = None, detail: dict = None, fallbackDelivered: bool = None):
                ClassObject.notificationId = notificationId
                ClassObject.type = type
                ClassObject.detail = detail
                ClassObject.fallbackDelivered = fallbackDelivered
                ClassObject.response: requests.Response = None


        class GetMetadataResponseModel:
            def __init__(ClassObject, metadata: "RobloxClient.Notifications.PushNotificationClientMetadata" = None, statusMessage: str = None):
                ClassObject.metadata = metadata
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class GetPushDestinationsResponseModel:
            def __init__(ClassObject, destinations: list["RobloxClient.Notifications.UserPushDestination"] = None, statusMessage: str = None):
                ClassObject.destinations = destinations
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class MarkAsReadRequestModel:
            def __init__(ClassObject, platformType: enum.Enum = None, notificationId: str = None):
                ClassObject.platformType = platformType
                ClassObject.notificationId = notificationId
                ClassObject.response: requests.Response = None


        class MarkCategoryAsReadRequestModel:
            def __init__(ClassObject, notificationType: enum.Enum = None, category: str = None, latestNotificationId: str = None):
                ClassObject.notificationType = notificationType
                ClassObject.category = category
                ClassObject.latestNotificationId = latestNotificationId
                ClassObject.response: requests.Response = None


        class MarkInteractedRequestModel:
            def __init__(ClassObject, eventId: str = None):
                ClassObject.eventId = eventId
                ClassObject.response: requests.Response = None


        class MarkInteractionRequestModel:
            def __init__(ClassObject, platformType: enum.Enum = None, notificationToken: str = None, notificationId: str = None, interactionType: enum.Enum = None):
                ClassObject.platformType = platformType
                ClassObject.notificationToken = notificationToken
                ClassObject.notificationId = notificationId
                ClassObject.interactionType = interactionType
                ClassObject.response: requests.Response = None


        class NotificationIdsResponseModel:
            def __init__(ClassObject, ids: list[str] = None, statusMessage: str = None):
                ClassObject.ids = ids
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class RolloutSettingsModel:
            def __init__(ClassObject, featureName: str = None, isRolloutEnabled: bool = None, isValidFeature: bool = None):
                ClassObject.featureName = featureName
                ClassObject.isRolloutEnabled = isRolloutEnabled
                ClassObject.isValidFeature = isValidFeature
                ClassObject.response: requests.Response = None


        class NotificationRolloutSettingsModel:
            def __init__(ClassObject, rollOutFeatureEnabledList: list["RobloxClient.Notifications.RolloutSettingsModel"] = None):
                ClassObject.rollOutFeatureEnabledList = rollOutFeatureEnabledList
                ClassObject.response: requests.Response = None


        class NotificationStreamEntriesModel:
            def __init__(ClassObject, id: str = None, notificationSourceType: enum.Enum = None, eventDate: str = None, timestamp: str = None, isInteracted: bool = None, metadataCollection: list[any] = None, eventCount: int = None, content: dict = None):
                ClassObject.id = id
                ClassObject.notificationSourceType = notificationSourceType
                ClassObject.eventDate = eventDate
                ClassObject.timestamp = timestamp
                ClassObject.isInteracted = isInteracted
                ClassObject.metadataCollection = metadataCollection
                ClassObject.eventCount = eventCount
                ClassObject.content = content
                ClassObject.response: requests.Response = None


        class PushNotificationRegistration:
            def __init__(ClassObject, userPushNotificationDestinationId: int = None, name: str = None, notificationToken: str = None, application: str = None, platform: enum.Enum = None):
                ClassObject.userPushNotificationDestinationId = userPushNotificationDestinationId
                ClassObject.name = name
                ClassObject.notificationToken = notificationToken
                ClassObject.application = application
                ClassObject.platform = platform
                ClassObject.response: requests.Response = None


        class ReceiverDestinationSettingModel:
            def __init__(ClassObject, name: str = None, platform: enum.Enum = None, destinationId: int = None, isEnabled: bool = None, isSetByReceiver: bool = None):
                ClassObject.name = name
                ClassObject.platform = platform
                ClassObject.destinationId = destinationId
                ClassObject.isEnabled = isEnabled
                ClassObject.isSetByReceiver = isSetByReceiver
                ClassObject.response: requests.Response = None


        class ReceiverNotificationSettingGroupModel:
            def __init__(ClassObject, notificationSourceType: enum.Enum = None, receiverDestinationType: enum.Enum = None, isEnabled: bool = None, isOverridable: bool = None, isSetByReceiver: bool = None, pushNotificationDestinationPreferences: list["RobloxClient.Notifications.ReceiverDestinationSettingModel"] = None):
                ClassObject.notificationSourceType = notificationSourceType
                ClassObject.receiverDestinationType = receiverDestinationType
                ClassObject.isEnabled = isEnabled
                ClassObject.isOverridable = isOverridable
                ClassObject.isSetByReceiver = isSetByReceiver
                ClassObject.pushNotificationDestinationPreferences = pushNotificationDestinationPreferences
                ClassObject.response: requests.Response = None


        class RegisterAndroidAmazonRequestModel:
            def __init__(ClassObject, notificationToken: str = None, authorizeForUser: bool = None, oldNotificationToken: str = None, deviceName: str = None):
                ClassObject.notificationToken = notificationToken
                ClassObject.authorizeForUser = authorizeForUser
                ClassObject.oldNotificationToken = oldNotificationToken
                ClassObject.deviceName = deviceName
                ClassObject.response: requests.Response = None


        class RegisterAndroidRequestModel:
            def __init__(ClassObject, notificationToken: str = None, authorizeForUser: bool = None, oldNotificationToken: str = None, deviceName: str = None):
                ClassObject.notificationToken = notificationToken
                ClassObject.authorizeForUser = authorizeForUser
                ClassObject.oldNotificationToken = oldNotificationToken
                ClassObject.deviceName = deviceName
                ClassObject.response: requests.Response = None


        class RegisterChromeRequestModel:
            def __init__(ClassObject, notificationToken: str = None, initiatedByUser: bool = None):
                ClassObject.notificationToken = notificationToken
                ClassObject.initiatedByUser = initiatedByUser
                ClassObject.response: requests.Response = None


        class RegisterFirefoxRequestModel:
            def __init__(ClassObject, notificationToken: str = None, notificationEndpoint: str = None, initiatedByUser: bool = None):
                ClassObject.notificationToken = notificationToken
                ClassObject.notificationEndpoint = notificationEndpoint
                ClassObject.initiatedByUser = initiatedByUser
                ClassObject.response: requests.Response = None


        class RegisterIOSNativeRequestModel:
            def __init__(ClassObject, notificationToken: str = None, destinationIdentifier: str = None, authorizeForUser: bool = None, oldNotificationToken: str = None, deviceName: str = None):
                ClassObject.notificationToken = notificationToken
                ClassObject.destinationIdentifier = destinationIdentifier
                ClassObject.authorizeForUser = authorizeForUser
                ClassObject.oldNotificationToken = oldNotificationToken
                ClassObject.deviceName = deviceName
                ClassObject.response: requests.Response = None


        class RegisterIOSPushKitRequestModel:
            def __init__(ClassObject, notificationToken: str = None, destinationIdentifier: str = None, authorizeForUser: bool = None, oldNotificationToken: str = None, deviceName: str = None):
                ClassObject.notificationToken = notificationToken
                ClassObject.destinationIdentifier = destinationIdentifier
                ClassObject.authorizeForUser = authorizeForUser
                ClassObject.oldNotificationToken = oldNotificationToken
                ClassObject.deviceName = deviceName
                ClassObject.response: requests.Response = None


        class RegisterTencentServiceRequestModel:
            def __init__(ClassObject, notificationToken: str = None, destinationIdentifier: str = None, authorizeForUser: bool = None, deviceName: str = None):
                ClassObject.notificationToken = notificationToken
                ClassObject.destinationIdentifier = destinationIdentifier
                ClassObject.authorizeForUser = authorizeForUser
                ClassObject.deviceName = deviceName
                ClassObject.response: requests.Response = None


        class RegistrationResponseModel:
            def __init__(ClassObject, registration: "RobloxClient.Notifications.PushNotificationRegistration" = None, statusMessage: str = None):
                ClassObject.registration = registration
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class NotificationStreamMetadataResponse:
            def __init__(ClassObject, bannerDismissTimeSpan: int = None, signalRDisconnectionResponseInMilliseconds: int = None, canLaunchGameFromGameUpdate: bool = None):
                ClassObject.bannerDismissTimeSpan = bannerDismissTimeSpan
                ClassObject.signalRDisconnectionResponseInMilliseconds = signalRDisconnectionResponseInMilliseconds
                ClassObject.canLaunchGameFromGameUpdate = canLaunchGameFromGameUpdate
                ClassObject.response: requests.Response = None


        class SuccessResponseModel:
            def __init__(ClassObject, statusMessage: str = None):
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class UnreadStreamNotificationsModel:
            def __init__(ClassObject, unreadNotifications: int = None, statusMessage: str = None):
                ClassObject.unreadNotifications = unreadNotifications
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class UserNotificationSettingsModel:
            def __init__(ClassObject, notificationBandSettings: list["RobloxClient.Notifications.ReceiverNotificationSettingGroupModel"] = None, optedOutNotificationSourceTypes: list[str] = None, optedOutReceiverDestinationTypes: list[str] = None):
                ClassObject.notificationBandSettings = notificationBandSettings
                ClassObject.optedOutNotificationSourceTypes = optedOutNotificationSourceTypes
                ClassObject.optedOutReceiverDestinationTypes = optedOutReceiverDestinationTypes
                ClassObject.response: requests.Response = None


        class RealTimeNotificationsSettingsResponseModel:
            def __init__(ClassObject, primaryDomain: str = None, fallbackDomain: str = None):
                ClassObject.primaryDomain = primaryDomain
                ClassObject.fallbackDomain = fallbackDomain
                ClassObject.response: requests.Response = None



        
        def GetNotificationsGetRolloutSettings(self, featureNames: list) -> NotificationRolloutSettingsModel:
            """
            Gets the notification settings related to rollout
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.GetNotificationsGetRolloutSettings(featureNames=array)
        
            Args:
                featureNames: list
            Returns:
                Notifications.NotificationRolloutSettingsModel: Notifications.NotificationRolloutSettingsModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {"featureNames": featureNames},"headers": {},"cookies": {}}
            
            GetNotificationsGetRolloutSettingsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Notifications.roblox.com/v2/notifications/get-rollout-settings", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.NotificationRolloutSettingsModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetNotificationsGetRolloutSettingsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetNotificationsGetRolloutSettingsRecivedData)
            
            return ResponseSchema
        
        def GetNotificationsGetSettings(self) -> UserNotificationSettingsModel:
            """
            Gets settings related to notifications for the signed in user
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.GetNotificationsGetSettings()
        
            Args:
                
            Returns:
                Notifications.UserNotificationSettingsModel: Notifications.UserNotificationSettingsModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetNotificationsGetSettingsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Notifications.roblox.com/v2/notifications/get-settings", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.UserNotificationSettingsModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetNotificationsGetSettingsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetNotificationsGetSettingsRecivedData)
            
            return ResponseSchema
        
        def GetNotificationsSettingsRealtime(self) -> RealTimeNotificationsSettingsResponseModel:
            """
            Gets the notification settings related to realtime
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.GetNotificationsSettingsRealtime()
        
            Args:
                
            Returns:
                Notifications.RealTimeNotificationsSettingsResponseModel: Notifications.RealTimeNotificationsSettingsResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetNotificationsSettingsRealtimeRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Notifications.roblox.com/v2/notifications/settings/realtime", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.RealTimeNotificationsSettingsResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetNotificationsSettingsRealtimeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetNotificationsSettingsRealtimeRecivedData)
            
            return ResponseSchema
        
        def GetPushNotificationsChromeManifest(self) -> ChromeManifestModel:
            """
            Get Chrome Manifest to link GCM project to Chrome Browser
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.GetPushNotificationsChromeManifest()
        
            Args:
                
            Returns:
                Notifications.ChromeManifestModel: Notifications.ChromeManifestModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetPushNotificationsChromeManifestRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Notifications.roblox.com/v2/push-notifications/chrome-manifest", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.ChromeManifestModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetPushNotificationsChromeManifestRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPushNotificationsChromeManifestRecivedData)
            
            return ResponseSchema
        
        def GetPushNotificationsGetCurrentDeviceDestination(self) -> GetCurrentPushDestinationResponseModel:
            """
            Gets the current device destination
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.GetPushNotificationsGetCurrentDeviceDestination()
        
            Args:
                
            Returns:
                Notifications.GetCurrentPushDestinationResponseModel: Notifications.GetCurrentPushDestinationResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetPushNotificationsGetCurrentDeviceDestinationRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Notifications.roblox.com/v2/push-notifications/get-current-device-destination", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.GetCurrentPushDestinationResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetPushNotificationsGetCurrentDeviceDestinationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPushNotificationsGetCurrentDeviceDestinationRecivedData)
            
            return ResponseSchema
        
        def GetPushNotificationsGetDestinations(self) -> GetPushDestinationsResponseModel:
            """
            Gets valid destinations associated with the signed user
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.GetPushNotificationsGetDestinations()
        
            Args:
                
            Returns:
                Notifications.GetPushDestinationsResponseModel: Notifications.GetPushDestinationsResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetPushNotificationsGetDestinationsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Notifications.roblox.com/v2/push-notifications/get-destinations", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.GetPushDestinationsResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetPushNotificationsGetDestinationsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPushNotificationsGetDestinationsRecivedData)
            
            return ResponseSchema
        
        def GetPushNotificationsMetadata(self, notificationToken: str, notificationId: str) -> GetMetadataResponseModel:
            """
            Gets the corresponding metadata for the specified notification
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.GetPushNotificationsMetadata(notificationToken=string, notificationId=string)
        
            Args:
                notificationToken: str
            notificationId: str
            Returns:
                Notifications.GetMetadataResponseModel: Notifications.GetMetadataResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {"notificationToken": notificationToken, "notificationId": notificationId},"headers": {},"cookies": {}}
            
            GetPushNotificationsMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Notifications.roblox.com/v2/push-notifications/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.GetMetadataResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetPushNotificationsMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPushNotificationsMetadataRecivedData)
            
            return ResponseSchema
        
        def GetPushNotificationsNotificationIds(self, notificationToken: str, limit: int, cursor: int) -> NotificationIdsResponseModel:
            """
            Gets the notificationIds for the specified notification token
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.GetPushNotificationsNotificationIds(notificationToken=string, limit=integer, cursor=integer)
        
            Args:
                notificationToken: str
            limit: int
            cursor: int
            Returns:
                Notifications.NotificationIdsResponseModel: Notifications.NotificationIdsResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {"notificationToken": notificationToken, "limit": limit, "cursor": cursor},"headers": {},"cookies": {}}
            
            GetPushNotificationsNotificationIdsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Notifications.roblox.com/v2/push-notifications/notification-ids", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.NotificationIdsResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetPushNotificationsNotificationIdsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPushNotificationsNotificationIdsRecivedData)
            
            return ResponseSchema
        
        def GetStreamNotificationsGetLatestGameUpdates(self, universeIds: list, sinceDateTime: str) -> requests.Response:
            """
            Unknown
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.GetStreamNotificationsGetLatestGameUpdates(universeIds=array, sinceDateTime=string)
        
            Args:
                universeIds: list
            sinceDateTime: str
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"universeIds": universeIds, "sinceDateTime": sinceDateTime},"headers": {},"cookies": {}}
            
            GetStreamNotificationsGetLatestGameUpdatesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Notifications.roblox.com/v2/stream-notifications/get-latest-game-updates", Dictinary=Dictinary)
            return GetStreamNotificationsGetLatestGameUpdatesRecivedData
        
        def GetStreamNotificationsGetRecent(self, startIndex: int, maxRows: int) -> requests.Response:
            """
            Gets the recent entries from the notification stream
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.GetStreamNotificationsGetRecent(startIndex=integer, maxRows=integer)
        
            Args:
                startIndex: int
            maxRows: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"startIndex": startIndex, "maxRows": maxRows},"headers": {},"cookies": {}}
            
            GetStreamNotificationsGetRecentRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Notifications.roblox.com/v2/stream-notifications/get-recent", Dictinary=Dictinary)
            return GetStreamNotificationsGetRecentRecivedData
        
        def GetStreamNotificationsMetadata(self) -> NotificationStreamMetadataResponse:
            """
            Get Notification Stream metadata.
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.GetStreamNotificationsMetadata()
        
            Args:
                
            Returns:
                Notifications.NotificationStreamMetadataResponse: Notifications.NotificationStreamMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetStreamNotificationsMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Notifications.roblox.com/v2/stream-notifications/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.NotificationStreamMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetStreamNotificationsMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetStreamNotificationsMetadataRecivedData)
            
            return ResponseSchema
        
        def GetStreamNotificationsUnreadCount(self) -> UnreadStreamNotificationsModel:
            """
            Gets the count of unread Notification stream entries
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.GetStreamNotificationsUnreadCount()
        
            Args:
                
            Returns:
                Notifications.UnreadStreamNotificationsModel: Notifications.UnreadStreamNotificationsModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetStreamNotificationsUnreadCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Notifications.roblox.com/v2/stream-notifications/unread-count", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.UnreadStreamNotificationsModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetStreamNotificationsUnreadCountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetStreamNotificationsUnreadCountRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsDeregisterAllDevices(self) -> SuccessResponseModel:
            """
            De-register all devices to disable push notifications
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsDeregisterAllDevices()
        
            Args:
                
            Returns:
                Notifications.SuccessResponseModel: Notifications.SuccessResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostPushNotificationsDeregisterAllDevicesRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/deregister-all-devices", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.SuccessResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsDeregisterAllDevicesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsDeregisterAllDevicesRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsDeregisterCurrentDevice(self) -> SuccessResponseModel:
            """
            De-register current device to disable push notifications
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsDeregisterCurrentDevice()
        
            Args:
                
            Returns:
                Notifications.SuccessResponseModel: Notifications.SuccessResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostPushNotificationsDeregisterCurrentDeviceRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/deregister-current-device", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.SuccessResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsDeregisterCurrentDeviceRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsDeregisterCurrentDeviceRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsDeregisterCurrentDeviceIosPushkit(self) -> SuccessResponseModel:
            """
            De-register current device to disable pushkit notifications
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsDeregisterCurrentDeviceIosPushkit()
        
            Args:
                
            Returns:
                Notifications.SuccessResponseModel: Notifications.SuccessResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostPushNotificationsDeregisterCurrentDeviceIosPushkitRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/deregister-current-device-ios-pushkit", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.SuccessResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsDeregisterCurrentDeviceIosPushkitRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsDeregisterCurrentDeviceIosPushkitRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsMarkAsRead(self, MarkAsReadRequestModel: MarkAsReadRequestModel) -> SuccessResponseModel:
            """
            Marks the specified notification as read.
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsMarkAsRead(MarkAsReadRequestModel=Notifications.MarkAsReadRequestModel())
        
            Args:
                MarkAsReadRequestModel: MarkAsReadRequestModel
            Returns:
                Notifications.SuccessResponseModel: Notifications.SuccessResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'MarkAsReadRequestModel': 'json'}
            Arguments = inspect.signature(self.PostPushNotificationsMarkAsRead)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPushNotificationsMarkAsReadRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/mark-as-read", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.SuccessResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsMarkAsReadRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsMarkAsReadRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsMarkCategoryAsRead(self, MarkCategoryAsReadRequestModel: MarkCategoryAsReadRequestModel) -> SuccessResponseModel:
            """
            Mark all notifications in the specified stacking category up until the specified date read
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsMarkCategoryAsRead(MarkCategoryAsReadRequestModel=Notifications.MarkCategoryAsReadRequestModel())
        
            Args:
                MarkCategoryAsReadRequestModel: MarkCategoryAsReadRequestModel
            Returns:
                Notifications.SuccessResponseModel: Notifications.SuccessResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'MarkCategoryAsReadRequestModel': 'json'}
            Arguments = inspect.signature(self.PostPushNotificationsMarkCategoryAsRead)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPushNotificationsMarkCategoryAsReadRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/mark-category-as-read", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.SuccessResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsMarkCategoryAsReadRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsMarkCategoryAsReadRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsMarkInteraction(self, MarkInteractionRequestModel: MarkInteractionRequestModel) -> SuccessResponseModel:
            """
            Marks Interaction status for push notification
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsMarkInteraction(MarkInteractionRequestModel=Notifications.MarkInteractionRequestModel())
        
            Args:
                MarkInteractionRequestModel: MarkInteractionRequestModel
            Returns:
                Notifications.SuccessResponseModel: Notifications.SuccessResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'MarkInteractionRequestModel': 'json'}
            Arguments = inspect.signature(self.PostPushNotificationsMarkInteraction)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPushNotificationsMarkInteractionRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/mark-interaction", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.SuccessResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsMarkInteractionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsMarkInteractionRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsRegisterAndroidAmazon(self, RegisterAndroidAmazonRequestModel: RegisterAndroidAmazonRequestModel) -> RegistrationResponseModel:
            """
            Register Amazon Android for push notifications
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsRegisterAndroidAmazon(RegisterAndroidAmazonRequestModel=Notifications.RegisterAndroidAmazonRequestModel())
        
            Args:
                RegisterAndroidAmazonRequestModel: RegisterAndroidAmazonRequestModel
            Returns:
                Notifications.RegistrationResponseModel: Notifications.RegistrationResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RegisterAndroidAmazonRequestModel': 'json'}
            Arguments = inspect.signature(self.PostPushNotificationsRegisterAndroidAmazon)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPushNotificationsRegisterAndroidAmazonRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/register-android-amazon", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.RegistrationResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsRegisterAndroidAmazonRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsRegisterAndroidAmazonRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsRegisterAndroidNative(self, RegisterAndroidRequestModel: RegisterAndroidRequestModel) -> RegistrationResponseModel:
            """
            Register Android Native for push notifications
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsRegisterAndroidNative(RegisterAndroidRequestModel=Notifications.RegisterAndroidRequestModel())
        
            Args:
                RegisterAndroidRequestModel: RegisterAndroidRequestModel
            Returns:
                Notifications.RegistrationResponseModel: Notifications.RegistrationResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RegisterAndroidRequestModel': 'json'}
            Arguments = inspect.signature(self.PostPushNotificationsRegisterAndroidNative)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPushNotificationsRegisterAndroidNativeRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/register-android-native", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.RegistrationResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsRegisterAndroidNativeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsRegisterAndroidNativeRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsRegisterAndroidTencentService(self, RegisterTencentServiceRequestModel: RegisterTencentServiceRequestModel) -> RegistrationResponseModel:
            """
            Register Android Tencent service device for push notifications
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsRegisterAndroidTencentService(RegisterTencentServiceRequestModel=Notifications.RegisterTencentServiceRequestModel())
        
            Args:
                RegisterTencentServiceRequestModel: RegisterTencentServiceRequestModel
            Returns:
                Notifications.RegistrationResponseModel: Notifications.RegistrationResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RegisterTencentServiceRequestModel': 'json'}
            Arguments = inspect.signature(self.PostPushNotificationsRegisterAndroidTencentService)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPushNotificationsRegisterAndroidTencentServiceRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/register-android-tencent-service", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.RegistrationResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsRegisterAndroidTencentServiceRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsRegisterAndroidTencentServiceRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsRegisterChrome(self, RegisterChromeRequestModel: RegisterChromeRequestModel) -> RegistrationResponseModel:
            """
            Registers Chrome for push notifications
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsRegisterChrome(RegisterChromeRequestModel=Notifications.RegisterChromeRequestModel())
        
            Args:
                RegisterChromeRequestModel: RegisterChromeRequestModel
            Returns:
                Notifications.RegistrationResponseModel: Notifications.RegistrationResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RegisterChromeRequestModel': 'json'}
            Arguments = inspect.signature(self.PostPushNotificationsRegisterChrome)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPushNotificationsRegisterChromeRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/register-chrome", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.RegistrationResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsRegisterChromeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsRegisterChromeRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsRegisterFirefox(self, RegisterFirefoxRequestModel: RegisterFirefoxRequestModel) -> RegistrationResponseModel:
            """
            Registers Firefox for push notifications
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsRegisterFirefox(RegisterFirefoxRequestModel=Notifications.RegisterFirefoxRequestModel())
        
            Args:
                RegisterFirefoxRequestModel: RegisterFirefoxRequestModel
            Returns:
                Notifications.RegistrationResponseModel: Notifications.RegistrationResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RegisterFirefoxRequestModel': 'json'}
            Arguments = inspect.signature(self.PostPushNotificationsRegisterFirefox)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPushNotificationsRegisterFirefoxRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/register-firefox", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.RegistrationResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsRegisterFirefoxRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsRegisterFirefoxRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsRegisterIosNative(self, RegisterIOSNativeRequestModel: RegisterIOSNativeRequestModel) -> RegistrationResponseModel:
            """
            Registers IOS device for push notifications
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsRegisterIosNative(RegisterIOSNativeRequestModel=Notifications.RegisterIOSNativeRequestModel())
        
            Args:
                RegisterIOSNativeRequestModel: RegisterIOSNativeRequestModel
            Returns:
                Notifications.RegistrationResponseModel: Notifications.RegistrationResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RegisterIOSNativeRequestModel': 'json'}
            Arguments = inspect.signature(self.PostPushNotificationsRegisterIosNative)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPushNotificationsRegisterIosNativeRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/register-ios-native", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.RegistrationResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsRegisterIosNativeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsRegisterIosNativeRecivedData)
            
            return ResponseSchema
        
        def PostPushNotificationsRegisterIosPushkit(self, RegisterIOSPushKitRequestModel: RegisterIOSPushKitRequestModel) -> RegistrationResponseModel:
            """
            Registers IOS device for pushkit notifications
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostPushNotificationsRegisterIosPushkit(RegisterIOSPushKitRequestModel=Notifications.RegisterIOSPushKitRequestModel())
        
            Args:
                RegisterIOSPushKitRequestModel: RegisterIOSPushKitRequestModel
            Returns:
                Notifications.RegistrationResponseModel: Notifications.RegistrationResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RegisterIOSPushKitRequestModel': 'json'}
            Arguments = inspect.signature(self.PostPushNotificationsRegisterIosPushkit)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPushNotificationsRegisterIosPushkitRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/push-notifications/register-ios-pushkit", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.RegistrationResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPushNotificationsRegisterIosPushkitRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPushNotificationsRegisterIosPushkitRecivedData)
            
            return ResponseSchema
        
        def PostStreamNotificationsClearUnread(self) -> SuccessResponseModel:
            """
            Clears the unread Notification stream count
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostStreamNotificationsClearUnread()
        
            Args:
                
            Returns:
                Notifications.SuccessResponseModel: Notifications.SuccessResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostStreamNotificationsClearUnreadRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/stream-notifications/clear-unread", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.SuccessResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostStreamNotificationsClearUnreadRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostStreamNotificationsClearUnreadRecivedData)
            
            return ResponseSchema
        
        def PostStreamNotificationsGameUpdateNotificationRead(self, GameUpdateNotificationReadRequestModel: GameUpdateNotificationReadRequestModel) -> SuccessResponseModel:
            """
            Sends metrics when a Game Update Notification is Read from the Game Update Notifications Section of the Notification Stream
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostStreamNotificationsGameUpdateNotificationRead(GameUpdateNotificationReadRequestModel=Notifications.GameUpdateNotificationReadRequestModel())
        
            Args:
                GameUpdateNotificationReadRequestModel: GameUpdateNotificationReadRequestModel
            Returns:
                Notifications.SuccessResponseModel: Notifications.SuccessResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'GameUpdateNotificationReadRequestModel': 'json'}
            Arguments = inspect.signature(self.PostStreamNotificationsGameUpdateNotificationRead)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostStreamNotificationsGameUpdateNotificationReadRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/stream-notifications/game-update-notification-read", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.SuccessResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostStreamNotificationsGameUpdateNotificationReadRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostStreamNotificationsGameUpdateNotificationReadRecivedData)
            
            return ResponseSchema
        
        def PostStreamNotificationsMarkInteracted(self, MarkInteractedRequestModel: MarkInteractedRequestModel) -> SuccessResponseModel:
            """
            Marks a Notification Stream Entry as Interacted
            
            Usage:
                import Notifications
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                NotificationsApi = Notifications.NotificationsApi(RobloxClient=RobloxClient)
                Response = NotificationsApi.PostStreamNotificationsMarkInteracted(MarkInteractedRequestModel=Notifications.MarkInteractedRequestModel())
        
            Args:
                MarkInteractedRequestModel: MarkInteractedRequestModel
            Returns:
                Notifications.SuccessResponseModel: Notifications.SuccessResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'MarkInteractedRequestModel': 'json'}
            Arguments = inspect.signature(self.PostStreamNotificationsMarkInteracted)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostStreamNotificationsMarkInteractedRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Notifications.roblox.com/v2/stream-notifications/mark-interacted", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Notifications.SuccessResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostStreamNotificationsMarkInteractedRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostStreamNotificationsMarkInteractedRecivedData)
            
            return ResponseSchema
        
    class Metrics:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class RecordBundleLoadRequest:
            def __init__(ClassObject, bundleUrl: str = None, bundleName: str = None, loadTimeInMilliseconds: int = None, cdnProviderName: str = None, loadState: enum.Enum = None, bundleContentType: enum.Enum = None):
                ClassObject.bundleUrl = bundleUrl
                ClassObject.bundleName = bundleName
                ClassObject.loadTimeInMilliseconds = loadTimeInMilliseconds
                ClassObject.cdnProviderName = cdnProviderName
                ClassObject.loadState = loadState
                ClassObject.bundleContentType = bundleContentType
                ClassObject.response: requests.Response = None


        class RecordThumbnailLoadRequest:
            def __init__(ClassObject, duration: int = None, loadState: enum.Enum = None, thumbnailType: str = None):
                ClassObject.duration = duration
                ClassObject.loadState = loadState
                ClassObject.thumbnailType = thumbnailType
                ClassObject.response: requests.Response = None


        class ThumbnailLoadMetadataResponse:
            def __init__(ClassObject, logRatio: float = None):
                ClassObject.logRatio = logRatio
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass


        
        def GetThumbnailsMetadata(self) -> ThumbnailLoadMetadataResponse:
            """
            Get metadata related to logging thumbnail load metrics.

e.g. ThumbnailLoadLoggingRatio
            
            Usage:
                import Metrics
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                MetricsApi = Metrics.MetricsApi(RobloxClient=RobloxClient)
                Response = MetricsApi.GetThumbnailsMetadata()
        
            Args:
                
            Returns:
                Metrics.ThumbnailLoadMetadataResponse: Metrics.ThumbnailLoadMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetThumbnailsMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Metrics.roblox.com/v1/thumbnails/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Metrics.ThumbnailLoadMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetThumbnailsMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetThumbnailsMetadataRecivedData)
            
            return ResponseSchema
        
        def PostBundleMetricsReport(self, RecordBundleLoadRequest: RecordBundleLoadRequest) -> ApiEmptyResponseModel:
            """
            Records bundle load successes.
            
            Usage:
                import Metrics
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                MetricsApi = Metrics.MetricsApi(RobloxClient=RobloxClient)
                Response = MetricsApi.PostBundleMetricsReport(RecordBundleLoadRequest=Metrics.RecordBundleLoadRequest())
        
            Args:
                RecordBundleLoadRequest: RecordBundleLoadRequest
            Returns:
                Metrics.ApiEmptyResponseModel: Metrics.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RecordBundleLoadRequest': 'json'}
            Arguments = inspect.signature(self.PostBundleMetricsReport)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostBundleMetricsReportRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Metrics.roblox.com/v1/bundle-metrics/report", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Metrics.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostBundleMetricsReportRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostBundleMetricsReportRecivedData)
            
            return ResponseSchema
        
        def PostThumbnailsLoad(self, RecordThumbnailLoadRequest: RecordThumbnailLoadRequest) -> ApiEmptyResponseModel:
            """
            Records the time it takes for a thumbnail to get loaded in the UI.
            
            Usage:
                import Metrics
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                MetricsApi = Metrics.MetricsApi(RobloxClient=RobloxClient)
                Response = MetricsApi.PostThumbnailsLoad(RecordThumbnailLoadRequest=Metrics.RecordThumbnailLoadRequest())
        
            Args:
                RecordThumbnailLoadRequest: RecordThumbnailLoadRequest
            Returns:
                Metrics.ApiEmptyResponseModel: Metrics.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RecordThumbnailLoadRequest': 'json'}
            Arguments = inspect.signature(self.PostThumbnailsLoad)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostThumbnailsLoadRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Metrics.roblox.com/v1/thumbnails/load", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Metrics.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostThumbnailsLoadRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostThumbnailsLoadRecivedData)
            
            return ResponseSchema
        
    class LocalizationTables:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class GameLocation:
            def __init__(ClassObject, path: str = None):
                ClassObject.path = path
                ClassObject.response: requests.Response = None


        class AutoLocalizationMetadataResponse:
            def __init__(ClassObject, isReactVersionEnabledForAutoLocalizationSettings: bool = None, isTabbedUIEnabledForConfigureLocalizationPage: bool = None, isAutomaticTranslationToggleUIEnabled: bool = None, isAutomaticTranslationQuotaUIEnabled: bool = None):
                ClassObject.isReactVersionEnabledForAutoLocalizationSettings = isReactVersionEnabledForAutoLocalizationSettings
                ClassObject.isTabbedUIEnabledForConfigureLocalizationPage = isTabbedUIEnabledForConfigureLocalizationPage
                ClassObject.isAutomaticTranslationToggleUIEnabled = isAutomaticTranslationToggleUIEnabled
                ClassObject.isAutomaticTranslationQuotaUIEnabled = isAutomaticTranslationQuotaUIEnabled
                ClassObject.response: requests.Response = None


        class MatchedEntry:
            def __init__(ClassObject, source: str = None, matchedParamIndex: int = None):
                ClassObject.source = source
                ClassObject.matchedParamIndex = matchedParamIndex
                ClassObject.response: requests.Response = None


        class AutoScrapeEntryMetadata:
            def __init__(ClassObject, text: str = None, userId: int = None, osPlatform: str = None, sessionId: str = None, matchedEntry: "RobloxClient.LocalizationTables.MatchedEntry" = None):
                ClassObject.text = text
                ClassObject.userId = userId
                ClassObject.osPlatform = osPlatform
                ClassObject.sessionId = sessionId
                ClassObject.matchedEntry = matchedEntry
                ClassObject.response: requests.Response = None


        class AutoScrapeEntry:
            def __init__(ClassObject, context: str = None, source: str = None, screenshot: str = None, meta: "RobloxClient.LocalizationTables.AutoScrapeEntryMetadata" = None):
                ClassObject.context = context
                ClassObject.source = source
                ClassObject.screenshot = screenshot
                ClassObject.meta = meta
                ClassObject.response: requests.Response = None


        class CreateTableRequest:
            def __init__(ClassObject, name: str = None, ownerType: enum.Enum = None, ownerId: int = None):
                ClassObject.name = name
                ClassObject.ownerType = ownerType
                ClassObject.ownerId = ownerId
                ClassObject.response: requests.Response = None


        class CreateTableResponse:
            def __init__(ClassObject, id: str = None, assetId: int = None):
                ClassObject.id = id
                ClassObject.assetId = assetId
                ClassObject.response: requests.Response = None


        class EntryIdentifier:
            def __init__(ClassObject, key: str = None, context: str = None, source: str = None):
                ClassObject.key = key
                ClassObject.context = context
                ClassObject.source = source
                ClassObject.response: requests.Response = None


        class CursorEntryIdentifier:
            def __init__(ClassObject, cursor: str = None, identifier: "RobloxClient.LocalizationTables.EntryIdentifier" = None, count: int = None, sortOrder: enum.Enum = None):
                ClassObject.cursor = cursor
                ClassObject.identifier = identifier
                ClassObject.count = count
                ClassObject.sortOrder = sortOrder
                ClassObject.response: requests.Response = None


        class EntryMetadata:
            def __init__(ClassObject, example: str = None, gameLocations: list["RobloxClient.LocalizationTables.GameLocation"] = None):
                ClassObject.example = example
                ClassObject.gameLocations = gameLocations
                ClassObject.response: requests.Response = None


        class Translator:
            def __init__(ClassObject, id: int = None, agentType: enum.Enum = None):
                ClassObject.id = id
                ClassObject.agentType = agentType
                ClassObject.response: requests.Response = None


        class Translation:
            def __init__(ClassObject, locale: str = None, translationText: str = None, translator: "RobloxClient.LocalizationTables.Translator" = None, updatedTime: str = None, feedbackCount: int = None):
                ClassObject.locale = locale
                ClassObject.translationText = translationText
                ClassObject.translator = translator
                ClassObject.updatedTime = updatedTime
                ClassObject.feedbackCount = feedbackCount
                ClassObject.response: requests.Response = None


        class Entry:
            def __init__(ClassObject, identifier: "RobloxClient.LocalizationTables.EntryIdentifier" = None, metadata: "RobloxClient.LocalizationTables.EntryMetadata" = None, translations: list["RobloxClient.LocalizationTables.Translation"] = None, createdTime: str = None):
                ClassObject.identifier = identifier
                ClassObject.metadata = metadata
                ClassObject.translations = translations
                ClassObject.createdTime = createdTime
                ClassObject.response: requests.Response = None


        class EntryIdentifierWithTranslation:
            def __init__(ClassObject, translation: "RobloxClient.LocalizationTables.Translation" = None, key: str = None, context: str = None, source: str = None):
                ClassObject.translation = translation
                ClassObject.key = key
                ClassObject.context = context
                ClassObject.source = source
                ClassObject.response: requests.Response = None


        class EntryOperationLimits:
            def __init__(ClassObject, maxContextLength: int = None, maxKeyLength: int = None, maxSourceLength: int = None, maxExampleLength: int = None, maxGameLocationPathLength: int = None):
                ClassObject.maxContextLength = maxContextLength
                ClassObject.maxKeyLength = maxKeyLength
                ClassObject.maxSourceLength = maxSourceLength
                ClassObject.maxExampleLength = maxExampleLength
                ClassObject.maxGameLocationPathLength = maxGameLocationPathLength
                ClassObject.response: requests.Response = None


        class EntryTranslationFeedback:
            def __init__(ClassObject, identifier: "RobloxClient.LocalizationTables.EntryIdentifierWithTranslation" = None, feedbackCount: int = None, playerSuggestionText: list[str] = None, reasons: list[str] = None, robloxSuggestionText: str = None):
                ClassObject.identifier = identifier
                ClassObject.feedbackCount = feedbackCount
                ClassObject.playerSuggestionText = playerSuggestionText
                ClassObject.reasons = reasons
                ClassObject.robloxSuggestionText = robloxSuggestionText
                ClassObject.response: requests.Response = None


        class TranslationHistory:
            def __init__(ClassObject, translationText: str = None, translator: "RobloxClient.LocalizationTables.Translator" = None, created: str = None):
                ClassObject.translationText = translationText
                ClassObject.translator = translator
                ClassObject.created = created
                ClassObject.response: requests.Response = None


        class EntryTranslationHistoryPaged:
            def __init__(ClassObject, identifier: "RobloxClient.LocalizationTables.EntryIdentifier" = None, history: list["RobloxClient.LocalizationTables.TranslationHistory"] = None, nextCursor: str = None):
                ClassObject.identifier = identifier
                ClassObject.history = history
                ClassObject.nextCursor = nextCursor
                ClassObject.response: requests.Response = None


        class Error:
            def __init__(ClassObject, errorCode: int = None, errorMessage: str = None):
                ClassObject.errorCode = errorCode
                ClassObject.errorMessage = errorMessage
                ClassObject.response: requests.Response = None


        class FailedEntry:
            def __init__(ClassObject, error: "RobloxClient.LocalizationTables.Error" = None, identifier: "RobloxClient.LocalizationTables.EntryIdentifier" = None, metadata: "RobloxClient.LocalizationTables.EntryMetadata" = None, translations: list["RobloxClient.LocalizationTables.Translation"] = None, createdTime: str = None):
                ClassObject.error = error
                ClassObject.identifier = identifier
                ClassObject.metadata = metadata
                ClassObject.translations = translations
                ClassObject.createdTime = createdTime
                ClassObject.response: requests.Response = None


        class FailedEntryTranslationHistoryPaged:
            def __init__(ClassObject, identifier: "RobloxClient.LocalizationTables.EntryIdentifier" = None, count: int = None, error: "RobloxClient.LocalizationTables.Error" = None):
                ClassObject.identifier = identifier
                ClassObject.count = count
                ClassObject.error = error
                ClassObject.response: requests.Response = None


        class GameAutolocalizationInformationResponse:
            def __init__(ClassObject, isAutolocalizationEnabled: bool = None, isAutomaticEntriesSettingEnabled: bool = None, isAutomaticEntriesDeletionEnabled: bool = None, shouldUseLocalizationTable: bool = None, autoLocalizationTableId: str = None, assetId: int = None):
                ClassObject.isAutolocalizationEnabled = isAutolocalizationEnabled
                ClassObject.isAutomaticEntriesSettingEnabled = isAutomaticEntriesSettingEnabled
                ClassObject.isAutomaticEntriesDeletionEnabled = isAutomaticEntriesDeletionEnabled
                ClassObject.shouldUseLocalizationTable = shouldUseLocalizationTable
                ClassObject.autoLocalizationTableId = autoLocalizationTableId
                ClassObject.assetId = assetId
                ClassObject.response: requests.Response = None


        class TableOperationLimits:
            def __init__(ClassObject, maxEntriesPerUpdate: int = None):
                ClassObject.maxEntriesPerUpdate = maxEntriesPerUpdate
                ClassObject.response: requests.Response = None


        class GetLimitsResponse:
            def __init__(ClassObject, entryOperationLimits: "RobloxClient.LocalizationTables.EntryOperationLimits" = None, tableOperationLimits: "RobloxClient.LocalizationTables.TableOperationLimits" = None):
                ClassObject.entryOperationLimits = entryOperationLimits
                ClassObject.tableOperationLimits = tableOperationLimits
                ClassObject.response: requests.Response = None


        class GetTableEntriesPagedResponse:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.LocalizationTables.Entry"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GetTableEntriesTranslationFeedbackRequest:
            def __init__(ClassObject, sourceLocale: str = None, entries: list["RobloxClient.LocalizationTables.EntryIdentifierWithTranslation"] = None):
                ClassObject.sourceLocale = sourceLocale
                ClassObject.entries = entries
                ClassObject.response: requests.Response = None


        class GetTableEntriesTranslationFeedbackResponse:
            def __init__(ClassObject, tableId: str = None, entries: list["RobloxClient.LocalizationTables.EntryTranslationFeedback"] = None):
                ClassObject.tableId = tableId
                ClassObject.entries = entries
                ClassObject.response: requests.Response = None


        class GetTableEntriesTranslationHistoryRequest:
            def __init__(ClassObject, locale: str = None, entries: list["RobloxClient.LocalizationTables.CursorEntryIdentifier"] = None):
                ClassObject.locale = locale
                ClassObject.entries = entries
                ClassObject.response: requests.Response = None


        class GetTableEntriesTranslationHistoryResponse:
            def __init__(ClassObject, tableId: str = None, locale: str = None, entries: list["RobloxClient.LocalizationTables.EntryTranslationHistoryPaged"] = None, failedEntries: list["RobloxClient.LocalizationTables.FailedEntryTranslationHistoryPaged"] = None):
                ClassObject.tableId = tableId
                ClassObject.locale = locale
                ClassObject.entries = entries
                ClassObject.failedEntries = failedEntries
                ClassObject.response: requests.Response = None


        class GetTableEntryCountResponse:
            def __init__(ClassObject, id: str = None, entryCount: int = None):
                ClassObject.id = id
                ClassObject.entryCount = entryCount
                ClassObject.response: requests.Response = None


        class GetTableResponse:
            def __init__(ClassObject, id: str = None, name: str = None, ownerType: enum.Enum = None, ownerId: int = None, assetId: int = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.ownerType = ownerType
                ClassObject.ownerId = ownerId
                ClassObject.assetId = assetId
                ClassObject.response: requests.Response = None


        class IngestContentMetadataPlaceInformation:
            def __init__(ClassObject, placeId: int = None, placeVersionNumber: int = None):
                ClassObject.placeId = placeId
                ClassObject.placeVersionNumber = placeVersionNumber
                ClassObject.response: requests.Response = None


        class IngestContentMetadata:
            def __init__(ClassObject, placeInformation: "RobloxClient.LocalizationTables.IngestContentMetadataPlaceInformation" = None):
                ClassObject.placeInformation = placeInformation
                ClassObject.response: requests.Response = None


        class IngestAutoScrapedContentForGameRequest:
            def __init__(ClassObject, entries: list["RobloxClient.LocalizationTables.AutoScrapeEntry"] = None, metadata: "RobloxClient.LocalizationTables.IngestContentMetadata" = None):
                ClassObject.entries = entries
                ClassObject.metadata = metadata
                ClassObject.response: requests.Response = None


        class Language:
            def __init__(ClassObject, name: str = None, nativeName: str = None, languageCode: str = None):
                ClassObject.name = name
                ClassObject.nativeName = nativeName
                ClassObject.languageCode = languageCode
                ClassObject.response: requests.Response = None


        class LocalizationTablesMetadataResponse:
            def __init__(ClassObject, isBulkUploadFeatureEnabled: bool = None, isCsvDownloadEnabled: bool = None, isAccessToTranslationMetaDataEnabled: bool = None, isTranslationManagementRedirectionEnabled: bool = None, isUntranslatedFilterEnabled: bool = None, isAutomaticTranslationFilterEnabled: bool = None):
                ClassObject.isBulkUploadFeatureEnabled = isBulkUploadFeatureEnabled
                ClassObject.isCsvDownloadEnabled = isCsvDownloadEnabled
                ClassObject.isAccessToTranslationMetaDataEnabled = isAccessToTranslationMetaDataEnabled
                ClassObject.isTranslationManagementRedirectionEnabled = isTranslationManagementRedirectionEnabled
                ClassObject.isUntranslatedFilterEnabled = isUntranslatedFilterEnabled
                ClassObject.isAutomaticTranslationFilterEnabled = isAutomaticTranslationFilterEnabled
                ClassObject.response: requests.Response = None


        class ModifiedEntry:
            def __init__(ClassObject, identifier: "RobloxClient.LocalizationTables.EntryIdentifier" = None, translations: list["RobloxClient.LocalizationTables.Translation"] = None):
                ClassObject.identifier = identifier
                ClassObject.translations = translations
                ClassObject.response: requests.Response = None


        class ChangeAgent:
            def __init__(ClassObject, ChangeAgentType: enum.Enum = None, Id: str = None, OptionalIdCase: enum.Enum = None):
                ClassObject.ChangeAgentType = ChangeAgentType
                ClassObject.Id = Id
                ClassObject.OptionalIdCase = OptionalIdCase
                ClassObject.response: requests.Response = None


        class PatchTranslation:
            def __init__(ClassObject, locale: str = None, translationText: str = None, delete: bool = None, changeAgent: "RobloxClient.LocalizationTables.ChangeAgent" = None, updatedTime: str = None):
                ClassObject.locale = locale
                ClassObject.translationText = translationText
                ClassObject.delete = delete
                ClassObject.changeAgent = changeAgent
                ClassObject.updatedTime = updatedTime
                ClassObject.response: requests.Response = None


        class PatchEntry:
            def __init__(ClassObject, identifier: "RobloxClient.LocalizationTables.EntryIdentifier" = None, metadata: "RobloxClient.LocalizationTables.EntryMetadata" = None, translations: list["RobloxClient.LocalizationTables.PatchTranslation"] = None, delete: bool = None):
                ClassObject.identifier = identifier
                ClassObject.metadata = metadata
                ClassObject.translations = translations
                ClassObject.delete = delete
                ClassObject.response: requests.Response = None


        class RaiseEventForAutoScrapedEntriesCleanupRequest:
            def __init__(ClassObject, maxAgeForFlush: str = None):
                ClassObject.maxAgeForFlush = maxAgeForFlush
                ClassObject.response: requests.Response = None


        class SetAutolocalizationSettingsForGameRequest:
            def __init__(ClassObject, isAutolocalizationEnabled: bool = None, isAutomaticEntriesSettingEnabled: bool = None, isAutomaticEntriesDeletionsEnabled: bool = None, shouldUseLocalizationTable: bool = None):
                ClassObject.isAutolocalizationEnabled = isAutolocalizationEnabled
                ClassObject.isAutomaticEntriesSettingEnabled = isAutomaticEntriesSettingEnabled
                ClassObject.isAutomaticEntriesDeletionsEnabled = isAutomaticEntriesDeletionsEnabled
                ClassObject.shouldUseLocalizationTable = shouldUseLocalizationTable
                ClassObject.response: requests.Response = None


        class SetAutolocalizationTableForGameRequest:
            def __init__(ClassObject, tableId: str = None):
                ClassObject.tableId = tableId
                ClassObject.response: requests.Response = None


        class UpdateTableContentsRequest:
            def __init__(ClassObject, name: str = None, entries: list["RobloxClient.LocalizationTables.PatchEntry"] = None):
                ClassObject.name = name
                ClassObject.entries = entries
                ClassObject.response: requests.Response = None


        class UpdateTableContentsResponse:
            def __init__(ClassObject, failedEntriesAndTranslations: list["RobloxClient.LocalizationTables.FailedEntry"] = None, modifiedEntriesAndTranslations: list["RobloxClient.LocalizationTables.ModifiedEntry"] = None):
                ClassObject.failedEntriesAndTranslations = failedEntriesAndTranslations
                ClassObject.modifiedEntriesAndTranslations = modifiedEntriesAndTranslations
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class LanguageExtra:
            def __init__(ClassObject, data: list["RobloxClient.LocalizationTables.Language"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetAutolocalizationMetadata(self) -> AutoLocalizationMetadataResponse:
            """
            Metadata for AutoLocalization Configuration
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.GetAutolocalizationMetadata()
        
            Args:
                
            Returns:
                LocalizationTables.AutoLocalizationMetadataResponse: LocalizationTables.AutoLocalizationMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAutolocalizationMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://LocalizationTables.roblox.com/v1/autolocalization/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.AutoLocalizationMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAutolocalizationMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAutolocalizationMetadataRecivedData)
            
            return ResponseSchema
        
        def GetLocalizationTableAvailableLanguages(self) -> LanguageExtra:
            """
            Gets the supported language codes that can be used by localization tables.
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.GetLocalizationTableAvailableLanguages()
        
            Args:
                
            Returns:
                LocalizationTables.LanguageExtra: LocalizationTables.LanguageExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetLocalizationTableAvailableLanguagesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://LocalizationTables.roblox.com/v1/localization-table/available-languages", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.LanguageExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetLocalizationTableAvailableLanguagesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetLocalizationTableAvailableLanguagesRecivedData)
            
            return ResponseSchema
        
        def GetLocalizationTableLimits(self) -> GetLimitsResponse:
            """
            Get limits for translation table entries operations
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.GetLocalizationTableLimits()
        
            Args:
                
            Returns:
                LocalizationTables.GetLimitsResponse: LocalizationTables.GetLimitsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetLocalizationTableLimitsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://LocalizationTables.roblox.com/v1/localization-table/limits", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.GetLimitsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetLocalizationTableLimitsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetLocalizationTableLimitsRecivedData)
            
            return ResponseSchema
        
        def GetLocalizationTableMetadata(self) -> LocalizationTablesMetadataResponse:
            """
            Get metadata for localization UI
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.GetLocalizationTableMetadata()
        
            Args:
                
            Returns:
                LocalizationTables.LocalizationTablesMetadataResponse: LocalizationTables.LocalizationTablesMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetLocalizationTableMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://LocalizationTables.roblox.com/v1/localization-table/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.LocalizationTablesMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetLocalizationTableMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetLocalizationTableMetadataRecivedData)
            
            return ResponseSchema
        
        def GetLocalizationTableTablesAssetid(self, assetId: int) -> GetTableResponse:
            """
            Get table information by the assetId of the table.
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.GetLocalizationTableTablesAssetid(assetId=integer)
        
            Args:
                assetId: int
            Returns:
                LocalizationTables.GetTableResponse: LocalizationTables.GetTableResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetLocalizationTableTablesAssetidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://LocalizationTables.roblox.com/v1/localization-table/tables/{assetId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.GetTableResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetLocalizationTableTablesAssetidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetLocalizationTableTablesAssetidRecivedData)
            
            return ResponseSchema
        
        def GetLocalizationTableTablesTableid(self, tableId: str) -> GetTableResponse:
            """
            Get table information by the id of the table.
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.GetLocalizationTableTablesTableid(tableId=string)
        
            Args:
                tableId: str
            Returns:
                LocalizationTables.GetTableResponse: LocalizationTables.GetTableResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetLocalizationTableTablesTableidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://LocalizationTables.roblox.com/v1/localization-table/tables/{tableId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.GetTableResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetLocalizationTableTablesTableidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetLocalizationTableTablesTableidRecivedData)
            
            return ResponseSchema
        
        def PatchLocalizationTableTablesTableid(self, gameId: int, tableId: str, UpdateTableContentsRequest: UpdateTableContentsRequest) -> UpdateTableContentsResponse:
            """
            Updates the tables contents based on what is provided.
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.PatchLocalizationTableTablesTableid(gameId=integer, tableId=string, UpdateTableContentsRequest=LocalizationTables.UpdateTableContentsRequest())
        
            Args:
                gameId: int
            tableId: str
            UpdateTableContentsRequest: UpdateTableContentsRequest
            Returns:
                LocalizationTables.UpdateTableContentsResponse: LocalizationTables.UpdateTableContentsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"gameId": gameId},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateTableContentsRequest': 'json'}
            Arguments = inspect.signature(self.PatchLocalizationTableTablesTableid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchLocalizationTableTablesTableidRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://LocalizationTables.roblox.com/v1/localization-table/tables/{tableId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.UpdateTableContentsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchLocalizationTableTablesTableidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchLocalizationTableTablesTableidRecivedData)
            
            return ResponseSchema
        
        def GetLocalizationTableTablesTableidEntries(self, cursor: str, gameId: int, tableId: str) -> GetTableEntriesPagedResponse:
            """
            Gets a batch of entries for a table.
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.GetLocalizationTableTablesTableidEntries(cursor=string, gameId=integer, tableId=string)
        
            Args:
                cursor: str
            gameId: int
            tableId: str
            Returns:
                LocalizationTables.GetTableEntriesPagedResponse: LocalizationTables.GetTableEntriesPagedResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"cursor": cursor, "gameId": gameId},"headers": {},"cookies": {}}
            
            GetLocalizationTableTablesTableidEntriesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://LocalizationTables.roblox.com/v1/localization-table/tables/{tableId}/entries", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.GetTableEntriesPagedResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetLocalizationTableTablesTableidEntriesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetLocalizationTableTablesTableidEntriesRecivedData)
            
            return ResponseSchema
        
        def GetLocalizationTableTablesTableidEntryCount(self, gameId: int, tableId: str) -> GetTableEntryCountResponse:
            """
            Gets the number of entries in the specified table
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.GetLocalizationTableTablesTableidEntryCount(gameId=integer, tableId=string)
        
            Args:
                gameId: int
            tableId: str
            Returns:
                LocalizationTables.GetTableEntryCountResponse: LocalizationTables.GetTableEntryCountResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"gameId": gameId},"headers": {},"cookies": {}}
            
            GetLocalizationTableTablesTableidEntryCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://LocalizationTables.roblox.com/v1/localization-table/tables/{tableId}/entry-count", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.GetTableEntryCountResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetLocalizationTableTablesTableidEntryCountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetLocalizationTableTablesTableidEntryCountRecivedData)
            
            return ResponseSchema
        
        def PostAutoLocalizationTableGamesGameidAssetsGenerationRequest(self, gameId: int) -> ApiEmptyResponseModel:
            """
            Generates localization asset of a game.
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.PostAutoLocalizationTableGamesGameidAssetsGenerationRequest(gameId=integer)
        
            Args:
                gameId: int
            Returns:
                LocalizationTables.ApiEmptyResponseModel: LocalizationTables.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostAutoLocalizationTableGamesGameidAssetsGenerationRequestRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://LocalizationTables.roblox.com/v1/auto-localization-table/games/{gameId}/assets-generation-request", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostAutoLocalizationTableGamesGameidAssetsGenerationRequestRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAutoLocalizationTableGamesGameidAssetsGenerationRequestRecivedData)
            
            return ResponseSchema
        
        def PostAutoLocalizationTableGamesGameidAutoScrapeCleanupRequest(self, gameId: int, RaiseEventForAutoScrapedEntriesCleanupRequest: RaiseEventForAutoScrapedEntriesCleanupRequest) -> requests.Response:
            """
            Enqueues an event to flush the auto scraped entries which doesn't have translations.
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.PostAutoLocalizationTableGamesGameidAutoScrapeCleanupRequest(gameId=integer, RaiseEventForAutoScrapedEntriesCleanupRequest=LocalizationTables.RaiseEventForAutoScrapedEntriesCleanupRequest())
        
            Args:
                gameId: int
            RaiseEventForAutoScrapedEntriesCleanupRequest: RaiseEventForAutoScrapedEntriesCleanupRequest
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RaiseEventForAutoScrapedEntriesCleanupRequest': 'json'}
            Arguments = inspect.signature(self.PostAutoLocalizationTableGamesGameidAutoScrapeCleanupRequest)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostAutoLocalizationTableGamesGameidAutoScrapeCleanupRequestRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://LocalizationTables.roblox.com/v1/auto-localization-table/games/{gameId}/auto-scrape-cleanup-request", Dictinary=Dictinary)
            return PostAutoLocalizationTableGamesGameidAutoScrapeCleanupRequestRecivedData
        
        def PatchAutolocalizationGamesGameidAutolocalizationtable(self, gameId: int, SetAutolocalizationTableForGameRequest: SetAutolocalizationTableForGameRequest) -> ApiEmptyResponseModel:
            """
            Unknown
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.PatchAutolocalizationGamesGameidAutolocalizationtable(gameId=integer, SetAutolocalizationTableForGameRequest=LocalizationTables.SetAutolocalizationTableForGameRequest())
        
            Args:
                gameId: int
            SetAutolocalizationTableForGameRequest: SetAutolocalizationTableForGameRequest
            Returns:
                LocalizationTables.ApiEmptyResponseModel: LocalizationTables.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SetAutolocalizationTableForGameRequest': 'json'}
            Arguments = inspect.signature(self.PatchAutolocalizationGamesGameidAutolocalizationtable)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchAutolocalizationGamesGameidAutolocalizationtableRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://LocalizationTables.roblox.com/v1/autolocalization/games/{gameId}/autolocalizationtable", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchAutolocalizationGamesGameidAutolocalizationtableRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchAutolocalizationGamesGameidAutolocalizationtableRecivedData)
            
            return ResponseSchema
        
        def PostAutolocalizationGamesGameidAutolocalizationtable(self, gameId: int) -> GameAutolocalizationInformationResponse:
            """
            Unknown
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.PostAutolocalizationGamesGameidAutolocalizationtable(gameId=integer)
        
            Args:
                gameId: int
            Returns:
                LocalizationTables.GameAutolocalizationInformationResponse: LocalizationTables.GameAutolocalizationInformationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostAutolocalizationGamesGameidAutolocalizationtableRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://LocalizationTables.roblox.com/v1/autolocalization/games/{gameId}/autolocalizationtable", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.GameAutolocalizationInformationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAutolocalizationGamesGameidAutolocalizationtableRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAutolocalizationGamesGameidAutolocalizationtableRecivedData)
            
            return ResponseSchema
        
        def PostLocalizationTableTables(self, CreateTableRequest: CreateTableRequest) -> CreateTableResponse:
            """
            Creates a Localization Table with the given data.

Note that this endpoint simply creates a table and does not associate it with any universe, so if intending to use this to create tables usable in experience more setup will be needed to grant those experiences access.
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.PostLocalizationTableTables(CreateTableRequest=LocalizationTables.CreateTableRequest())
        
            Args:
                CreateTableRequest: CreateTableRequest
            Returns:
                LocalizationTables.CreateTableResponse: LocalizationTables.CreateTableResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'CreateTableRequest': 'json'}
            Arguments = inspect.signature(self.PostLocalizationTableTables)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostLocalizationTableTablesRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://LocalizationTables.roblox.com/v1/localization-table/tables", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.CreateTableResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostLocalizationTableTablesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostLocalizationTableTablesRecivedData)
            
            return ResponseSchema
        
        def PostLocalizationTableTablesTableidEntriesTranslationFeedback(self, gameId: int, tableId: str, GetTableEntriesTranslationFeedbackRequest: GetTableEntriesTranslationFeedbackRequest) -> GetTableEntriesTranslationFeedbackResponse:
            """
            Gets the translation feedback for each entry passed in.
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.PostLocalizationTableTablesTableidEntriesTranslationFeedback(gameId=integer, tableId=string, GetTableEntriesTranslationFeedbackRequest=LocalizationTables.GetTableEntriesTranslationFeedbackRequest())
        
            Args:
                gameId: int
            tableId: str
            GetTableEntriesTranslationFeedbackRequest: GetTableEntriesTranslationFeedbackRequest
            Returns:
                LocalizationTables.GetTableEntriesTranslationFeedbackResponse: LocalizationTables.GetTableEntriesTranslationFeedbackResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"gameId": gameId},"headers": {},"cookies": {}}
            
            Schemas = {'GetTableEntriesTranslationFeedbackRequest': 'json'}
            Arguments = inspect.signature(self.PostLocalizationTableTablesTableidEntriesTranslationFeedback)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostLocalizationTableTablesTableidEntriesTranslationFeedbackRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://LocalizationTables.roblox.com/v1/localization-table/tables/{tableId}/entries/translation-feedback", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.GetTableEntriesTranslationFeedbackResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostLocalizationTableTablesTableidEntriesTranslationFeedbackRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostLocalizationTableTablesTableidEntriesTranslationFeedbackRecivedData)
            
            return ResponseSchema
        
        def PostLocalizationTableTablesTableidEntriesTranslationHistory(self, gameId: int, tableId: str, GetTableEntriesTranslationHistoryRequest: GetTableEntriesTranslationHistoryRequest) -> GetTableEntriesTranslationHistoryResponse:
            """
            Gets the translation history for each entry passed in.
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.PostLocalizationTableTablesTableidEntriesTranslationHistory(gameId=integer, tableId=string, GetTableEntriesTranslationHistoryRequest=LocalizationTables.GetTableEntriesTranslationHistoryRequest())
        
            Args:
                gameId: int
            tableId: str
            GetTableEntriesTranslationHistoryRequest: GetTableEntriesTranslationHistoryRequest
            Returns:
                LocalizationTables.GetTableEntriesTranslationHistoryResponse: LocalizationTables.GetTableEntriesTranslationHistoryResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"gameId": gameId},"headers": {},"cookies": {}}
            
            Schemas = {'GetTableEntriesTranslationHistoryRequest': 'json'}
            Arguments = inspect.signature(self.PostLocalizationTableTablesTableidEntriesTranslationHistory)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostLocalizationTableTablesTableidEntriesTranslationHistoryRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://LocalizationTables.roblox.com/v1/localization-table/tables/{tableId}/entries/translation-history", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.GetTableEntriesTranslationHistoryResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostLocalizationTableTablesTableidEntriesTranslationHistoryRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostLocalizationTableTablesTableidEntriesTranslationHistoryRecivedData)
            
            return ResponseSchema
        
        def PatchAutoLocalizationTableGamesGameidIngestion(self, gameId: int, IngestAutoScrapedContentForGameRequest: IngestAutoScrapedContentForGameRequest) -> requests.Response:
            """
            Ingests entries for auto localization. Needs to be an authorized user.
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.PatchAutoLocalizationTableGamesGameidIngestion(gameId=integer, IngestAutoScrapedContentForGameRequest=LocalizationTables.IngestAutoScrapedContentForGameRequest())
        
            Args:
                gameId: int
            IngestAutoScrapedContentForGameRequest: IngestAutoScrapedContentForGameRequest
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'IngestAutoScrapedContentForGameRequest': 'json'}
            Arguments = inspect.signature(self.PatchAutoLocalizationTableGamesGameidIngestion)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchAutoLocalizationTableGamesGameidIngestionRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://LocalizationTables.roblox.com/v1/auto-localization-table/games/{gameId}/ingestion", Dictinary=Dictinary)
            return PatchAutoLocalizationTableGamesGameidIngestionRecivedData
        
        def PatchAutolocalizationGamesGameidSettings(self, gameId: int, SetAutolocalizationSettingsForGameRequest: SetAutolocalizationSettingsForGameRequest) -> ApiEmptyResponseModel:
            """
            Sets a game's auto-localization related settings
            
            Usage:
                import LocalizationTables
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                LocalizationTablesApi = LocalizationTables.LocalizationTablesApi(RobloxClient=RobloxClient)
                Response = LocalizationTablesApi.PatchAutolocalizationGamesGameidSettings(gameId=integer, SetAutolocalizationSettingsForGameRequest=LocalizationTables.SetAutolocalizationSettingsForGameRequest())
        
            Args:
                gameId: int
            SetAutolocalizationSettingsForGameRequest: SetAutolocalizationSettingsForGameRequest
            Returns:
                LocalizationTables.ApiEmptyResponseModel: LocalizationTables.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SetAutolocalizationSettingsForGameRequest': 'json'}
            Arguments = inspect.signature(self.PatchAutolocalizationGamesGameidSettings)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchAutolocalizationGamesGameidSettingsRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://LocalizationTables.roblox.com/v1/autolocalization/games/{gameId}/settings", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.LocalizationTables.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchAutolocalizationGamesGameidSettingsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchAutolocalizationGamesGameidSettingsRecivedData)
            
            return ResponseSchema
        
    class ItemConfiguration:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class AssetCreationsDetailsRequest:
            def __init__(ClassObject, assetIds: list[int] = None):
                ClassObject.assetIds = assetIds
                ClassObject.response: requests.Response = None


        class PriceConfigurationModel:
            def __init__(ClassObject, priceInRobux: int = None, premiumDiscountPercentage: int = None, premiumPriceInRobux: int = None, priceOffset: int = None):
                ClassObject.priceInRobux = priceInRobux
                ClassObject.premiumDiscountPercentage = premiumDiscountPercentage
                ClassObject.premiumPriceInRobux = premiumPriceInRobux
                ClassObject.priceOffset = priceOffset
                ClassObject.response: requests.Response = None


        class ReleaseConfigurationResponseModel:
            def __init__(ClassObject, saleAvailabilityLocations: list[str] = None):
                ClassObject.saleAvailabilityLocations = saleAvailabilityLocations
                ClassObject.response: requests.Response = None


        class AssetCreationsDetailsResponse:
            def __init__(ClassObject, assetId: int = None, name: str = None, status: enum.Enum = None, description: str = None, creatorType: enum.Enum = None, creatorTargetId: int = None, price: int = None, priceConfiguration: "RobloxClient.ItemConfiguration.PriceConfigurationModel" = None, isArchived: bool = None, assetType: str = None, releaseConfiguration: "RobloxClient.ItemConfiguration.ReleaseConfigurationResponseModel" = None, created: str = None, updated: str = None):
                ClassObject.assetId = assetId
                ClassObject.name = name
                ClassObject.status = status
                ClassObject.description = description
                ClassObject.creatorType = creatorType
                ClassObject.creatorTargetId = creatorTargetId
                ClassObject.price = price
                ClassObject.priceConfiguration = priceConfiguration
                ClassObject.isArchived = isArchived
                ClassObject.assetType = assetType
                ClassObject.releaseConfiguration = releaseConfiguration
                ClassObject.created = created
                ClassObject.updated = updated
                ClassObject.response: requests.Response = None


        class AssetCreationsResponse:
            def __init__(ClassObject, assetId: int = None, name: str = None):
                ClassObject.assetId = assetId
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class CreateItemTagRequest:
            def __init__(ClassObject, itemId: str = None, tagId: str = None):
                ClassObject.itemId = itemId
                ClassObject.tagId = tagId
                ClassObject.response: requests.Response = None


        class TagDetails:
            def __init__(ClassObject, tagId: str = None, name: str = None, localizedDisplayName: str = None, status: enum.Enum = None):
                ClassObject.tagId = tagId
                ClassObject.name = name
                ClassObject.localizedDisplayName = localizedDisplayName
                ClassObject.status = status
                ClassObject.response: requests.Response = None


        class ItemTagDetails:
            def __init__(ClassObject, id: str = None, tag: "RobloxClient.ItemConfiguration.TagDetails" = None):
                ClassObject.id = id
                ClassObject.tag = tag
                ClassObject.response: requests.Response = None


        class ItemTagsMetadataResponse:
            def __init__(ClassObject, isItemTagsFeatureEnabled: bool = None, enabledAssetTypes: list[str] = None, maximumItemTagsPerItem: int = None):
                ClassObject.isItemTagsFeatureEnabled = isItemTagsFeatureEnabled
                ClassObject.enabledAssetTypes = enabledAssetTypes
                ClassObject.maximumItemTagsPerItem = maximumItemTagsPerItem
                ClassObject.response: requests.Response = None


        class ItemWithTags:
            def __init__(ClassObject, id: str = None, itemTags: list["RobloxClient.ItemConfiguration.ItemTagDetails"] = None):
                ClassObject.id = id
                ClassObject.itemTags = itemTags
                ClassObject.response: requests.Response = None


        class StartIndexCursor:
            def __init__(ClassObject, startIndex: int = None, discriminator: str = None, count: int = None):
                ClassObject.startIndex = startIndex
                ClassObject.discriminator = discriminator
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class ItemWithTagsExtra:
            def __init__(ClassObject, data: list["RobloxClient.ItemConfiguration.ItemWithTags"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class TagDetailsExtra:
            def __init__(ClassObject, data: list["RobloxClient.ItemConfiguration.TagDetails"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class AssetCreationsResponseExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.ItemConfiguration.AssetCreationsResponse"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetCreationsGetAssets(self, assetType: str, isArchived: bool, groupId: int, limit: int, cursor: str) -> AssetCreationsResponseExtra:
            """
            Gets the user created asset information filtered by the given asset type
            
            Usage:
                import ItemConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ItemConfigurationApi = ItemConfiguration.ItemConfigurationApi(RobloxClient=RobloxClient)
                Response = ItemConfigurationApi.GetCreationsGetAssets(assetType=string, isArchived=boolean, groupId=integer, limit=integer, cursor=string)
        
            Args:
                assetType: str
            isArchived: bool
            groupId: int
            limit: int
            cursor: str
            Returns:
                ItemConfiguration.AssetCreationsResponseExtra: ItemConfiguration.AssetCreationsResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"assetType": assetType, "isArchived": isArchived, "groupId": groupId, "limit": limit, "cursor": cursor},"headers": {},"cookies": {}}
            
            GetCreationsGetAssetsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ItemConfiguration.roblox.com/v1/creations/get-assets", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ItemConfiguration.AssetCreationsResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetCreationsGetAssetsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetCreationsGetAssetsRecivedData)
            
            return ResponseSchema
        
        def GetItemTags(self, itemIds: list) -> ItemWithTagsExtra:
            """
            Gets all related item tags for each item id listed
            
            Usage:
                import ItemConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ItemConfigurationApi = ItemConfiguration.ItemConfigurationApi(RobloxClient=RobloxClient)
                Response = ItemConfigurationApi.GetItemTags(itemIds=array)
        
            Args:
                itemIds: list
            Returns:
                ItemConfiguration.ItemWithTagsExtra: ItemConfiguration.ItemWithTagsExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"itemIds": itemIds},"headers": {},"cookies": {}}
            
            GetItemTagsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ItemConfiguration.roblox.com/v1/item-tags", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ItemConfiguration.ItemWithTagsExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetItemTagsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetItemTagsRecivedData)
            
            return ResponseSchema
        
        def PostItemTags(self, CreateItemTagRequest: CreateItemTagRequest) -> ItemTagDetails:
            """
            Creates a new item tag
            
            Usage:
                import ItemConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ItemConfigurationApi = ItemConfiguration.ItemConfigurationApi(RobloxClient=RobloxClient)
                Response = ItemConfigurationApi.PostItemTags(CreateItemTagRequest=ItemConfiguration.CreateItemTagRequest())
        
            Args:
                CreateItemTagRequest: CreateItemTagRequest
            Returns:
                ItemConfiguration.ItemTagDetails: ItemConfiguration.ItemTagDetails
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'CreateItemTagRequest': 'json'}
            Arguments = inspect.signature(self.PostItemTags)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostItemTagsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://ItemConfiguration.roblox.com/v1/item-tags", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ItemConfiguration.ItemTagDetails()
        
            ReturnedJson = None
            try: ReturnedJson = PostItemTagsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostItemTagsRecivedData)
            
            return ResponseSchema
        
        def GetItemTagsMetadata(self) -> ItemTagsMetadataResponse:
            """
            Gets the metadata related to item tags
            
            Usage:
                import ItemConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ItemConfigurationApi = ItemConfiguration.ItemConfigurationApi(RobloxClient=RobloxClient)
                Response = ItemConfigurationApi.GetItemTagsMetadata()
        
            Args:
                
            Returns:
                ItemConfiguration.ItemTagsMetadataResponse: ItemConfiguration.ItemTagsMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetItemTagsMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ItemConfiguration.roblox.com/v1/item-tags/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ItemConfiguration.ItemTagsMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetItemTagsMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetItemTagsMetadataRecivedData)
            
            return ResponseSchema
        
        def GetTags(self, tagIds: list) -> TagDetailsExtra:
            """
            Gets the information for a list of tag Ids
            
            Usage:
                import ItemConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ItemConfigurationApi = ItemConfiguration.ItemConfigurationApi(RobloxClient=RobloxClient)
                Response = ItemConfigurationApi.GetTags(tagIds=array)
        
            Args:
                tagIds: list
            Returns:
                ItemConfiguration.TagDetailsExtra: ItemConfiguration.TagDetailsExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"tagIds": tagIds},"headers": {},"cookies": {}}
            
            GetTagsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ItemConfiguration.roblox.com/v1/tags", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ItemConfiguration.TagDetailsExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetTagsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetTagsRecivedData)
            
            return ResponseSchema
        
        def GetTagsPrefixSearch(self, prefix: str, numberOfResults: int) -> TagDetailsExtra:
            """
            Searches for up to numberOfResults tags based on the given prefix
            
            Usage:
                import ItemConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ItemConfigurationApi = ItemConfiguration.ItemConfigurationApi(RobloxClient=RobloxClient)
                Response = ItemConfigurationApi.GetTagsPrefixSearch(prefix=string, numberOfResults=integer)
        
            Args:
                prefix: str
            numberOfResults: int
            Returns:
                ItemConfiguration.TagDetailsExtra: ItemConfiguration.TagDetailsExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"prefix": prefix, "numberOfResults": numberOfResults},"headers": {},"cookies": {}}
            
            GetTagsPrefixSearchRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ItemConfiguration.roblox.com/v1/tags/prefix-search", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ItemConfiguration.TagDetailsExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetTagsPrefixSearchRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetTagsPrefixSearchRecivedData)
            
            return ResponseSchema
        
        def PostCreationsGetAssetDetails(self, AssetCreationsDetailsRequest: AssetCreationsDetailsRequest) -> requests.Response:
            """
            Gets the asset status and other configuration details for the given assetIds list
            
            Usage:
                import ItemConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ItemConfigurationApi = ItemConfiguration.ItemConfigurationApi(RobloxClient=RobloxClient)
                Response = ItemConfigurationApi.PostCreationsGetAssetDetails(AssetCreationsDetailsRequest=ItemConfiguration.AssetCreationsDetailsRequest())
        
            Args:
                AssetCreationsDetailsRequest: AssetCreationsDetailsRequest
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'AssetCreationsDetailsRequest': 'json'}
            Arguments = inspect.signature(self.PostCreationsGetAssetDetails)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostCreationsGetAssetDetailsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://ItemConfiguration.roblox.com/v1/creations/get-asset-details", Dictinary=Dictinary)
            return PostCreationsGetAssetDetailsRecivedData
        
        def DeleteItemTagsItemtagid(self, itemTagId: str) -> ApiEmptyResponseModel:
            """
            Deletes an item tag from an item
            
            Usage:
                import ItemConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ItemConfigurationApi = ItemConfiguration.ItemConfigurationApi(RobloxClient=RobloxClient)
                Response = ItemConfigurationApi.DeleteItemTagsItemtagid(itemTagId=string)
        
            Args:
                itemTagId: str
            Returns:
                ItemConfiguration.ApiEmptyResponseModel: ItemConfiguration.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteItemTagsItemtagidRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://ItemConfiguration.roblox.com/v1/item-tags/{itemTagId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ItemConfiguration.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteItemTagsItemtagidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteItemTagsItemtagidRecivedData)
            
            return ResponseSchema
        
    class Inventory:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class AssetsExplorerCategoryItemModel:
            def __init__(ClassObject, name: str = None, displayName: str = None, filter: str = None, id: int = None, type: enum.Enum = None, categoryType: str = None):
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.filter = filter
                ClassObject.id = id
                ClassObject.type = type
                ClassObject.categoryType = categoryType
                ClassObject.response: requests.Response = None


        class AssetsExplorerCategoryModel:
            def __init__(ClassObject, name: str = None, displayName: str = None, categoryType: str = None, items: list["RobloxClient.Inventory.AssetsExplorerCategoryItemModel"] = None):
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.categoryType = categoryType
                ClassObject.items = items
                ClassObject.response: requests.Response = None


        class CategoriesModel:
            def __init__(ClassObject, categories: list["RobloxClient.Inventory.AssetsExplorerCategoryModel"] = None):
                ClassObject.categories = categories
                ClassObject.response: requests.Response = None


        class AssetIdListModel:
            def __init__(ClassObject, assetIds: list[int] = None):
                ClassObject.assetIds = assetIds
                ClassObject.response: requests.Response = None


        class CanViewInventoryResponse:
            def __init__(ClassObject, canView: bool = None):
                ClassObject.canView = canView
                ClassObject.response: requests.Response = None


        class CollectibleUserAssetModel:
            def __init__(ClassObject, userAssetId: int = None, serialNumber: int = None, assetId: int = None, name: str = None, recentAveragePrice: int = None, originalPrice: int = None, assetStock: int = None, buildersClubMembershipType: enum.Enum = None, isOnHold: bool = None):
                ClassObject.userAssetId = userAssetId
                ClassObject.serialNumber = serialNumber
                ClassObject.assetId = assetId
                ClassObject.name = name
                ClassObject.recentAveragePrice = recentAveragePrice
                ClassObject.originalPrice = originalPrice
                ClassObject.assetStock = assetStock
                ClassObject.buildersClubMembershipType = buildersClubMembershipType
                ClassObject.isOnHold = isOnHold
                ClassObject.response: requests.Response = None


        class IItemModel:
            def __init__(ClassObject, Id: int = None, Name: str = None, Type: enum.Enum = None, InstanceId: int = None):
                ClassObject.Id = Id
                ClassObject.Name = Name
                ClassObject.Type = Type
                ClassObject.InstanceId = InstanceId
                ClassObject.response: requests.Response = None


        class InventoryPageResponse:
            def __init__(ClassObject, data: list[any] = None, total: int = None, includesAccessories: bool = None):
                ClassObject.data = data
                ClassObject.total = total
                ClassObject.includesAccessories = includesAccessories
                ClassObject.response: requests.Response = None


        class Int64Extra:
            def __init__(ClassObject, SortOrder: enum.Enum = None, PagingDirection: enum.Enum = None, Count: int = None):
                ClassObject.SortOrder = SortOrder
                ClassObject.PagingDirection = PagingDirection
                ClassObject.Count = Count
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class CollectibleUserAssetModelExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Inventory.CollectibleUserAssetModel"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class IItemModelExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Inventory.IItemModel"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetPackagesPackageidAssets(self, packageID: int) -> AssetIdListModel:
            """
            Given a package ID, returns the list of asset IDs for that package
            
            Usage:
                import Inventory
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                InventoryApi = Inventory.InventoryApi(RobloxClient=RobloxClient)
                Response = InventoryApi.GetPackagesPackageidAssets(packageID=integer)
        
            Args:
                packageID: int
            Returns:
                Inventory.AssetIdListModel: Inventory.AssetIdListModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetPackagesPackageidAssetsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Inventory.roblox.com/v1/packages/{packageId}/assets", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Inventory.AssetIdListModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetPackagesPackageidAssetsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPackagesPackageidAssetsRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridAssetsCollectibles(self, assetType: int, limit: int, cursor: str, sortOrder: str, userId: int) -> CollectibleUserAssetModelExtra:
            """
            Gets all collectible assets owned by the specified user.
            
            Usage:
                import Inventory
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                InventoryApi = Inventory.InventoryApi(RobloxClient=RobloxClient)
                Response = InventoryApi.GetUsersUseridAssetsCollectibles(assetType=integer, limit=integer, cursor=string, sortOrder=string, userId=integer)
        
            Args:
                assetType: int
            limit: int
            cursor: str
            sortOrder: str
            userId: int
            Returns:
                Inventory.CollectibleUserAssetModelExtra: Inventory.CollectibleUserAssetModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"assetType": assetType, "limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetUsersUseridAssetsCollectiblesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Inventory.roblox.com/v1/users/{userId}/assets/collectibles", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Inventory.CollectibleUserAssetModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridAssetsCollectiblesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridAssetsCollectiblesRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridCanViewInventory(self, userId: int) -> CanViewInventoryResponse:
            """
            Gets whether the specified user's inventory can be viewed.
            
            Usage:
                import Inventory
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                InventoryApi = Inventory.InventoryApi(RobloxClient=RobloxClient)
                Response = InventoryApi.GetUsersUseridCanViewInventory(userId=integer)
        
            Args:
                userId: int
            Returns:
                Inventory.CanViewInventoryResponse: Inventory.CanViewInventoryResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridCanViewInventoryRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Inventory.roblox.com/v1/users/{userId}/can-view-inventory", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Inventory.CanViewInventoryResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridCanViewInventoryRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridCanViewInventoryRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridCategories(self, userId: int) -> CategoriesModel:
            """
            Return inventory categories for a user
            
            Usage:
                import Inventory
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                InventoryApi = Inventory.InventoryApi(RobloxClient=RobloxClient)
                Response = InventoryApi.GetUsersUseridCategories(userId=integer)
        
            Args:
                userId: int
            Returns:
                Inventory.CategoriesModel: Inventory.CategoriesModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridCategoriesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Inventory.roblox.com/v1/users/{userId}/categories", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Inventory.CategoriesModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridCategoriesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridCategoriesRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridCategoriesFavorites(self, userId: int) -> CategoriesModel:
            """
            Return favorites categories for a user
            
            Usage:
                import Inventory
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                InventoryApi = Inventory.InventoryApi(RobloxClient=RobloxClient)
                Response = InventoryApi.GetUsersUseridCategoriesFavorites(userId=integer)
        
            Args:
                userId: int
            Returns:
                Inventory.CategoriesModel: Inventory.CategoriesModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridCategoriesFavoritesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Inventory.roblox.com/v1/users/{userId}/categories/favorites", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Inventory.CategoriesModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridCategoriesFavoritesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridCategoriesFavoritesRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridInventoryAssettype(self, pageNumber: int, itemsPerPage: int, keyword: str, userId: int, assetType: int) -> InventoryPageResponse:
            """
            Gets a list of assets by type for the specified user.

Note that the 'Hat' asset type may return accessories while we are migrating.
            
            Usage:
                import Inventory
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                InventoryApi = Inventory.InventoryApi(RobloxClient=RobloxClient)
                Response = InventoryApi.GetUsersUseridInventoryAssettype(pageNumber=integer, itemsPerPage=integer, keyword=string, userId=integer, assetType=integer)
        
            Args:
                pageNumber: int
            itemsPerPage: int
            keyword: str
            userId: int
            assetType: int
            Returns:
                Inventory.InventoryPageResponse: Inventory.InventoryPageResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"pageNumber": pageNumber, "itemsPerPage": itemsPerPage, "keyword": keyword},"headers": {},"cookies": {}}
            
            GetUsersUseridInventoryAssettypeRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Inventory.roblox.com/v1/users/{userId}/inventory/{assetType}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Inventory.InventoryPageResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridInventoryAssettypeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridInventoryAssettypeRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridItemsItemtypeItemtargetid(self, userId: int, itemType: int, itemTargetId: int) -> IItemModelExtra:
            """
            Gets owned items of the specified item type. Game Servers can make requests for any user, but can only make requests for game passes that belong to the place sending the request.

Place creators can make requests as if they were the Game Server.
            
            Usage:
                import Inventory
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                InventoryApi = Inventory.InventoryApi(RobloxClient=RobloxClient)
                Response = InventoryApi.GetUsersUseridItemsItemtypeItemtargetid(userId=integer, itemType=integer, itemTargetId=integer)
        
            Args:
                userId: int
            itemType: int
            itemTargetId: int
            Returns:
                Inventory.IItemModelExtra: Inventory.IItemModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridItemsItemtypeItemtargetidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Inventory.roblox.com/v1/users/{userId}/items/{itemType}/{itemTargetId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Inventory.IItemModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridItemsItemtypeItemtargetidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridItemsItemtypeItemtargetidRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridItemsItemtypeItemtargetidIsOwned(self, userId: int, itemType: int, itemTargetId: int) -> requests.Response:
            """
            Gets whether a user owns an item of type itemType with id itemTargetId.
            
            Usage:
                import Inventory
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                InventoryApi = Inventory.InventoryApi(RobloxClient=RobloxClient)
                Response = InventoryApi.GetUsersUseridItemsItemtypeItemtargetidIsOwned(userId=integer, itemType=integer, itemTargetId=integer)
        
            Args:
                userId: int
            itemType: int
            itemTargetId: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridItemsItemtypeItemtargetidIsOwnedRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Inventory.roblox.com/v1/users/{userId}/items/{itemType}/{itemTargetId}/is-owned", Dictinary=Dictinary)
            return GetUsersUseridItemsItemtypeItemtargetidIsOwnedRecivedData
        
        def DeleteCollectionsItemsItemtypeItemtargetid(self, itemType: int, itemTargetId: int) -> ApiEmptyResponseModel:
            """
            Removes an item to the appropriate collection
            
            Usage:
                import Inventory
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                InventoryApi = Inventory.InventoryApi(RobloxClient=RobloxClient)
                Response = InventoryApi.DeleteCollectionsItemsItemtypeItemtargetid(itemType=integer, itemTargetId=integer)
        
            Args:
                itemType: int
            itemTargetId: int
            Returns:
                Inventory.ApiEmptyResponseModel: Inventory.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteCollectionsItemsItemtypeItemtargetidRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Inventory.roblox.com/v1/collections/items/{itemType}/{itemTargetId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Inventory.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteCollectionsItemsItemtypeItemtargetidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteCollectionsItemsItemtypeItemtargetidRecivedData)
            
            return ResponseSchema
        
        def PostCollectionsItemsItemtypeItemtargetid(self, itemType: int, itemTargetId: int) -> ApiEmptyResponseModel:
            """
            Adds an item to the appropriate collection
            
            Usage:
                import Inventory
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                InventoryApi = Inventory.InventoryApi(RobloxClient=RobloxClient)
                Response = InventoryApi.PostCollectionsItemsItemtypeItemtargetid(itemType=integer, itemTargetId=integer)
        
            Args:
                itemType: int
            itemTargetId: int
            Returns:
                Inventory.ApiEmptyResponseModel: Inventory.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostCollectionsItemsItemtypeItemtargetidRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Inventory.roblox.com/v1/collections/items/{itemType}/{itemTargetId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Inventory.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostCollectionsItemsItemtypeItemtargetidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostCollectionsItemsItemtypeItemtargetidRecivedData)
            
            return ResponseSchema
        
    class Groups:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class ChangeOwnerRequest:
            def __init__(ClassObject, userId: int = None):
                ClassObject.userId = userId
                ClassObject.response: requests.Response = None


        class CreateWallPostRequest:
            def __init__(ClassObject, body: str = None, captchaId: str = None, captchaToken: str = None, captchaProvider: str = None, challengeId: str = None):
                ClassObject.body = body
                ClassObject.captchaId = captchaId
                ClassObject.captchaToken = captchaToken
                ClassObject.captchaProvider = captchaProvider
                ClassObject.challengeId = challengeId
                ClassObject.response: requests.Response = None


        class GroupRoleResponse:
            def __init__(ClassObject, id: int = None, name: str = None, description: str = None, rank: int = None, memberCount: int = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.rank = rank
                ClassObject.memberCount = memberCount
                ClassObject.response: requests.Response = None


        class GroupAllRolesResponse:
            def __init__(ClassObject, groupId: int = None, roles: list["RobloxClient.Groups.GroupRoleResponse"] = None):
                ClassObject.groupId = groupId
                ClassObject.roles = roles
                ClassObject.response: requests.Response = None


        class UserModel:
            def __init__(ClassObject, buildersClubMembershipType: enum.Enum = None, hasVerifiedBadge: bool = None, userId: int = None, username: str = None, displayName: str = None):
                ClassObject.buildersClubMembershipType = buildersClubMembershipType
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.userId = userId
                ClassObject.username = username
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class UserGroupRoleResponse:
            def __init__(ClassObject, user: "RobloxClient.Groups.UserModel" = None, role: "RobloxClient.Groups.GroupRoleResponse" = None):
                ClassObject.user = user
                ClassObject.role = role
                ClassObject.response: requests.Response = None


        class GroupAuditLogResponseItem:
            def __init__(ClassObject, actor: "RobloxClient.Groups.UserGroupRoleResponse" = None, actionType: str = None, description: dict = None, created: str = None):
                ClassObject.actor = actor
                ClassObject.actionType = actionType
                ClassObject.description = description
                ClassObject.created = created
                ClassObject.response: requests.Response = None


        class GroupAuditLogResponseItemExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Groups.GroupAuditLogResponseItem"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GroupConfigurationResponse:
            def __init__(ClassObject, nameMaxLength: int = None, descriptionMaxLength: int = None, iconMaxFileSizeMb: int = None, cost: int = None, isUsingTwoStepWebviewComponent: bool = None):
                ClassObject.nameMaxLength = nameMaxLength
                ClassObject.descriptionMaxLength = descriptionMaxLength
                ClassObject.iconMaxFileSizeMb = iconMaxFileSizeMb
                ClassObject.cost = cost
                ClassObject.isUsingTwoStepWebviewComponent = isUsingTwoStepWebviewComponent
                ClassObject.response: requests.Response = None


        class RecurringPayoutsConfigurationResponse:
            def __init__(ClassObject, maxPayoutPartners: int = None):
                ClassObject.maxPayoutPartners = maxPayoutPartners
                ClassObject.response: requests.Response = None


        class RoleConfigurationResponse:
            def __init__(ClassObject, nameMaxLength: int = None, descriptionMaxLength: int = None, limit: int = None, cost: int = None, minRank: int = None, maxRank: int = None):
                ClassObject.nameMaxLength = nameMaxLength
                ClassObject.descriptionMaxLength = descriptionMaxLength
                ClassObject.limit = limit
                ClassObject.cost = cost
                ClassObject.minRank = minRank
                ClassObject.maxRank = maxRank
                ClassObject.response: requests.Response = None


        class GroupNameChangeConfigurationResponse:
            def __init__(ClassObject, cost: int = None, cooldownInDays: int = None, ownershipCooldownInDays: int = None):
                ClassObject.cost = cost
                ClassObject.cooldownInDays = cooldownInDays
                ClassObject.ownershipCooldownInDays = ownershipCooldownInDays
                ClassObject.response: requests.Response = None


        class GroupConfigurationDisplayOptionsResponse:
            def __init__(ClassObject, groupConfiguration: "RobloxClient.Groups.GroupConfigurationResponse" = None, recurringPayoutsConfiguration: "RobloxClient.Groups.RecurringPayoutsConfigurationResponse" = None, roleConfiguration: "RobloxClient.Groups.RoleConfigurationResponse" = None, groupNameChangeConfiguration: "RobloxClient.Groups.GroupNameChangeConfigurationResponse" = None, isPremiumPayoutsEnabled: bool = None, isDefaultEmblemPolicyEnabled: bool = None):
                ClassObject.groupConfiguration = groupConfiguration
                ClassObject.recurringPayoutsConfiguration = recurringPayoutsConfiguration
                ClassObject.roleConfiguration = roleConfiguration
                ClassObject.groupNameChangeConfiguration = groupNameChangeConfiguration
                ClassObject.isPremiumPayoutsEnabled = isPremiumPayoutsEnabled
                ClassObject.isDefaultEmblemPolicyEnabled = isDefaultEmblemPolicyEnabled
                ClassObject.response: requests.Response = None


        class GroupDescriptionResponse:
            def __init__(ClassObject, newDescription: str = None):
                ClassObject.newDescription = newDescription
                ClassObject.response: requests.Response = None


        class ShoutResponse:
            def __init__(ClassObject, body: str = None, poster: "RobloxClient.Groups.UserModel" = None, created: str = None, updated: str = None):
                ClassObject.body = body
                ClassObject.poster = poster
                ClassObject.created = created
                ClassObject.updated = updated
                ClassObject.response: requests.Response = None


        class GroupDetailResponse:
            def __init__(ClassObject, id: int = None, name: str = None, description: str = None, owner: "RobloxClient.Groups.UserModel" = None, shout: "RobloxClient.Groups.ShoutResponse" = None, memberCount: int = None, isBuildersClubOnly: bool = None, publicEntryAllowed: bool = None, isLocked: bool = None, hasVerifiedBadge: bool = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.owner = owner
                ClassObject.shout = shout
                ClassObject.memberCount = memberCount
                ClassObject.isBuildersClubOnly = isBuildersClubOnly
                ClassObject.publicEntryAllowed = publicEntryAllowed
                ClassObject.isLocked = isLocked
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.response: requests.Response = None


        class GroupEconomyPermissionsModel:
            def __init__(ClassObject, spendGroupFunds: bool = None, advertiseGroup: bool = None, createItems: bool = None, manageItems: bool = None, addGroupPlaces: bool = None, manageGroupGames: bool = None, viewGroupPayouts: bool = None, viewAnalytics: bool = None):
                ClassObject.spendGroupFunds = spendGroupFunds
                ClassObject.advertiseGroup = advertiseGroup
                ClassObject.createItems = createItems
                ClassObject.manageItems = manageItems
                ClassObject.addGroupPlaces = addGroupPlaces
                ClassObject.manageGroupGames = manageGroupGames
                ClassObject.viewGroupPayouts = viewGroupPayouts
                ClassObject.viewAnalytics = viewAnalytics
                ClassObject.response: requests.Response = None


        class GroupJoinRequestResponse:
            def __init__(ClassObject, requester: "RobloxClient.Groups.UserModel" = None, created: str = None):
                ClassObject.requester = requester
                ClassObject.created = created
                ClassObject.response: requests.Response = None


        class GroupManagementPermissionsModel:
            def __init__(ClassObject, manageRelationships: bool = None, manageClan: bool = None, viewAuditLogs: bool = None):
                ClassObject.manageRelationships = manageRelationships
                ClassObject.manageClan = manageClan
                ClassObject.viewAuditLogs = viewAuditLogs
                ClassObject.response: requests.Response = None


        class GroupMembershipDetailResponse:
            def __init__(ClassObject, group: "RobloxClient.Groups.GroupDetailResponse" = None, role: "RobloxClient.Groups.GroupRoleResponse" = None, isPrimaryGroup: bool = None, isNotificationsEnabled: bool = None):
                ClassObject.group = group
                ClassObject.role = role
                ClassObject.isPrimaryGroup = isPrimaryGroup
                ClassObject.isNotificationsEnabled = isNotificationsEnabled
                ClassObject.response: requests.Response = None


        class GroupPostsPermissionsModel:
            def __init__(ClassObject, viewWall: bool = None, postToWall: bool = None, deleteFromWall: bool = None, viewStatus: bool = None, postToStatus: bool = None):
                ClassObject.viewWall = viewWall
                ClassObject.postToWall = postToWall
                ClassObject.deleteFromWall = deleteFromWall
                ClassObject.viewStatus = viewStatus
                ClassObject.postToStatus = postToStatus
                ClassObject.response: requests.Response = None


        class GroupMembershipPermissionsModel:
            def __init__(ClassObject, changeRank: bool = None, inviteMembers: bool = None, removeMembers: bool = None, banMembers: bool = None):
                ClassObject.changeRank = changeRank
                ClassObject.inviteMembers = inviteMembers
                ClassObject.removeMembers = removeMembers
                ClassObject.banMembers = banMembers
                ClassObject.response: requests.Response = None


        class GroupOpenCloudPermissionsModel:
            def __init__(ClassObject, useCloudAuthentication: bool = None, administerCloudAuthentication: bool = None):
                ClassObject.useCloudAuthentication = useCloudAuthentication
                ClassObject.administerCloudAuthentication = administerCloudAuthentication
                ClassObject.response: requests.Response = None


        class GroupPermissionsModel:
            def __init__(ClassObject, groupPostsPermissions: "RobloxClient.Groups.GroupPostsPermissionsModel" = None, groupMembershipPermissions: "RobloxClient.Groups.GroupMembershipPermissionsModel" = None, groupManagementPermissions: "RobloxClient.Groups.GroupManagementPermissionsModel" = None, groupEconomyPermissions: "RobloxClient.Groups.GroupEconomyPermissionsModel" = None, groupOpenCloudPermissions: "RobloxClient.Groups.GroupOpenCloudPermissionsModel" = None):
                ClassObject.groupPostsPermissions = groupPostsPermissions
                ClassObject.groupMembershipPermissions = groupMembershipPermissions
                ClassObject.groupManagementPermissions = groupManagementPermissions
                ClassObject.groupEconomyPermissions = groupEconomyPermissions
                ClassObject.groupOpenCloudPermissions = groupOpenCloudPermissions
                ClassObject.response: requests.Response = None


        class GroupMembershipMetadataResponse:
            def __init__(ClassObject, groupId: int = None, isPrimary: bool = None, isPendingJoin: bool = None, userRole: "RobloxClient.Groups.UserGroupRoleResponse" = None, permissions: "RobloxClient.Groups.GroupPermissionsModel" = None, areGroupGamesVisible: bool = None, areGroupFundsVisible: bool = None, areEnemiesAllowed: bool = None, canConfigure: bool = None, isNotificationsEnabled: bool = None, isBannedFromGroup: bool = None):
                ClassObject.groupId = groupId
                ClassObject.isPrimary = isPrimary
                ClassObject.isPendingJoin = isPendingJoin
                ClassObject.userRole = userRole
                ClassObject.permissions = permissions
                ClassObject.areGroupGamesVisible = areGroupGamesVisible
                ClassObject.areGroupFundsVisible = areGroupFundsVisible
                ClassObject.areEnemiesAllowed = areEnemiesAllowed
                ClassObject.canConfigure = canConfigure
                ClassObject.isNotificationsEnabled = isNotificationsEnabled
                ClassObject.isBannedFromGroup = isBannedFromGroup
                ClassObject.response: requests.Response = None


        class GroupPayoutResponse:
            def __init__(ClassObject, user: "RobloxClient.Groups.UserModel" = None, percentage: int = None):
                ClassObject.user = user
                ClassObject.percentage = percentage
                ClassObject.response: requests.Response = None


        class GroupPayoutRestrictionResponse:
            def __init__(ClassObject, canUseRecurringPayout: bool = None, canUseOneTimePayout: bool = None):
                ClassObject.canUseRecurringPayout = canUseRecurringPayout
                ClassObject.canUseOneTimePayout = canUseOneTimePayout
                ClassObject.response: requests.Response = None


        class GroupPermissionsResponse:
            def __init__(ClassObject, groupId: int = None, role: "RobloxClient.Groups.GroupRoleResponse" = None, permissions: "RobloxClient.Groups.GroupPermissionsModel" = None):
                ClassObject.groupId = groupId
                ClassObject.role = role
                ClassObject.permissions = permissions
                ClassObject.response: requests.Response = None


        class GroupPolicyResponse:
            def __init__(ClassObject, canViewGroup: bool = None, groupId: int = None):
                ClassObject.canViewGroup = canViewGroup
                ClassObject.groupId = groupId
                ClassObject.response: requests.Response = None


        class GroupPoliciesResponse:
            def __init__(ClassObject, groups: list["RobloxClient.Groups.GroupPolicyResponse"] = None):
                ClassObject.groups = groups
                ClassObject.response: requests.Response = None


        class GroupPolicyRequest:
            def __init__(ClassObject, groupIds: list[int] = None):
                ClassObject.groupIds = groupIds
                ClassObject.response: requests.Response = None


        class GroupRelationshipsResponse:
            def __init__(ClassObject, groupId: int = None, relationshipType: enum.Enum = None, totalGroupCount: int = None, relatedGroups: list["RobloxClient.Groups.GroupDetailResponse"] = None, nextRowIndex: int = None):
                ClassObject.groupId = groupId
                ClassObject.relationshipType = relationshipType
                ClassObject.totalGroupCount = totalGroupCount
                ClassObject.relatedGroups = relatedGroups
                ClassObject.nextRowIndex = nextRowIndex
                ClassObject.response: requests.Response = None


        class GroupRoleDetailResponse:
            def __init__(ClassObject, groupId: int = None, id: int = None, name: str = None, description: str = None, rank: int = None, memberCount: int = None):
                ClassObject.groupId = groupId
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.rank = rank
                ClassObject.memberCount = memberCount
                ClassObject.response: requests.Response = None


        class GroupSearchMetadataResponse:
            def __init__(ClassObject, SuggestedGroupKeywords: list[str] = None, ShowFriendsGroupsSort: bool = None):
                ClassObject.SuggestedGroupKeywords = SuggestedGroupKeywords
                ClassObject.ShowFriendsGroupsSort = ShowFriendsGroupsSort
                ClassObject.response: requests.Response = None


        class GroupSearchResponseItem:
            def __init__(ClassObject, id: int = None, name: str = None, description: str = None, memberCount: int = None, previousName: str = None, publicEntryAllowed: bool = None, created: str = None, updated: str = None, hasVerifiedBadge: bool = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.memberCount = memberCount
                ClassObject.previousName = previousName
                ClassObject.publicEntryAllowed = publicEntryAllowed
                ClassObject.created = created
                ClassObject.updated = updated
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.response: requests.Response = None


        class GroupSearchPageResponse:
            def __init__(ClassObject, keyword: str = None, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Groups.GroupSearchResponseItem"] = None):
                ClassObject.keyword = keyword
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GroupSettingsResponse:
            def __init__(ClassObject, isApprovalRequired: bool = None, isBuildersClubRequired: bool = None, areEnemiesAllowed: bool = None, areGroupFundsVisible: bool = None, areGroupGamesVisible: bool = None, isGroupNameChangeEnabled: bool = None):
                ClassObject.isApprovalRequired = isApprovalRequired
                ClassObject.isBuildersClubRequired = isBuildersClubRequired
                ClassObject.areEnemiesAllowed = areEnemiesAllowed
                ClassObject.areGroupFundsVisible = areGroupFundsVisible
                ClassObject.areGroupGamesVisible = areGroupGamesVisible
                ClassObject.isGroupNameChangeEnabled = isGroupNameChangeEnabled
                ClassObject.response: requests.Response = None


        class GroupsDisplayOptionsResponse:
            def __init__(ClassObject, groupLimit: int = None, currentGroupCount: int = None, groupStatusMaxLength: int = None, groupPostMaxLength: int = None, isGroupWallNotificationsEnabled: bool = None, groupWallNotificationsSubscribeIntervalInMilliseconds: int = None, areProfileGroupsHidden: bool = None, isGroupDetailsPolicyEnabled: bool = None, showPreviousGroupNames: bool = None, areGroupBansEnabled: bool = None):
                ClassObject.groupLimit = groupLimit
                ClassObject.currentGroupCount = currentGroupCount
                ClassObject.groupStatusMaxLength = groupStatusMaxLength
                ClassObject.groupPostMaxLength = groupPostMaxLength
                ClassObject.isGroupWallNotificationsEnabled = isGroupWallNotificationsEnabled
                ClassObject.groupWallNotificationsSubscribeIntervalInMilliseconds = groupWallNotificationsSubscribeIntervalInMilliseconds
                ClassObject.areProfileGroupsHidden = areProfileGroupsHidden
                ClassObject.isGroupDetailsPolicyEnabled = isGroupDetailsPolicyEnabled
                ClassObject.showPreviousGroupNames = showPreviousGroupNames
                ClassObject.areGroupBansEnabled = areGroupBansEnabled
                ClassObject.response: requests.Response = None


        class JoinGroupRequest:
            def __init__(ClassObject, sessionId: str = None, redemptionToken: str = None, captchaId: str = None, captchaToken: str = None, captchaProvider: str = None, challengeId: str = None):
                ClassObject.sessionId = sessionId
                ClassObject.redemptionToken = redemptionToken
                ClassObject.captchaId = captchaId
                ClassObject.captchaToken = captchaToken
                ClassObject.captchaProvider = captchaProvider
                ClassObject.challengeId = challengeId
                ClassObject.response: requests.Response = None


        class MembersRequest:
            def __init__(ClassObject, UserIds: list[int] = None):
                ClassObject.UserIds = UserIds
                ClassObject.response: requests.Response = None


        class CreateRoleSetRequest:
            def __init__(ClassObject, name: str = None, description: str = None, rank: int = None, usingGroupFunds: bool = None):
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.rank = rank
                ClassObject.usingGroupFunds = usingGroupFunds
                ClassObject.response: requests.Response = None


        class UpdateRoleSetRequest:
            def __init__(ClassObject, name: str = None, description: str = None, rank: int = None):
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.rank = rank
                ClassObject.response: requests.Response = None


        class GroupNameHistoryResponseItem:
            def __init__(ClassObject, name: str = None, created: str = None):
                ClassObject.name = name
                ClassObject.created = created
                ClassObject.response: requests.Response = None


        class GroupWallPostModel:
            def __init__(ClassObject, id: int = None, poster: "RobloxClient.Groups.UserModel" = None, body: str = None, created: str = None, updated: str = None):
                ClassObject.id = id
                ClassObject.poster = poster
                ClassObject.body = body
                ClassObject.created = created
                ClassObject.updated = updated
                ClassObject.response: requests.Response = None


        class PayoutRecipientRequest:
            def __init__(ClassObject, recipientId: int = None, recipientType: enum.Enum = None, amount: int = None):
                ClassObject.recipientId = recipientId
                ClassObject.recipientType = recipientType
                ClassObject.amount = amount
                ClassObject.response: requests.Response = None


        class PayoutRequest:
            def __init__(ClassObject, PayoutType: enum.Enum = None, Recipients: list["RobloxClient.Groups.PayoutRecipientRequest"] = None):
                ClassObject.PayoutType = PayoutType
                ClassObject.Recipients = Recipients
                ClassObject.response: requests.Response = None


        class PostGroupStatusRequest:
            def __init__(ClassObject, message: str = None):
                ClassObject.message = message
                ClassObject.response: requests.Response = None


        class PrimaryGroupRequest:
            def __init__(ClassObject, groupId: int = None):
                ClassObject.groupId = groupId
                ClassObject.response: requests.Response = None


        class RelationshipsRequest:
            def __init__(ClassObject, GroupIds: list[int] = None):
                ClassObject.GroupIds = GroupIds
                ClassObject.response: requests.Response = None


        class SocialLinkRequest:
            def __init__(ClassObject, type: enum.Enum = None, url: str = None, title: str = None):
                ClassObject.type = type
                ClassObject.url = url
                ClassObject.title = title
                ClassObject.response: requests.Response = None


        class SocialLinkResponse:
            def __init__(ClassObject, id: int = None, type: enum.Enum = None, url: str = None, title: str = None):
                ClassObject.id = id
                ClassObject.type = type
                ClassObject.url = url
                ClassObject.title = title
                ClassObject.response: requests.Response = None


        class UpdateGroupDescriptionRequest:
            def __init__(ClassObject, description: str = None):
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateGroupNameRequest:
            def __init__(ClassObject, name: str = None):
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class UpdateGroupNameResponse:
            def __init__(ClassObject, newName: str = None):
                ClassObject.newName = newName
                ClassObject.response: requests.Response = None


        class UpdateGroupNotificationPreferenceRequest:
            def __init__(ClassObject, notificationsEnabled: bool = None):
                ClassObject.notificationsEnabled = notificationsEnabled
                ClassObject.response: requests.Response = None


        class UpdateGroupSettingsRequest:
            def __init__(ClassObject, isApprovalRequired: bool = None, areEnemiesAllowed: bool = None, areGroupFundsVisible: bool = None, areGroupGamesVisible: bool = None):
                ClassObject.isApprovalRequired = isApprovalRequired
                ClassObject.areEnemiesAllowed = areEnemiesAllowed
                ClassObject.areGroupFundsVisible = areGroupFundsVisible
                ClassObject.areGroupGamesVisible = areGroupGamesVisible
                ClassObject.response: requests.Response = None


        class UpdatePermissionsRequest:
            def __init__(ClassObject, permissions: dict = None):
                ClassObject.permissions = permissions
                ClassObject.response: requests.Response = None


        class UpdateUserRoleRequest:
            def __init__(ClassObject, roleId: int = None):
                ClassObject.roleId = roleId
                ClassObject.response: requests.Response = None


        class UserGroupMembershipResponse:
            def __init__(ClassObject, user: "RobloxClient.Groups.UserModel" = None, groups: list["RobloxClient.Groups.GroupMembershipDetailResponse"] = None):
                ClassObject.user = user
                ClassObject.groups = groups
                ClassObject.response: requests.Response = None


        class GroupFeaturedContentResponse:
            def __init__(ClassObject, groupId: int = None, contentType: str = None, contentId: str = None):
                ClassObject.groupId = groupId
                ClassObject.contentType = contentType
                ClassObject.contentId = contentId
                ClassObject.response: requests.Response = None


        class Int64Extra:
            def __init__(ClassObject, SortOrder: enum.Enum = None, PagingDirection: enum.Enum = None, Count: int = None):
                ClassObject.SortOrder = SortOrder
                ClassObject.PagingDirection = PagingDirection
                ClassObject.Count = Count
                ClassObject.response: requests.Response = None


        class StringExtra:
            def __init__(ClassObject, key: str = None, sortOrder: enum.Enum = None, pagingDirection: enum.Enum = None, pageNumber: int = None, discriminator: str = None, count: int = None):
                ClassObject.key = key
                ClassObject.sortOrder = sortOrder
                ClassObject.pagingDirection = pagingDirection
                ClassObject.pageNumber = pageNumber
                ClassObject.discriminator = discriminator
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class StartIndexCursor:
            def __init__(ClassObject, startIndex: int = None, discriminator: str = None, count: int = None):
                ClassObject.startIndex = startIndex
                ClassObject.discriminator = discriminator
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class Int32Extra:
            def __init__(ClassObject, SortOrder: enum.Enum = None, PagingDirection: enum.Enum = None, Count: int = None):
                ClassObject.SortOrder = SortOrder
                ClassObject.PagingDirection = PagingDirection
                ClassObject.Count = Count
                ClassObject.response: requests.Response = None


        class GroupBasicResponse:
            def __init__(ClassObject, id: int = None, name: str = None, memberCount: int = None, hasVerifiedBadge: bool = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.memberCount = memberCount
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.response: requests.Response = None


        class GroupOwnerTypeExtra:
            def __init__(ClassObject, id: int = None, type: enum.Enum = None, name: str = None):
                ClassObject.id = id
                ClassObject.type = type
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class GroupResponseV2:
            def __init__(ClassObject, id: int = None, name: str = None, description: str = None, owner: "RobloxClient.Groups.GroupOwnerTypeExtra" = None, memberCount: int = None, created: str = None, hasVerifiedBadge: bool = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.owner = owner
                ClassObject.memberCount = memberCount
                ClassObject.created = created
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class GroupDetailResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Groups.GroupDetailResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GroupMembershipDetailResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Groups.GroupMembershipDetailResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GroupPayoutResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Groups.GroupPayoutResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GroupPermissionsResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Groups.GroupPermissionsResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GroupRoleDetailResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Groups.GroupRoleDetailResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class SocialLinkResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Groups.SocialLinkResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class UserGroupMembershipResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Groups.UserGroupMembershipResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GroupBasicResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Groups.GroupBasicResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GroupJoinRequestResponseExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Groups.GroupJoinRequestResponse"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GroupNameHistoryResponseItemExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Groups.GroupNameHistoryResponseItem"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GroupWallPostModelExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Groups.GroupWallPostModel"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class UserModelExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Groups.UserModel"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class UserGroupRoleResponseExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Groups.UserGroupRoleResponse"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class Stream:
            def __init__(ClassObject, CanRead: bool = None, CanWrite: bool = None, CanSeek: bool = None, CanTimeout: bool = None, Length: int = None, Position: int = None, ReadTimeout: int = None, WriteTimeout: int = None):
                ClassObject.CanRead = CanRead
                ClassObject.CanWrite = CanWrite
                ClassObject.CanSeek = CanSeek
                ClassObject.CanTimeout = CanTimeout
                ClassObject.Length = Length
                ClassObject.Position = Position
                ClassObject.ReadTimeout = ReadTimeout
                ClassObject.WriteTimeout = WriteTimeout
                ClassObject.response: requests.Response = None


        class IUploadedFile:
            def __init__(ClassObject, Name: str = None, Stream: "RobloxClient.Groups.Stream" = None, ContentEncoding: enum.Enum = None):
                ClassObject.Name = Name
                ClassObject.Stream = Stream
                ClassObject.ContentEncoding = ContentEncoding
                ClassObject.response: requests.Response = None



        
        def DeleteFeaturedContentEvent(self, groupId: int, eventId: int) -> requests.Response:
            """
            Deletes the featured event for a group
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.DeleteFeaturedContentEvent(groupId=integer, eventId=integer)
        
            Args:
                groupId: int
            eventId: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"groupId": groupId, "eventId": eventId},"headers": {},"cookies": {}}
            
            DeleteFeaturedContentEventRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Groups.roblox.com/v1/featured-content/event", Dictinary=Dictinary)
            return DeleteFeaturedContentEventRecivedData
        
        def GetFeaturedContentEvent(self, groupId: int) -> GroupFeaturedContentResponse:
            """
            Gets the featured event for a group
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetFeaturedContentEvent(groupId=integer)
        
            Args:
                groupId: int
            Returns:
                Groups.GroupFeaturedContentResponse: Groups.GroupFeaturedContentResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"groupId": groupId},"headers": {},"cookies": {}}
            
            GetFeaturedContentEventRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/featured-content/event", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupFeaturedContentResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetFeaturedContentEventRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetFeaturedContentEventRecivedData)
            
            return ResponseSchema
        
        def PostFeaturedContentEvent(self, groupId: int, eventId: int) -> GroupFeaturedContentResponse:
            """
            Sets the featured event for a group
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostFeaturedContentEvent(groupId=integer, eventId=integer)
        
            Args:
                groupId: int
            eventId: int
            Returns:
                Groups.GroupFeaturedContentResponse: Groups.GroupFeaturedContentResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"groupId": groupId, "eventId": eventId},"headers": {},"cookies": {}}
            
            PostFeaturedContentEventRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/featured-content/event", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupFeaturedContentResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostFeaturedContentEventRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostFeaturedContentEventRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupid(self, groupId: int) -> GroupDetailResponse:
            """
            Gets group information
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupid(groupId=integer)
        
            Args:
                groupId: int
            Returns:
                Groups.GroupDetailResponse: Groups.GroupDetailResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsGroupidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupDetailResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidAuditLog(self, actionType: str, userId: int, limit: int, cursor: str, sortOrder: str, groupId: int) -> GroupAuditLogResponseItemExtra:
            """
            Gets the Group's audit log
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidAuditLog(actionType=string, userId=integer, limit=integer, cursor=string, sortOrder=string, groupId=integer)
        
            Args:
                actionType: str
            userId: int
            limit: int
            cursor: str
            sortOrder: str
            groupId: int
            Returns:
                Groups.GroupAuditLogResponseItemExtra: Groups.GroupAuditLogResponseItemExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"actionType": actionType, "userId": userId, "limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetGroupsGroupidAuditLogRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/audit-log", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupAuditLogResponseItemExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidAuditLogRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidAuditLogRecivedData)
            
            return ResponseSchema
        
        def DeleteGroupsGroupidJoinRequests(self, groupId: int, MembersRequest: MembersRequest) -> ApiEmptyResponseModel:
            """
            Batch declines group join requests
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.DeleteGroupsGroupidJoinRequests(groupId=integer, MembersRequest=Groups.MembersRequest())
        
            Args:
                groupId: int
            MembersRequest: MembersRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'MembersRequest': 'json'}
            Arguments = inspect.signature(self.DeleteGroupsGroupidJoinRequests)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            DeleteGroupsGroupidJoinRequestsRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Groups.roblox.com/v1/groups/{groupId}/join-requests", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGroupsGroupidJoinRequestsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGroupsGroupidJoinRequestsRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidJoinRequests(self, limit: int, cursor: str, sortOrder: str, groupId: int) -> GroupJoinRequestResponseExtra:
            """
            Gets a page of Group Join Requests for a group.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidJoinRequests(limit=integer, cursor=string, sortOrder=string, groupId=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            groupId: int
            Returns:
                Groups.GroupJoinRequestResponseExtra: Groups.GroupJoinRequestResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetGroupsGroupidJoinRequestsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/join-requests", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupJoinRequestResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidJoinRequestsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidJoinRequestsRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidJoinRequests(self, groupId: int, MembersRequest: MembersRequest) -> ApiEmptyResponseModel:
            """
            Batch accepts group join requests
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidJoinRequests(groupId=integer, MembersRequest=Groups.MembersRequest())
        
            Args:
                groupId: int
            MembersRequest: MembersRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'MembersRequest': 'json'}
            Arguments = inspect.signature(self.PostGroupsGroupidJoinRequests)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGroupsGroupidJoinRequestsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/join-requests", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidJoinRequestsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidJoinRequestsRecivedData)
            
            return ResponseSchema
        
        def DeleteGroupsGroupidJoinRequestsUsersUserid(self, groupId: int, userId: int) -> ApiEmptyResponseModel:
            """
            Declines/cancels a group join request.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.DeleteGroupsGroupidJoinRequestsUsersUserid(groupId=integer, userId=integer)
        
            Args:
                groupId: int
            userId: int
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteGroupsGroupidJoinRequestsUsersUseridRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Groups.roblox.com/v1/groups/{groupId}/join-requests/users/{userId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGroupsGroupidJoinRequestsUsersUseridRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGroupsGroupidJoinRequestsUsersUseridRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidJoinRequestsUsersUserid(self, groupId: int, userId: int) -> GroupJoinRequestResponse:
            """
            Gets a group join request by userId.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidJoinRequestsUsersUserid(groupId=integer, userId=integer)
        
            Args:
                groupId: int
            userId: int
            Returns:
                Groups.GroupJoinRequestResponse: Groups.GroupJoinRequestResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsGroupidJoinRequestsUsersUseridRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/join-requests/users/{userId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupJoinRequestResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidJoinRequestsUsersUseridRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidJoinRequestsUsersUseridRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidJoinRequestsUsersUserid(self, groupId: int, userId: int) -> ApiEmptyResponseModel:
            """
            Accepts a group join request.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidJoinRequestsUsersUserid(groupId=integer, userId=integer)
        
            Args:
                groupId: int
            userId: int
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostGroupsGroupidJoinRequestsUsersUseridRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/join-requests/users/{userId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidJoinRequestsUsersUseridRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidJoinRequestsUsersUseridRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidMembership(self, includeNotificationPreferences: bool, groupId: int) -> GroupMembershipMetadataResponse:
            """
            Gets group membership information in the context of the authenticated user
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidMembership(includeNotificationPreferences=boolean, groupId=integer)
        
            Args:
                includeNotificationPreferences: bool
            groupId: int
            Returns:
                Groups.GroupMembershipMetadataResponse: Groups.GroupMembershipMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"includeNotificationPreferences": includeNotificationPreferences},"headers": {},"cookies": {}}
            
            GetGroupsGroupidMembershipRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/membership", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupMembershipMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidMembershipRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidMembershipRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidNameHistory(self, limit: int, cursor: str, sortOrder: str, groupId: int) -> GroupNameHistoryResponseItemExtra:
            """
            Gets the Group's name change history.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidNameHistory(limit=integer, cursor=string, sortOrder=string, groupId=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            groupId: int
            Returns:
                Groups.GroupNameHistoryResponseItemExtra: Groups.GroupNameHistoryResponseItemExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetGroupsGroupidNameHistoryRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/name-history", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupNameHistoryResponseItemExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidNameHistoryRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidNameHistoryRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidPayoutRestriction(self, groupId: int) -> GroupPayoutRestrictionResponse:
            """
            Gets a value indicating whether the group can use payout feature
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidPayoutRestriction(groupId=integer)
        
            Args:
                groupId: int
            Returns:
                Groups.GroupPayoutRestrictionResponse: Groups.GroupPayoutRestrictionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsGroupidPayoutRestrictionRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/payout-restriction", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupPayoutRestrictionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidPayoutRestrictionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidPayoutRestrictionRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidPayouts(self, groupId: int) -> GroupPayoutResponseExtra:
            """
            Gets a list of the group payout percentages
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidPayouts(groupId=integer)
        
            Args:
                groupId: int
            Returns:
                Groups.GroupPayoutResponseExtra: Groups.GroupPayoutResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsGroupidPayoutsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/payouts", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupPayoutResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidPayoutsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidPayoutsRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidPayouts(self, groupId: int, PayoutRequest: PayoutRequest) -> ApiEmptyResponseModel:
            """
            Pays out a user in Robux.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidPayouts(groupId=integer, PayoutRequest=Groups.PayoutRequest())
        
            Args:
                groupId: int
            PayoutRequest: PayoutRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PayoutRequest': 'json'}
            Arguments = inspect.signature(self.PostGroupsGroupidPayouts)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGroupsGroupidPayoutsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/payouts", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidPayoutsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidPayoutsRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidRelationshipsGrouprelationshiptype(self, StartRowIndex: int, MaxRows: int, groupId: int, groupRelationshipType: str) -> GroupRelationshipsResponse:
            """
            Gets a group's relationships
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidRelationshipsGrouprelationshiptype(StartRowIndex=integer, MaxRows=integer, groupId=integer, groupRelationshipType=string)
        
            Args:
                StartRowIndex: int
            MaxRows: int
            groupId: int
            groupRelationshipType: str
            Returns:
                Groups.GroupRelationshipsResponse: Groups.GroupRelationshipsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"StartRowIndex": StartRowIndex, "MaxRows": MaxRows},"headers": {},"cookies": {}}
            
            GetGroupsGroupidRelationshipsGrouprelationshiptypeRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/relationships/{groupRelationshipType}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupRelationshipsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidRelationshipsGrouprelationshiptypeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidRelationshipsGrouprelationshiptypeRecivedData)
            
            return ResponseSchema
        
        def DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRequests(self, groupId: int, groupRelationshipType: str, RelationshipsRequest: RelationshipsRequest) -> ApiEmptyResponseModel:
            """
            Batch declines group affiliate requests
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRequests(groupId=integer, groupRelationshipType=string, RelationshipsRequest=Groups.RelationshipsRequest())
        
            Args:
                groupId: int
            groupRelationshipType: str
            RelationshipsRequest: RelationshipsRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RelationshipsRequest': 'json'}
            Arguments = inspect.signature(self.DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRequests)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Groups.roblox.com/v1/groups/{groupId}/relationships/{groupRelationshipType}/requests", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidRelationshipsGrouprelationshiptypeRequests(self, StartRowIndex: int, MaxRows: int, groupId: int, groupRelationshipType: str) -> GroupRelationshipsResponse:
            """
            Gets a group's relationship requests
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidRelationshipsGrouprelationshiptypeRequests(StartRowIndex=integer, MaxRows=integer, groupId=integer, groupRelationshipType=string)
        
            Args:
                StartRowIndex: int
            MaxRows: int
            groupId: int
            groupRelationshipType: str
            Returns:
                Groups.GroupRelationshipsResponse: Groups.GroupRelationshipsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"StartRowIndex": StartRowIndex, "MaxRows": MaxRows},"headers": {},"cookies": {}}
            
            GetGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/relationships/{groupRelationshipType}/requests", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupRelationshipsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidRelationshipsGrouprelationshiptypeRequests(self, groupId: int, groupRelationshipType: str, RelationshipsRequest: RelationshipsRequest) -> ApiEmptyResponseModel:
            """
            Batch accepts group affiliate requests
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidRelationshipsGrouprelationshiptypeRequests(groupId=integer, groupRelationshipType=string, RelationshipsRequest=Groups.RelationshipsRequest())
        
            Args:
                groupId: int
            groupRelationshipType: str
            RelationshipsRequest: RelationshipsRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RelationshipsRequest': 'json'}
            Arguments = inspect.signature(self.PostGroupsGroupidRelationshipsGrouprelationshiptypeRequests)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/relationships/{groupRelationshipType}/requests", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidRoles(self, groupId: int) -> GroupAllRolesResponse:
            """
            Gets a list of the rolesets in a group.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidRoles(groupId=integer)
        
            Args:
                groupId: int
            Returns:
                Groups.GroupAllRolesResponse: Groups.GroupAllRolesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsGroupidRolesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/roles", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupAllRolesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidRolesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidRolesRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidRolesRolesetidPermissions(self, groupId: int, roleSetId: int) -> GroupPermissionsResponse:
            """
            Gets the permissions for a group's roleset. The authorized user must either be the group owner or the roleset being requested, except for guest roles, which can be viewed by all (members and guests).
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidRolesRolesetidPermissions(groupId=integer, roleSetId=integer)
        
            Args:
                groupId: int
            roleSetId: int
            Returns:
                Groups.GroupPermissionsResponse: Groups.GroupPermissionsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsGroupidRolesRolesetidPermissionsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/roles/{roleSetId}/permissions", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupPermissionsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidRolesRolesetidPermissionsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidRolesRolesetidPermissionsRecivedData)
            
            return ResponseSchema
        
        def PatchGroupsGroupidRolesRolesetidPermissions(self, groupId: int, roleSetId: int, UpdatePermissionsRequest: UpdatePermissionsRequest) -> ApiEmptyResponseModel:
            """
            Updates the permissions for a group's roleset. The authorized user must be the group owner.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PatchGroupsGroupidRolesRolesetidPermissions(groupId=integer, roleSetId=integer, UpdatePermissionsRequest=Groups.UpdatePermissionsRequest())
        
            Args:
                groupId: int
            roleSetId: int
            UpdatePermissionsRequest: UpdatePermissionsRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdatePermissionsRequest': 'json'}
            Arguments = inspect.signature(self.PatchGroupsGroupidRolesRolesetidPermissions)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGroupsGroupidRolesRolesetidPermissionsRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Groups.roblox.com/v1/groups/{groupId}/roles/{roleSetId}/permissions", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGroupsGroupidRolesRolesetidPermissionsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGroupsGroupidRolesRolesetidPermissionsRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidRolesRolesetidUsers(self, limit: int, cursor: str, sortOrder: str, groupId: int, roleSetId: int) -> UserModelExtra:
            """
            Gets a list of users in a group for a specific roleset.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidRolesRolesetidUsers(limit=integer, cursor=string, sortOrder=string, groupId=integer, roleSetId=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            groupId: int
            roleSetId: int
            Returns:
                Groups.UserModelExtra: Groups.UserModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetGroupsGroupidRolesRolesetidUsersRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/roles/{roleSetId}/users", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.UserModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidRolesRolesetidUsersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidRolesRolesetidUsersRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidRolesGuestPermissions(self, groupId: int) -> GroupPermissionsResponse:
            """
            Gets the permissions for a group's guest roleset. These can be viewed by all (members and guests) users.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidRolesGuestPermissions(groupId=integer)
        
            Args:
                groupId: int
            Returns:
                Groups.GroupPermissionsResponse: Groups.GroupPermissionsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsGroupidRolesGuestPermissionsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/roles/guest/permissions", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupPermissionsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidRolesGuestPermissionsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidRolesGuestPermissionsRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidRolesPermissions(self, groupId: int) -> GroupPermissionsResponseExtra:
            """
            Gets all permissions for each role
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidRolesPermissions(groupId=integer)
        
            Args:
                groupId: int
            Returns:
                Groups.GroupPermissionsResponseExtra: Groups.GroupPermissionsResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsGroupidRolesPermissionsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/roles/permissions", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupPermissionsResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidRolesPermissionsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidRolesPermissionsRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidSettings(self, groupId: int) -> GroupSettingsResponse:
            """
            Gets the Group's settings
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidSettings(groupId=integer)
        
            Args:
                groupId: int
            Returns:
                Groups.GroupSettingsResponse: Groups.GroupSettingsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsGroupidSettingsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/settings", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupSettingsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidSettingsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidSettingsRecivedData)
            
            return ResponseSchema
        
        def PatchGroupsGroupidSettings(self, groupId: int, UpdateGroupSettingsRequest: UpdateGroupSettingsRequest) -> ApiEmptyResponseModel:
            """
            Updates the group's settings
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PatchGroupsGroupidSettings(groupId=integer, UpdateGroupSettingsRequest=Groups.UpdateGroupSettingsRequest())
        
            Args:
                groupId: int
            UpdateGroupSettingsRequest: UpdateGroupSettingsRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateGroupSettingsRequest': 'json'}
            Arguments = inspect.signature(self.PatchGroupsGroupidSettings)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGroupsGroupidSettingsRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Groups.roblox.com/v1/groups/{groupId}/settings", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGroupsGroupidSettingsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGroupsGroupidSettingsRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidSocialLinks(self, groupId: int) -> SocialLinkResponseExtra:
            """
            Get social link data associated with a group
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidSocialLinks(groupId=integer)
        
            Args:
                groupId: int
            Returns:
                Groups.SocialLinkResponseExtra: Groups.SocialLinkResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsGroupidSocialLinksRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/social-links", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.SocialLinkResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidSocialLinksRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidSocialLinksRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidSocialLinks(self, groupId: int, SocialLinkRequest: SocialLinkRequest) -> SocialLinkResponse:
            """
            Posts a social links
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidSocialLinks(groupId=integer, SocialLinkRequest=Groups.SocialLinkRequest())
        
            Args:
                groupId: int
            SocialLinkRequest: SocialLinkRequest
            Returns:
                Groups.SocialLinkResponse: Groups.SocialLinkResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SocialLinkRequest': 'json'}
            Arguments = inspect.signature(self.PostGroupsGroupidSocialLinks)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGroupsGroupidSocialLinksRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/social-links", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.SocialLinkResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidSocialLinksRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidSocialLinksRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidUsers(self, limit: int, cursor: str, sortOrder: str, groupId: int) -> UserGroupRoleResponseExtra:
            """
            Gets a list of users in a group.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidUsers(limit=integer, cursor=string, sortOrder=string, groupId=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            groupId: int
            Returns:
                Groups.UserGroupRoleResponseExtra: Groups.UserGroupRoleResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetGroupsGroupidUsersRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/users", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.UserGroupRoleResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidUsersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidUsersRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidUsers(self, groupId: int, JoinGroupRequest: JoinGroupRequest) -> ApiEmptyResponseModel:
            """
            Joins a group
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidUsers(groupId=integer, JoinGroupRequest=Groups.JoinGroupRequest())
        
            Args:
                groupId: int
            JoinGroupRequest: JoinGroupRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'JoinGroupRequest': 'json'}
            Arguments = inspect.signature(self.PostGroupsGroupidUsers)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGroupsGroupidUsersRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/users", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidUsersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidUsersRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidWallPosts(self, limit: int, cursor: str, sortOrder: str, groupId: int) -> GroupWallPostModelExtra:
            """
            Gets a list of group wall posts.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsGroupidWallPosts(limit=integer, cursor=string, sortOrder=string, groupId=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            groupId: int
            Returns:
                Groups.GroupWallPostModelExtra: Groups.GroupWallPostModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetGroupsGroupidWallPostsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/{groupId}/wall/posts", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupWallPostModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidWallPostsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidWallPostsRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidWallPosts(self, groupId: int, CreateWallPostRequest: CreateWallPostRequest) -> GroupWallPostModel:
            """
            Creates a post on a group wall
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidWallPosts(groupId=integer, CreateWallPostRequest=Groups.CreateWallPostRequest())
        
            Args:
                groupId: int
            CreateWallPostRequest: CreateWallPostRequest
            Returns:
                Groups.GroupWallPostModel: Groups.GroupWallPostModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'CreateWallPostRequest': 'json'}
            Arguments = inspect.signature(self.PostGroupsGroupidWallPosts)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGroupsGroupidWallPostsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/wall/posts", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupWallPostModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidWallPostsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidWallPostsRecivedData)
            
            return ResponseSchema
        
        def GetGroupsConfigurationMetadata(self) -> GroupConfigurationDisplayOptionsResponse:
            """
            Gets Group configuration contextual information
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsConfigurationMetadata()
        
            Args:
                
            Returns:
                Groups.GroupConfigurationDisplayOptionsResponse: Groups.GroupConfigurationDisplayOptionsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsConfigurationMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/configuration/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupConfigurationDisplayOptionsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsConfigurationMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsConfigurationMetadataRecivedData)
            
            return ResponseSchema
        
        def GetGroupsMetadata(self) -> GroupsDisplayOptionsResponse:
            """
            Gets Groups contextual information:

Max number of groups a user can be part of.

Current number of groups a user is a member of.

Whether to show/hide certain features based on device type.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsMetadata()
        
            Args:
                
            Returns:
                Groups.GroupsDisplayOptionsResponse: Groups.GroupsDisplayOptionsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupsDisplayOptionsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsMetadataRecivedData)
            
            return ResponseSchema
        
        def GetGroupsSearch(self, keyword: str, prioritizeExactMatch: bool, limit: int, cursor: str) -> GroupSearchPageResponse:
            """
            Search for groups by keyword.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsSearch(keyword=string, prioritizeExactMatch=boolean, limit=integer, cursor=string)
        
            Args:
                keyword: str
            prioritizeExactMatch: bool
            limit: int
            cursor: str
            Returns:
                Groups.GroupSearchPageResponse: Groups.GroupSearchPageResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"keyword": keyword, "prioritizeExactMatch": prioritizeExactMatch, "limit": limit, "cursor": cursor},"headers": {},"cookies": {}}
            
            GetGroupsSearchRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/search", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupSearchPageResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsSearchRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsSearchRecivedData)
            
            return ResponseSchema
        
        def GetGroupsSearchLookup(self, groupName: str) -> GroupBasicResponseExtra:
            """
            Looks up groups by a name. Prioritizes an exact match as the first result.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsSearchLookup(groupName=string)
        
            Args:
                groupName: str
            Returns:
                Groups.GroupBasicResponseExtra: Groups.GroupBasicResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"groupName": groupName},"headers": {},"cookies": {}}
            
            GetGroupsSearchLookupRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/search/lookup", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupBasicResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsSearchLookupRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsSearchLookupRecivedData)
            
            return ResponseSchema
        
        def GetGroupsSearchMetadata(self) -> GroupSearchMetadataResponse:
            """
            Get suggested groups and other miscellaneous information needed for the group/join page like flags
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetGroupsSearchMetadata()
        
            Args:
                
            Returns:
                Groups.GroupSearchMetadataResponse: Groups.GroupSearchMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGroupsSearchMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/groups/search/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupSearchMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsSearchMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsSearchMetadataRecivedData)
            
            return ResponseSchema
        
        def GetRoles(self, ids: list) -> GroupRoleDetailResponseExtra:
            """
            Gets the Roles by their ids.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetRoles(ids=array)
        
            Args:
                ids: list
            Returns:
                Groups.GroupRoleDetailResponseExtra: Groups.GroupRoleDetailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"ids": ids},"headers": {},"cookies": {}}
            
            GetRolesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/roles", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupRoleDetailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetRolesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetRolesRecivedData)
            
            return ResponseSchema
        
        def GetUserGroupsPending(self) -> GroupDetailResponseExtra:
            """
            Gets groups that the authenticated user has requested to join
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetUserGroupsPending()
        
            Args:
                
            Returns:
                Groups.GroupDetailResponseExtra: Groups.GroupDetailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUserGroupsPendingRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/user/groups/pending", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupDetailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUserGroupsPendingRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUserGroupsPendingRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridFriendsGroupsRoles(self, userId: int) -> UserGroupMembershipResponseExtra:
            """
            Gets a list of all groups the specified users' friends are in.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetUsersUseridFriendsGroupsRoles(userId=integer)
        
            Args:
                userId: int
            Returns:
                Groups.UserGroupMembershipResponseExtra: Groups.UserGroupMembershipResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridFriendsGroupsRolesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/users/{userId}/friends/groups/roles", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.UserGroupMembershipResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridFriendsGroupsRolesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridFriendsGroupsRolesRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridGroupsPrimaryRole(self, userId: int) -> GroupMembershipDetailResponse:
            """
            Gets a user's primary group.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetUsersUseridGroupsPrimaryRole(userId=integer)
        
            Args:
                userId: int
            Returns:
                Groups.GroupMembershipDetailResponse: Groups.GroupMembershipDetailResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridGroupsPrimaryRoleRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/users/{userId}/groups/primary/role", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupMembershipDetailResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridGroupsPrimaryRoleRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridGroupsPrimaryRoleRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridGroupsRoles(self, includeLocked: bool, includeNotificationPreferences: bool, userId: int) -> GroupMembershipDetailResponseExtra:
            """
            Gets a list of all group roles for groups the specified user is in.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.GetUsersUseridGroupsRoles(includeLocked=boolean, includeNotificationPreferences=boolean, userId=integer)
        
            Args:
                includeLocked: bool
            includeNotificationPreferences: bool
            userId: int
            Returns:
                Groups.GroupMembershipDetailResponseExtra: Groups.GroupMembershipDetailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"includeLocked": includeLocked, "includeNotificationPreferences": includeNotificationPreferences},"headers": {},"cookies": {}}
            
            GetUsersUseridGroupsRolesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Groups.roblox.com/v1/users/{userId}/groups/roles", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupMembershipDetailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridGroupsRolesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridGroupsRolesRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidChangeOwner(self, groupId: int, ChangeOwnerRequest: ChangeOwnerRequest) -> ApiEmptyResponseModel:
            """
            Changes the group owner to another user.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidChangeOwner(groupId=integer, ChangeOwnerRequest=Groups.ChangeOwnerRequest())
        
            Args:
                groupId: int
            ChangeOwnerRequest: ChangeOwnerRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'ChangeOwnerRequest': 'json'}
            Arguments = inspect.signature(self.PostGroupsGroupidChangeOwner)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGroupsGroupidChangeOwnerRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/change-owner", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidChangeOwnerRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidChangeOwnerRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidClaimOwnership(self, groupId: int) -> ApiEmptyResponseModel:
            """
            Claims ownership of the group as the authenticated user
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidClaimOwnership(groupId=integer)
        
            Args:
                groupId: int
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostGroupsGroupidClaimOwnershipRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/claim-ownership", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidClaimOwnershipRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidClaimOwnershipRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidPayoutsRecurring(self, groupId: int, PayoutRequest: PayoutRequest) -> ApiEmptyResponseModel:
            """
            Updates recurring payouts.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidPayoutsRecurring(groupId=integer, PayoutRequest=Groups.PayoutRequest())
        
            Args:
                groupId: int
            PayoutRequest: PayoutRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PayoutRequest': 'json'}
            Arguments = inspect.signature(self.PostGroupsGroupidPayoutsRecurring)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGroupsGroupidPayoutsRecurringRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/payouts/recurring", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidPayoutsRecurringRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidPayoutsRecurringRecivedData)
            
            return ResponseSchema
        
        def DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRelatedgroupid(self, groupId: int, groupRelationshipType: str, relatedGroupId: int) -> ApiEmptyResponseModel:
            """
            Deletes a group relationship.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRelatedgroupid(groupId=integer, groupRelationshipType=string, relatedGroupId=integer)
        
            Args:
                groupId: int
            groupRelationshipType: str
            relatedGroupId: int
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRelatedgroupidRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Groups.roblox.com/v1/groups/{groupId}/relationships/{groupRelationshipType}/{relatedGroupId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRelatedgroupidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRelatedgroupidRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidRelationshipsGrouprelationshiptypeRelatedgroupid(self, groupId: int, groupRelationshipType: str, relatedGroupId: int) -> ApiEmptyResponseModel:
            """
            Create a group relationship.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidRelationshipsGrouprelationshiptypeRelatedgroupid(groupId=integer, groupRelationshipType=string, relatedGroupId=integer)
        
            Args:
                groupId: int
            groupRelationshipType: str
            relatedGroupId: int
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostGroupsGroupidRelationshipsGrouprelationshiptypeRelatedgroupidRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/relationships/{groupRelationshipType}/{relatedGroupId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidRelationshipsGrouprelationshiptypeRelatedgroupidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidRelationshipsGrouprelationshiptypeRelatedgroupidRecivedData)
            
            return ResponseSchema
        
        def DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRelatedgroupid(self, groupId: int, groupRelationshipType: str, relatedGroupId: int) -> ApiEmptyResponseModel:
            """
            Declines a group relationship request.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRelatedgroupid(groupId=integer, groupRelationshipType=string, relatedGroupId=integer)
        
            Args:
                groupId: int
            groupRelationshipType: str
            relatedGroupId: int
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRelatedgroupidRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Groups.roblox.com/v1/groups/{groupId}/relationships/{groupRelationshipType}/requests/{relatedGroupId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRelatedgroupidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRelatedgroupidRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRelatedgroupid(self, groupId: int, groupRelationshipType: str, relatedGroupId: int) -> ApiEmptyResponseModel:
            """
            Accepts a group relationship request.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRelatedgroupid(groupId=integer, groupRelationshipType=string, relatedGroupId=integer)
        
            Args:
                groupId: int
            groupRelationshipType: str
            relatedGroupId: int
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRelatedgroupidRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/relationships/{groupRelationshipType}/requests/{relatedGroupId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRelatedgroupidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidRelationshipsGrouprelationshiptypeRequestsRelatedgroupidRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidRolesetsCreate(self, groupId: int, CreateRoleSetRequest: CreateRoleSetRequest) -> GroupRoleResponse:
            """
            Creates new group roleset.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidRolesetsCreate(groupId=integer, CreateRoleSetRequest=Groups.CreateRoleSetRequest())
        
            Args:
                groupId: int
            CreateRoleSetRequest: CreateRoleSetRequest
            Returns:
                Groups.GroupRoleResponse: Groups.GroupRoleResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'CreateRoleSetRequest': 'json'}
            Arguments = inspect.signature(self.PostGroupsGroupidRolesetsCreate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGroupsGroupidRolesetsCreateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/rolesets/create", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupRoleResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsGroupidRolesetsCreateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsGroupidRolesetsCreateRecivedData)
            
            return ResponseSchema
        
        def PostGroupsGroupidWallSubscribe(self, groupId: int) -> requests.Response:
            """
            Subscribes the authenticated user to notifications of group wall events.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsGroupidWallSubscribe(groupId=integer)
        
            Args:
                groupId: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostGroupsGroupidWallSubscribeRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/{groupId}/wall/subscribe", Dictinary=Dictinary)
            return PostGroupsGroupidWallSubscribeRecivedData
        
        def PostGroupsCreate(self, name: str, description: str, publicGroup: bool, buildersClubMembersOnly: bool, Files: typing.IO) -> GroupResponseV2:
            """
            Creates a new group.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsCreate(name=string, description=string, publicGroup=boolean, buildersClubMembersOnly=boolean, Files=file)
        
            Args:
                name: str
            description: str
            publicGroup: bool
            buildersClubMembersOnly: bool
            Files: typing.IO
            Returns:
                Groups.GroupResponseV2: Groups.GroupResponseV2
            """
        
            Dictinary = {"json": {},"data": {"name": name, "description": description, "publicGroup": publicGroup, "buildersClubMembersOnly": buildersClubMembersOnly, "Files": Files},"params": {},"headers": {},"cookies": {}}
            
            PostGroupsCreateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/create", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupResponseV2()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsCreateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsCreateRecivedData)
            
            return ResponseSchema
        
        def PostGroupsPolicies(self, GroupPolicyRequest: GroupPolicyRequest) -> GroupPoliciesResponse:
            """
            Gets group policy info used for compliance.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostGroupsPolicies(GroupPolicyRequest=Groups.GroupPolicyRequest())
        
            Args:
                GroupPolicyRequest: GroupPolicyRequest
            Returns:
                Groups.GroupPoliciesResponse: Groups.GroupPoliciesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'GroupPolicyRequest': 'json'}
            Arguments = inspect.signature(self.PostGroupsPolicies)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGroupsPoliciesRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/groups/policies", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupPoliciesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostGroupsPoliciesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGroupsPoliciesRecivedData)
            
            return ResponseSchema
        
        def DeleteUserGroupsPrimary(self) -> ApiEmptyResponseModel:
            """
            Removes the authenticated user's primary group
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.DeleteUserGroupsPrimary()
        
            Args:
                
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteUserGroupsPrimaryRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Groups.roblox.com/v1/user/groups/primary", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteUserGroupsPrimaryRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteUserGroupsPrimaryRecivedData)
            
            return ResponseSchema
        
        def PostUserGroupsPrimary(self, PrimaryGroupRequest: PrimaryGroupRequest) -> ApiEmptyResponseModel:
            """
            Sets the authenticated user's primary group
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PostUserGroupsPrimary(PrimaryGroupRequest=Groups.PrimaryGroupRequest())
        
            Args:
                PrimaryGroupRequest: PrimaryGroupRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PrimaryGroupRequest': 'json'}
            Arguments = inspect.signature(self.PostUserGroupsPrimary)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUserGroupsPrimaryRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Groups.roblox.com/v1/user/groups/primary", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUserGroupsPrimaryRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUserGroupsPrimaryRecivedData)
            
            return ResponseSchema
        
        def PatchGroupsGroupidDescription(self, groupId: int, UpdateGroupDescriptionRequest: UpdateGroupDescriptionRequest) -> GroupDescriptionResponse:
            """
            Updates the groups description
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PatchGroupsGroupidDescription(groupId=integer, UpdateGroupDescriptionRequest=Groups.UpdateGroupDescriptionRequest())
        
            Args:
                groupId: int
            UpdateGroupDescriptionRequest: UpdateGroupDescriptionRequest
            Returns:
                Groups.GroupDescriptionResponse: Groups.GroupDescriptionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateGroupDescriptionRequest': 'json'}
            Arguments = inspect.signature(self.PatchGroupsGroupidDescription)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGroupsGroupidDescriptionRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Groups.roblox.com/v1/groups/{groupId}/description", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupDescriptionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGroupsGroupidDescriptionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGroupsGroupidDescriptionRecivedData)
            
            return ResponseSchema
        
        def PatchGroupsGroupidName(self, groupId: int, UpdateGroupNameRequest: UpdateGroupNameRequest) -> UpdateGroupNameResponse:
            """
            Updates the group's name.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PatchGroupsGroupidName(groupId=integer, UpdateGroupNameRequest=Groups.UpdateGroupNameRequest())
        
            Args:
                groupId: int
            UpdateGroupNameRequest: UpdateGroupNameRequest
            Returns:
                Groups.UpdateGroupNameResponse: Groups.UpdateGroupNameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateGroupNameRequest': 'json'}
            Arguments = inspect.signature(self.PatchGroupsGroupidName)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGroupsGroupidNameRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Groups.roblox.com/v1/groups/{groupId}/name", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.UpdateGroupNameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGroupsGroupidNameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGroupsGroupidNameRecivedData)
            
            return ResponseSchema
        
        def PatchGroupsGroupidNotificationPreference(self, groupId: int, UpdateGroupNotificationPreferenceRequest: UpdateGroupNotificationPreferenceRequest) -> requests.Response:
            """
            Updates the group's settings
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PatchGroupsGroupidNotificationPreference(groupId=integer, UpdateGroupNotificationPreferenceRequest=Groups.UpdateGroupNotificationPreferenceRequest())
        
            Args:
                groupId: int
            UpdateGroupNotificationPreferenceRequest: UpdateGroupNotificationPreferenceRequest
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateGroupNotificationPreferenceRequest': 'json'}
            Arguments = inspect.signature(self.PatchGroupsGroupidNotificationPreference)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGroupsGroupidNotificationPreferenceRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Groups.roblox.com/v1/groups/{groupId}/notification-preference", Dictinary=Dictinary)
            return PatchGroupsGroupidNotificationPreferenceRecivedData
        
        def DeleteGroupsGroupidRolesetsRolesetid(self, groupId: int, rolesetId: int) -> ApiEmptyResponseModel:
            """
            Deletes existing group roleset.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.DeleteGroupsGroupidRolesetsRolesetid(groupId=integer, rolesetId=integer)
        
            Args:
                groupId: int
            rolesetId: int
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteGroupsGroupidRolesetsRolesetidRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Groups.roblox.com/v1/groups/{groupId}/rolesets/{rolesetId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGroupsGroupidRolesetsRolesetidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGroupsGroupidRolesetsRolesetidRecivedData)
            
            return ResponseSchema
        
        def PatchGroupsGroupidRolesetsRolesetid(self, groupId: int, rolesetId: int, UpdateRoleSetRequest: UpdateRoleSetRequest) -> GroupRoleResponse:
            """
            Updates existing group roleset.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PatchGroupsGroupidRolesetsRolesetid(groupId=integer, rolesetId=integer, UpdateRoleSetRequest=Groups.UpdateRoleSetRequest())
        
            Args:
                groupId: int
            rolesetId: int
            UpdateRoleSetRequest: UpdateRoleSetRequest
            Returns:
                Groups.GroupRoleResponse: Groups.GroupRoleResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateRoleSetRequest': 'json'}
            Arguments = inspect.signature(self.PatchGroupsGroupidRolesetsRolesetid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGroupsGroupidRolesetsRolesetidRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Groups.roblox.com/v1/groups/{groupId}/rolesets/{rolesetId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.GroupRoleResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGroupsGroupidRolesetsRolesetidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGroupsGroupidRolesetsRolesetidRecivedData)
            
            return ResponseSchema
        
        def DeleteGroupsGroupidSocialLinksSociallinkid(self, groupId: int, socialLinkId: int) -> ApiEmptyResponseModel:
            """
            Deletes a social link
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.DeleteGroupsGroupidSocialLinksSociallinkid(groupId=integer, socialLinkId=integer)
        
            Args:
                groupId: int
            socialLinkId: int
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteGroupsGroupidSocialLinksSociallinkidRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Groups.roblox.com/v1/groups/{groupId}/social-links/{socialLinkId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGroupsGroupidSocialLinksSociallinkidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGroupsGroupidSocialLinksSociallinkidRecivedData)
            
            return ResponseSchema
        
        def PatchGroupsGroupidSocialLinksSociallinkid(self, groupId: int, socialLinkId: int, SocialLinkRequest: SocialLinkRequest) -> ApiEmptyResponseModel:
            """
            Updates a social link
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PatchGroupsGroupidSocialLinksSociallinkid(groupId=integer, socialLinkId=integer, SocialLinkRequest=Groups.SocialLinkRequest())
        
            Args:
                groupId: int
            socialLinkId: int
            SocialLinkRequest: SocialLinkRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SocialLinkRequest': 'json'}
            Arguments = inspect.signature(self.PatchGroupsGroupidSocialLinksSociallinkid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGroupsGroupidSocialLinksSociallinkidRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Groups.roblox.com/v1/groups/{groupId}/social-links/{socialLinkId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGroupsGroupidSocialLinksSociallinkidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGroupsGroupidSocialLinksSociallinkidRecivedData)
            
            return ResponseSchema
        
        def PatchGroupsGroupidStatus(self, groupId: int, PostGroupStatusRequest: PostGroupStatusRequest) -> ShoutResponse:
            """
            Sets group status
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PatchGroupsGroupidStatus(groupId=integer, PostGroupStatusRequest=Groups.PostGroupStatusRequest())
        
            Args:
                groupId: int
            PostGroupStatusRequest: PostGroupStatusRequest
            Returns:
                Groups.ShoutResponse: Groups.ShoutResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PostGroupStatusRequest': 'json'}
            Arguments = inspect.signature(self.PatchGroupsGroupidStatus)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGroupsGroupidStatusRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Groups.roblox.com/v1/groups/{groupId}/status", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ShoutResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGroupsGroupidStatusRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGroupsGroupidStatusRecivedData)
            
            return ResponseSchema
        
        def DeleteGroupsGroupidUsersUserid(self, groupId: int, userId: int) -> ApiEmptyResponseModel:
            """
            Removes a user from a group
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.DeleteGroupsGroupidUsersUserid(groupId=integer, userId=integer)
        
            Args:
                groupId: int
            userId: int
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteGroupsGroupidUsersUseridRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Groups.roblox.com/v1/groups/{groupId}/users/{userId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGroupsGroupidUsersUseridRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGroupsGroupidUsersUseridRecivedData)
            
            return ResponseSchema
        
        def PatchGroupsGroupidUsersUserid(self, groupId: int, userId: int, UpdateUserRoleRequest: UpdateUserRoleRequest) -> ApiEmptyResponseModel:
            """
            Updates a users role in a group.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PatchGroupsGroupidUsersUserid(groupId=integer, userId=integer, UpdateUserRoleRequest=Groups.UpdateUserRoleRequest())
        
            Args:
                groupId: int
            userId: int
            UpdateUserRoleRequest: UpdateUserRoleRequest
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateUserRoleRequest': 'json'}
            Arguments = inspect.signature(self.PatchGroupsGroupidUsersUserid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGroupsGroupidUsersUseridRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Groups.roblox.com/v1/groups/{groupId}/users/{userId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGroupsGroupidUsersUseridRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGroupsGroupidUsersUseridRecivedData)
            
            return ResponseSchema
        
        def PatchGroupsIcon(self, groupId: int, Files: typing.IO) -> ApiEmptyResponseModel:
            """
            Updates the group icon.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.PatchGroupsIcon(groupId=integer, Files=file)
        
            Args:
                groupId: int
            Files: typing.IO
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {"Files": Files},"params": {"groupId": groupId},"headers": {},"cookies": {}}
            
            PatchGroupsIconRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Groups.roblox.com/v1/groups/icon", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGroupsIconRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGroupsIconRecivedData)
            
            return ResponseSchema
        
        def DeleteGroupsGroupidWallPostsPostid(self, groupId: int, postId: int) -> ApiEmptyResponseModel:
            """
            Deletes a group wall post.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.DeleteGroupsGroupidWallPostsPostid(groupId=integer, postId=integer)
        
            Args:
                groupId: int
            postId: int
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteGroupsGroupidWallPostsPostidRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Groups.roblox.com/v1/groups/{groupId}/wall/posts/{postId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGroupsGroupidWallPostsPostidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGroupsGroupidWallPostsPostidRecivedData)
            
            return ResponseSchema
        
        def DeleteGroupsGroupidWallUsersUseridPosts(self, groupId: int, userId: int) -> ApiEmptyResponseModel:
            """
            Deletes all group wall posts made by a specific user.
            
            Usage:
                import Groups
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GroupsApi = Groups.GroupsApi(RobloxClient=RobloxClient)
                Response = GroupsApi.DeleteGroupsGroupidWallUsersUseridPosts(groupId=integer, userId=integer)
        
            Args:
                groupId: int
            userId: int
            Returns:
                Groups.ApiEmptyResponseModel: Groups.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteGroupsGroupidWallUsersUseridPostsRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Groups.roblox.com/v1/groups/{groupId}/wall/users/{userId}/posts", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Groups.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGroupsGroupidWallUsersUseridPostsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGroupsGroupidWallUsersUseridPostsRecivedData)
            
            return ResponseSchema
        
    class Games:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class CreateVipServersRequest:
            def __init__(ClassObject, name: str = None, expectedPrice: int = None, isPurchaseConfirmed: bool = None):
                ClassObject.name = name
                ClassObject.expectedPrice = expectedPrice
                ClassObject.isPurchaseConfirmed = isPurchaseConfirmed
                ClassObject.response: requests.Response = None


        class PlaceResponse:
            def __init__(ClassObject, id: int = None, name: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class GameResponse:
            def __init__(ClassObject, id: int = None, name: str = None, rootPlace: "RobloxClient.Games.PlaceResponse" = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.rootPlace = rootPlace
                ClassObject.response: requests.Response = None


        class GameServerPlayerResponse:
            def __init__(ClassObject, playerToken: str = None, id: int = None, name: str = None, displayName: str = None):
                ClassObject.playerToken = playerToken
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class GameFavoritesRequest:
            def __init__(ClassObject, isFavorited: bool = None):
                ClassObject.isFavorited = isFavorited
                ClassObject.response: requests.Response = None


        class SetUserGameVoteRequest:
            def __init__(ClassObject, vote: bool = None):
                ClassObject.vote = vote
                ClassObject.response: requests.Response = None


        class GameCreator:
            def __init__(ClassObject, id: int = None, name: str = None, type: str = None, isRNVAccount: bool = None, hasVerifiedBadge: bool = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.type = type
                ClassObject.isRNVAccount = isRNVAccount
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.response: requests.Response = None


        class GameDetailResponse:
            def __init__(ClassObject, id: int = None, rootPlaceId: int = None, name: str = None, description: str = None, sourceName: str = None, sourceDescription: str = None, creator: "RobloxClient.Games.GameCreator" = None, price: int = None, allowedGearGenres: list[str] = None, allowedGearCategories: list[str] = None, isGenreEnforced: bool = None, copyingAllowed: bool = None, playing: int = None, visits: int = None, maxPlayers: int = None, created: str = None, updated: str = None, studioAccessToApisAllowed: bool = None, createVipServersAllowed: bool = None, universeAvatarType: enum.Enum = None, genre: str = None, genrel1: str = None, genrel2: str = None, isAllGenre: bool = None, isFavoritedByUser: bool = None, favoritedCount: int = None):
                ClassObject.id = id
                ClassObject.rootPlaceId = rootPlaceId
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.sourceName = sourceName
                ClassObject.sourceDescription = sourceDescription
                ClassObject.creator = creator
                ClassObject.price = price
                ClassObject.allowedGearGenres = allowedGearGenres
                ClassObject.allowedGearCategories = allowedGearCategories
                ClassObject.isGenreEnforced = isGenreEnforced
                ClassObject.copyingAllowed = copyingAllowed
                ClassObject.playing = playing
                ClassObject.visits = visits
                ClassObject.maxPlayers = maxPlayers
                ClassObject.created = created
                ClassObject.updated = updated
                ClassObject.studioAccessToApisAllowed = studioAccessToApisAllowed
                ClassObject.createVipServersAllowed = createVipServersAllowed
                ClassObject.universeAvatarType = universeAvatarType
                ClassObject.genre = genre
                ClassObject.genrel1 = genrel1
                ClassObject.genrel2 = genrel2
                ClassObject.isAllGenre = isAllGenre
                ClassObject.isFavoritedByUser = isFavoritedByUser
                ClassObject.favoritedCount = favoritedCount
                ClassObject.response: requests.Response = None


        class GameFavoriteResponse:
            def __init__(ClassObject, isFavorited: bool = None):
                ClassObject.isFavorited = isFavorited
                ClassObject.response: requests.Response = None


        class GameFavoritesCountResponse:
            def __init__(ClassObject, favoritesCount: int = None):
                ClassObject.favoritesCount = favoritesCount
                ClassObject.response: requests.Response = None


        class GameMediaItem:
            def __init__(ClassObject, id: int = None, assetTypeId: int = None, assetType: str = None, imageId: int = None, videoHash: str = None, videoTitle: str = None, approved: bool = None, altText: str = None):
                ClassObject.id = id
                ClassObject.assetTypeId = assetTypeId
                ClassObject.assetType = assetType
                ClassObject.imageId = imageId
                ClassObject.videoHash = videoHash
                ClassObject.videoTitle = videoTitle
                ClassObject.approved = approved
                ClassObject.altText = altText
                ClassObject.response: requests.Response = None


        class GamePassResponse:
            def __init__(ClassObject, id: int = None, name: str = None, displayName: str = None, productId: int = None, price: int = None, sellerName: str = None, sellerId: int = None, isOwned: bool = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.productId = productId
                ClassObject.price = price
                ClassObject.sellerName = sellerName
                ClassObject.sellerId = sellerId
                ClassObject.isOwned = isOwned
                ClassObject.response: requests.Response = None


        class GameProductResponse:
            def __init__(ClassObject, universeId: int = None, isForSale: bool = None, productId: int = None, price: int = None, sellerId: int = None):
                ClassObject.universeId = universeId
                ClassObject.isForSale = isForSale
                ClassObject.productId = productId
                ClassObject.price = price
                ClassObject.sellerId = sellerId
                ClassObject.response: requests.Response = None


        class GameResponseModel:
            def __init__(ClassObject, creatorId: int = None, creatorName: str = None, creatorType: str = None, creatorHasVerifiedBadge: bool = None, totalUpVotes: int = None, totalDownVotes: int = None, universeId: int = None, name: str = None, placeId: int = None, playerCount: int = None, imageToken: str = None, isSponsored: bool = None, nativeAdData: str = None, isShowSponsoredLabel: bool = None, price: int = None, analyticsIdentifier: str = None, gameDescription: str = None, genre: str = None, minimumAge: int = None, ageRecommendationDisplayName: str = None):
                ClassObject.creatorId = creatorId
                ClassObject.creatorName = creatorName
                ClassObject.creatorType = creatorType
                ClassObject.creatorHasVerifiedBadge = creatorHasVerifiedBadge
                ClassObject.totalUpVotes = totalUpVotes
                ClassObject.totalDownVotes = totalDownVotes
                ClassObject.universeId = universeId
                ClassObject.name = name
                ClassObject.placeId = placeId
                ClassObject.playerCount = playerCount
                ClassObject.imageToken = imageToken
                ClassObject.isSponsored = isSponsored
                ClassObject.nativeAdData = nativeAdData
                ClassObject.isShowSponsoredLabel = isShowSponsoredLabel
                ClassObject.price = price
                ClassObject.analyticsIdentifier = analyticsIdentifier
                ClassObject.gameDescription = gameDescription
                ClassObject.genre = genre
                ClassObject.minimumAge = minimumAge
                ClassObject.ageRecommendationDisplayName = ageRecommendationDisplayName
                ClassObject.response: requests.Response = None


        class GameRecommendationsResponse:
            def __init__(ClassObject, games: list["RobloxClient.Games.GameResponseModel"] = None, nextPaginationKey: str = None):
                ClassObject.games = games
                ClassObject.nextPaginationKey = nextPaginationKey
                ClassObject.response: requests.Response = None


        class SpotlightTypeData:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class GameSpotlightResponse:
            def __init__(ClassObject, spotlightType: str = None, spotlightActionText: str = None, spotlightTypeData: "RobloxClient.Games.SpotlightTypeData" = None, gameInfo: "RobloxClient.Games.GameResponseModel" = None):
                ClassObject.spotlightType = spotlightType
                ClassObject.spotlightActionText = spotlightActionText
                ClassObject.spotlightTypeData = spotlightTypeData
                ClassObject.gameInfo = gameInfo
                ClassObject.response: requests.Response = None


        class GameVoteResponse:
            def __init__(ClassObject, id: int = None, upVotes: int = None, downVotes: int = None):
                ClassObject.id = id
                ClassObject.upVotes = upVotes
                ClassObject.downVotes = downVotes
                ClassObject.response: requests.Response = None


        class MyPrivateServersData:
            def __init__(ClassObject, universeId: int = None, placeId: int = None, name: str = None, ownerId: int = None, ownerName: str = None, priceInRobux: int = None):
                ClassObject.universeId = universeId
                ClassObject.placeId = placeId
                ClassObject.name = name
                ClassObject.ownerId = ownerId
                ClassObject.ownerName = ownerName
                ClassObject.priceInRobux = priceInRobux
                ClassObject.response: requests.Response = None


        class MyPrivateServersResponse:
            def __init__(ClassObject, nextPageCursor: str = None, previousPageCursor: str = None, data: list["RobloxClient.Games.MyPrivateServersData"] = None):
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class PlaceDetails:
            def __init__(ClassObject, placeId: int = None, name: str = None, description: str = None, sourceName: str = None, sourceDescription: str = None, url: str = None, builder: str = None, builderId: int = None, hasVerifiedBadge: bool = None, isPlayable: bool = None, reasonProhibited: str = None, universeId: int = None, universeRootPlaceId: int = None, price: int = None, imageToken: str = None):
                ClassObject.placeId = placeId
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.sourceName = sourceName
                ClassObject.sourceDescription = sourceDescription
                ClassObject.url = url
                ClassObject.builder = builder
                ClassObject.builderId = builderId
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.isPlayable = isPlayable
                ClassObject.reasonProhibited = reasonProhibited
                ClassObject.universeId = universeId
                ClassObject.universeRootPlaceId = universeRootPlaceId
                ClassObject.price = price
                ClassObject.imageToken = imageToken
                ClassObject.response: requests.Response = None


        class PlayabilityStatusResponse:
            def __init__(ClassObject, playabilityStatus: enum.Enum = None, isPlayable: bool = None, universeId: int = None):
                ClassObject.playabilityStatus = playabilityStatus
                ClassObject.isPlayable = isPlayable
                ClassObject.universeId = universeId
                ClassObject.response: requests.Response = None


        class PrivateServersEnabledInUniverseResponse:
            def __init__(ClassObject, privateServersEnabled: bool = None):
                ClassObject.privateServersEnabled = privateServersEnabled
                ClassObject.response: requests.Response = None


        class Thumbnail:
            def __init__(ClassObject, final: bool = None, url: str = None, cdnUrl: str = None, retryToken: str = None, universeId: int = None, placeId: int = None):
                ClassObject.final = final
                ClassObject.url = url
                ClassObject.cdnUrl = cdnUrl
                ClassObject.retryToken = retryToken
                ClassObject.universeId = universeId
                ClassObject.placeId = placeId
                ClassObject.response: requests.Response = None


        class UserGameVoteResponse:
            def __init__(ClassObject, canVote: bool = None, userVote: bool = None, reasonForNotVoteable: str = None):
                ClassObject.canVote = canVote
                ClassObject.userVote = userVote
                ClassObject.reasonForNotVoteable = reasonForNotVoteable
                ClassObject.response: requests.Response = None


        class VerifiedBadgeUserResponse:
            def __init__(ClassObject, hasVerifiedBadge: bool = None, id: int = None, name: str = None, displayName: str = None):
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class GameServerResponse:
            def __init__(ClassObject, id: str = None, maxPlayers: int = None, playing: int = None, playerTokens: list[str] = None, players: list["RobloxClient.Games.GameServerPlayerResponse"] = None, fps: float = None, ping: int = None, name: str = None, vipServerId: int = None, accessCode: str = None, owner: "RobloxClient.Games.VerifiedBadgeUserResponse" = None):
                ClassObject.id = id
                ClassObject.maxPlayers = maxPlayers
                ClassObject.playing = playing
                ClassObject.playerTokens = playerTokens
                ClassObject.players = players
                ClassObject.fps = fps
                ClassObject.ping = ping
                ClassObject.name = name
                ClassObject.vipServerId = vipServerId
                ClassObject.accessCode = accessCode
                ClassObject.owner = owner
                ClassObject.response: requests.Response = None


        class PrivateServersResponse:
            def __init__(ClassObject, privateServerResponses: list["RobloxClient.Games.GameServerResponse"] = None):
                ClassObject.privateServerResponses = privateServerResponses
                ClassObject.response: requests.Response = None


        class VipServerCanInviteResponse:
            def __init__(ClassObject, canInvite: bool = None, doesOwnerPrivacyRestrictJoins: bool = None, inviteResponseType: enum.Enum = None):
                ClassObject.canInvite = canInvite
                ClassObject.doesOwnerPrivacyRestrictJoins = doesOwnerPrivacyRestrictJoins
                ClassObject.inviteResponseType = inviteResponseType
                ClassObject.response: requests.Response = None


        class SkinnyUserResponse:
            def __init__(ClassObject, id: int = None, name: str = None, displayName: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class VipServerPermissionsResponse:
            def __init__(ClassObject, clanAllowed: bool = None, enemyClanId: int = None, friendsAllowed: bool = None, users: list["RobloxClient.Games.SkinnyUserResponse"] = None):
                ClassObject.clanAllowed = clanAllowed
                ClassObject.enemyClanId = enemyClanId
                ClassObject.friendsAllowed = friendsAllowed
                ClassObject.users = users
                ClassObject.response: requests.Response = None


        class VipServerSubscriptionResponse:
            def __init__(ClassObject, active: bool = None, expired: bool = None, expirationDate: str = None, price: int = None, canRenew: bool = None, hasInsufficientFunds: bool = None, hasRecurringProfile: bool = None, hasPriceChanged: bool = None):
                ClassObject.active = active
                ClassObject.expired = expired
                ClassObject.expirationDate = expirationDate
                ClassObject.price = price
                ClassObject.canRenew = canRenew
                ClassObject.hasInsufficientFunds = hasInsufficientFunds
                ClassObject.hasRecurringProfile = hasRecurringProfile
                ClassObject.hasPriceChanged = hasPriceChanged
                ClassObject.response: requests.Response = None


        class VipServerVoiceSettingsResponse:
            def __init__(ClassObject, enabled: bool = None):
                ClassObject.enabled = enabled
                ClassObject.response: requests.Response = None


        class VipServerResponse:
            def __init__(ClassObject, id: int = None, name: str = None, game: "RobloxClient.Games.GameResponse" = None, joinCode: str = None, active: bool = None, subscription: "RobloxClient.Games.VipServerSubscriptionResponse" = None, permissions: "RobloxClient.Games.VipServerPermissionsResponse" = None, voiceSettings: "RobloxClient.Games.VipServerVoiceSettingsResponse" = None, link: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.game = game
                ClassObject.joinCode = joinCode
                ClassObject.active = active
                ClassObject.subscription = subscription
                ClassObject.permissions = permissions
                ClassObject.voiceSettings = voiceSettings
                ClassObject.link = link
                ClassObject.response: requests.Response = None


        class VipServerUpdatePermissionsRequest:
            def __init__(ClassObject, clanAllowed: bool = None, enemyClanId: int = None, friendsAllowed: bool = None, usersToAdd: list[int] = None, usersToRemove: list[int] = None):
                ClassObject.clanAllowed = clanAllowed
                ClassObject.enemyClanId = enemyClanId
                ClassObject.friendsAllowed = friendsAllowed
                ClassObject.usersToAdd = usersToAdd
                ClassObject.usersToRemove = usersToRemove
                ClassObject.response: requests.Response = None


        class VipServerUpdateRequest:
            def __init__(ClassObject, name: str = None, newJoinCode: bool = None, active: bool = None):
                ClassObject.name = name
                ClassObject.newJoinCode = newJoinCode
                ClassObject.active = active
                ClassObject.response: requests.Response = None


        class VipServerUpdateSubscriptionRequest:
            def __init__(ClassObject, active: bool = None, price: int = None):
                ClassObject.active = active
                ClassObject.price = price
                ClassObject.response: requests.Response = None


        class VipServerUpdateVoiceSettingsRequest:
            def __init__(ClassObject, enabled: bool = None):
                ClassObject.enabled = enabled
                ClassObject.response: requests.Response = None


        class StringExtra:
            def __init__(ClassObject, key: str = None, sortOrder: enum.Enum = None, pagingDirection: enum.Enum = None, pageNumber: int = None, discriminator: str = None, count: int = None):
                ClassObject.key = key
                ClassObject.sortOrder = sortOrder
                ClassObject.pagingDirection = pagingDirection
                ClassObject.pageNumber = pageNumber
                ClassObject.discriminator = discriminator
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class StartIndexCursor:
            def __init__(ClassObject, startIndex: int = None, discriminator: str = None, count: int = None):
                ClassObject.startIndex = startIndex
                ClassObject.discriminator = discriminator
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class GameDetailResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Games.GameDetailResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GameMediaItemExtra:
            def __init__(ClassObject, data: list["RobloxClient.Games.GameMediaItem"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GameProductResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Games.GameProductResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GameSpotlightResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Games.GameSpotlightResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GameVoteResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Games.GameVoteResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GamePassResponseExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Games.GamePassResponse"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GameServerResponseExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Games.GameServerResponse"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetGames(self, universeIds: list) -> GameDetailResponseExtra:
            """
            Gets a list of games' detail
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGames(universeIds=array)
        
            Args:
                universeIds: list
            Returns:
                Games.GameDetailResponseExtra: Games.GameDetailResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"universeIds": universeIds},"headers": {},"cookies": {}}
            
            GetGamesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameDetailResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesRecivedData)
            
            return ResponseSchema
        
        def GetGamesPlaceidPrivateServers(self, limit: int, cursor: str, sortOrder: str, placeId: int) -> GameServerResponseExtra:
            """
            Get list of private servers user can access for given game id.
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesPlaceidPrivateServers(limit=integer, cursor=string, sortOrder=string, placeId=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            placeId: int
            Returns:
                Games.GameServerResponseExtra: Games.GameServerResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetGamesPlaceidPrivateServersRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/{placeId}/private-servers", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameServerResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesPlaceidPrivateServersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesPlaceidPrivateServersRecivedData)
            
            return ResponseSchema
        
        def GetGamesPlaceidServersServertype(self, sortOrder: int, excludeFullGames: bool, limit: int, cursor: str, placeId: int, serverType: int) -> GameServerResponseExtra:
            """
            Get the game server list
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesPlaceidServersServertype(sortOrder=integer, excludeFullGames=boolean, limit=integer, cursor=string, placeId=integer, serverType=integer)
        
            Args:
                sortOrder: int
            excludeFullGames: bool
            limit: int
            cursor: str
            placeId: int
            serverType: int
            Returns:
                Games.GameServerResponseExtra: Games.GameServerResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"sortOrder": sortOrder, "excludeFullGames": excludeFullGames, "limit": limit, "cursor": cursor},"headers": {},"cookies": {}}
            
            GetGamesPlaceidServersServertypeRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/{placeId}/servers/{serverType}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameServerResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesPlaceidServersServertypeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesPlaceidServersServertypeRecivedData)
            
            return ResponseSchema
        
        def GetGamesUniverseidFavorites(self, universeId: int) -> GameFavoriteResponse:
            """
            Returns if a game was marked as favorite for the authenticated user
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesUniverseidFavorites(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Games.GameFavoriteResponse: Games.GameFavoriteResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGamesUniverseidFavoritesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/{universeId}/favorites", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameFavoriteResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesUniverseidFavoritesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesUniverseidFavoritesRecivedData)
            
            return ResponseSchema
        
        def PostGamesUniverseidFavorites(self, universeId: int, GameFavoritesRequest: GameFavoritesRequest) -> ApiEmptyResponseModel:
            """
            Favors (or unfavors) a game for the authenticated user
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.PostGamesUniverseidFavorites(universeId=integer, GameFavoritesRequest=Games.GameFavoritesRequest())
        
            Args:
                universeId: int
            GameFavoritesRequest: GameFavoritesRequest
            Returns:
                Games.ApiEmptyResponseModel: Games.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'GameFavoritesRequest': 'json'}
            Arguments = inspect.signature(self.PostGamesUniverseidFavorites)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGamesUniverseidFavoritesRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Games.roblox.com/v1/games/{universeId}/favorites", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGamesUniverseidFavoritesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGamesUniverseidFavoritesRecivedData)
            
            return ResponseSchema
        
        def GetGamesUniverseidFavoritesCount(self, universeId: int) -> GameFavoritesCountResponse:
            """
            Get the favorites count of the a specific game
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesUniverseidFavoritesCount(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Games.GameFavoritesCountResponse: Games.GameFavoritesCountResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGamesUniverseidFavoritesCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/{universeId}/favorites/count", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameFavoritesCountResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesUniverseidFavoritesCountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesUniverseidFavoritesCountRecivedData)
            
            return ResponseSchema
        
        def GetGamesUniverseidGamePasses(self, limit: int, sortOrder: int, cursor: str, universeId: int) -> GamePassResponseExtra:
            """
            Get the game's game passes
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesUniverseidGamePasses(limit=integer, sortOrder=integer, cursor=string, universeId=integer)
        
            Args:
                limit: int
            sortOrder: int
            cursor: str
            universeId: int
            Returns:
                Games.GamePassResponseExtra: Games.GamePassResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "sortOrder": sortOrder, "cursor": cursor},"headers": {},"cookies": {}}
            
            GetGamesUniverseidGamePassesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/{universeId}/game-passes", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GamePassResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesUniverseidGamePassesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesUniverseidGamePassesRecivedData)
            
            return ResponseSchema
        
        def GetGamesUniverseidMedia(self, universeId: int) -> GameMediaItemExtra:
            """
            Get the game media data
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesUniverseidMedia(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Games.GameMediaItemExtra: Games.GameMediaItemExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGamesUniverseidMediaRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/{universeId}/media", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameMediaItemExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesUniverseidMediaRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesUniverseidMediaRecivedData)
            
            return ResponseSchema
        
        def GetGamesUniverseidVotes(self, universeId: int) -> GameVoteResponse:
            """
            Get the game vote status
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesUniverseidVotes(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Games.GameVoteResponse: Games.GameVoteResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGamesUniverseidVotesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/{universeId}/votes", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameVoteResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesUniverseidVotesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesUniverseidVotesRecivedData)
            
            return ResponseSchema
        
        def GetGamesUniverseidVotesUser(self, universeId: int) -> UserGameVoteResponse:
            """
            Get the user's vote status for a game
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesUniverseidVotesUser(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Games.UserGameVoteResponse: Games.UserGameVoteResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGamesUniverseidVotesUserRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/{universeId}/votes/user", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.UserGameVoteResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesUniverseidVotesUserRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesUniverseidVotesUserRecivedData)
            
            return ResponseSchema
        
        def GetGamesGameThumbnail(self, imageToken: str, height: int, width: int) -> requests.Response:
            """
            Get a single game thumbnail
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesGameThumbnail(imageToken=string, height=integer, width=integer)
        
            Args:
                imageToken: str
            height: int
            width: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"imageToken": imageToken, "height": height, "width": width},"headers": {},"cookies": {}}
            
            GetGamesGameThumbnailRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/game-thumbnail", Dictinary=Dictinary)
            return GetGamesGameThumbnailRecivedData
        
        def GetGamesGameThumbnails(self, imageTokens: list, height: int, width: int) -> requests.Response:
            """
            Gets a list of game thumbnails
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesGameThumbnails(imageTokens=array, height=integer, width=integer)
        
            Args:
                imageTokens: list
            height: int
            width: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"imageTokens": imageTokens, "height": height, "width": width},"headers": {},"cookies": {}}
            
            GetGamesGameThumbnailsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/game-thumbnails", Dictinary=Dictinary)
            return GetGamesGameThumbnailsRecivedData
        
        def GetGamesGamesProductInfo(self, universeIds: list) -> GameProductResponseExtra:
            """
            Gets a list of games' product info, used to purchase a game
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesGamesProductInfo(universeIds=array)
        
            Args:
                universeIds: list
            Returns:
                Games.GameProductResponseExtra: Games.GameProductResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"universeIds": universeIds},"headers": {},"cookies": {}}
            
            GetGamesGamesProductInfoRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/games-product-info", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameProductResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesGamesProductInfoRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesGamesProductInfoRecivedData)
            
            return ResponseSchema
        
        def GetGamesListSpotlight(self) -> GameSpotlightResponseExtra:
            """
            Gets games that the client should spotlight.
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesListSpotlight()
        
            Args:
                
            Returns:
                Games.GameSpotlightResponseExtra: Games.GameSpotlightResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGamesListSpotlightRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/list-spotlight", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameSpotlightResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesListSpotlightRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesListSpotlightRecivedData)
            
            return ResponseSchema
        
        def GetGamesMultigetPlaceDetails(self, placeIds: list) -> requests.Response:
            """
            Get place details
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesMultigetPlaceDetails(placeIds=array)
        
            Args:
                placeIds: list
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"placeIds": placeIds},"headers": {},"cookies": {}}
            
            GetGamesMultigetPlaceDetailsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/multiget-place-details", Dictinary=Dictinary)
            return GetGamesMultigetPlaceDetailsRecivedData
        
        def GetGamesMultigetPlayabilityStatus(self, universeIds: list) -> requests.Response:
            """
            Gets a list of universe playability statuses for the authenticated user
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesMultigetPlayabilityStatus(universeIds=array)
        
            Args:
                universeIds: list
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"universeIds": universeIds},"headers": {},"cookies": {}}
            
            GetGamesMultigetPlayabilityStatusRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/multiget-playability-status", Dictinary=Dictinary)
            return GetGamesMultigetPlayabilityStatusRecivedData
        
        def GetGamesRecommendationsAlgorithmAlgorithmname(self, PaginationKey: str, MaxRows: int, IsTruncatedResultsEnabled: bool, algorithmName: str) -> GameRecommendationsResponse:
            """
            Get games recommendations
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesRecommendationsAlgorithmAlgorithmname(PaginationKey=string, MaxRows=integer, IsTruncatedResultsEnabled=boolean, algorithmName=string)
        
            Args:
                PaginationKey: str
            MaxRows: int
            IsTruncatedResultsEnabled: bool
            algorithmName: str
            Returns:
                Games.GameRecommendationsResponse: Games.GameRecommendationsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"PaginationKey": PaginationKey, "MaxRows": MaxRows, "IsTruncatedResultsEnabled": IsTruncatedResultsEnabled},"headers": {},"cookies": {}}
            
            GetGamesRecommendationsAlgorithmAlgorithmnameRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/recommendations/algorithm/{algorithmName}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameRecommendationsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesRecommendationsAlgorithmAlgorithmnameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesRecommendationsAlgorithmAlgorithmnameRecivedData)
            
            return ResponseSchema
        
        def GetGamesRecommendationsGameUniverseid(self, PaginationKey: str, MaxRows: int, IsTruncatedResultsEnabled: bool, universeId: int) -> GameRecommendationsResponse:
            """
            Get games recommendations based on a given universe
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesRecommendationsGameUniverseid(PaginationKey=string, MaxRows=integer, IsTruncatedResultsEnabled=boolean, universeId=integer)
        
            Args:
                PaginationKey: str
            MaxRows: int
            IsTruncatedResultsEnabled: bool
            universeId: int
            Returns:
                Games.GameRecommendationsResponse: Games.GameRecommendationsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"PaginationKey": PaginationKey, "MaxRows": MaxRows, "IsTruncatedResultsEnabled": IsTruncatedResultsEnabled},"headers": {},"cookies": {}}
            
            GetGamesRecommendationsGameUniverseidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/recommendations/game/{universeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameRecommendationsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesRecommendationsGameUniverseidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesRecommendationsGameUniverseidRecivedData)
            
            return ResponseSchema
        
        def GetGamesVotes(self, universeIds: list) -> GameVoteResponseExtra:
            """
            Gets a list of universe vote status
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetGamesVotes(universeIds=array)
        
            Args:
                universeIds: list
            Returns:
                Games.GameVoteResponseExtra: Games.GameVoteResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"universeIds": universeIds},"headers": {},"cookies": {}}
            
            GetGamesVotesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/games/votes", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameVoteResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamesVotesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamesVotesRecivedData)
            
            return ResponseSchema
        
        def GetPrivateServers(self, privateServerIds: list) -> PrivateServersResponse:
            """
            Get private servers from private server ids
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetPrivateServers(privateServerIds=array)
        
            Args:
                privateServerIds: list
            Returns:
                Games.PrivateServersResponse: Games.PrivateServersResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"privateServerIds": privateServerIds},"headers": {},"cookies": {}}
            
            GetPrivateServersRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/private-servers", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.PrivateServersResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetPrivateServersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPrivateServersRecivedData)
            
            return ResponseSchema
        
        def GetPrivateServersEnabledInUniverseUniverseid(self, universeId: int) -> PrivateServersEnabledInUniverseResponse:
            """
            Checks if the private servers are enabled in the specified universe.
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetPrivateServersEnabledInUniverseUniverseid(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Games.PrivateServersEnabledInUniverseResponse: Games.PrivateServersEnabledInUniverseResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetPrivateServersEnabledInUniverseUniverseidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/private-servers/enabled-in-universe/{universeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.PrivateServersEnabledInUniverseResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetPrivateServersEnabledInUniverseUniverseidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPrivateServersEnabledInUniverseUniverseidRecivedData)
            
            return ResponseSchema
        
        def GetPrivateServersMyPrivateServers(self, privateServersTab: int, itemsPerPage: int, cursor: str) -> MyPrivateServersResponse:
            """
            Get private servers for the authenticated user
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetPrivateServersMyPrivateServers(privateServersTab=integer, itemsPerPage=integer, cursor=string)
        
            Args:
                privateServersTab: int
            itemsPerPage: int
            cursor: str
            Returns:
                Games.MyPrivateServersResponse: Games.MyPrivateServersResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"privateServersTab": privateServersTab, "itemsPerPage": itemsPerPage, "cursor": cursor},"headers": {},"cookies": {}}
            
            GetPrivateServersMyPrivateServersRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/private-servers/my-private-servers", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.MyPrivateServersResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetPrivateServersMyPrivateServersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPrivateServersMyPrivateServersRecivedData)
            
            return ResponseSchema
        
        def GetVipServerCanInviteUserid(self, userId: int) -> VipServerCanInviteResponse:
            """
            Determines if a user by id is allowed to receive a VIP Server invite from the authenticated user.
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetVipServerCanInviteUserid(userId=integer)
        
            Args:
                userId: int
            Returns:
                Games.VipServerCanInviteResponse: Games.VipServerCanInviteResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetVipServerCanInviteUseridRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/vip-server/can-invite/{userId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.VipServerCanInviteResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetVipServerCanInviteUseridRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetVipServerCanInviteUseridRecivedData)
            
            return ResponseSchema
        
        def GetVipServersId(self, id: int) -> VipServerResponse:
            """
            Get necessary data to generate webpage
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.GetVipServersId(id=integer)
        
            Args:
                id: int
            Returns:
                Games.VipServerResponse: Games.VipServerResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetVipServersIdRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Games.roblox.com/v1/vip-servers/{id}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.VipServerResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetVipServersIdRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetVipServersIdRecivedData)
            
            return ResponseSchema
        
        def PatchVipServersId(self, id: int, VipServerUpdateRequest: VipServerUpdateRequest) -> VipServerResponse:
            """
            Updates vip server
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.PatchVipServersId(id=integer, VipServerUpdateRequest=Games.VipServerUpdateRequest())
        
            Args:
                id: int
            VipServerUpdateRequest: VipServerUpdateRequest
            Returns:
                Games.VipServerResponse: Games.VipServerResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VipServerUpdateRequest': 'json'}
            Arguments = inspect.signature(self.PatchVipServersId)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchVipServersIdRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Games.roblox.com/v1/vip-servers/{id}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.VipServerResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchVipServersIdRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchVipServersIdRecivedData)
            
            return ResponseSchema
        
        def PostGamesVipServersUniverseid(self, universeId: int, CreateVipServersRequest: CreateVipServersRequest) -> GameServerResponse:
            """
            Create VIP server for a game
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.PostGamesVipServersUniverseid(universeId=integer, CreateVipServersRequest=Games.CreateVipServersRequest())
        
            Args:
                universeId: int
            CreateVipServersRequest: CreateVipServersRequest
            Returns:
                Games.GameServerResponse: Games.GameServerResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'CreateVipServersRequest': 'json'}
            Arguments = inspect.signature(self.PostGamesVipServersUniverseid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGamesVipServersUniverseidRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Games.roblox.com/v1/games/vip-servers/{universeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.GameServerResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostGamesVipServersUniverseidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGamesVipServersUniverseidRecivedData)
            
            return ResponseSchema
        
        def PatchGamesUniverseidUserVotes(self, universeId: int, SetUserGameVoteRequest: SetUserGameVoteRequest) -> ApiEmptyResponseModel:
            """
            Set the user's vote for a game
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.PatchGamesUniverseidUserVotes(universeId=integer, SetUserGameVoteRequest=Games.SetUserGameVoteRequest())
        
            Args:
                universeId: int
            SetUserGameVoteRequest: SetUserGameVoteRequest
            Returns:
                Games.ApiEmptyResponseModel: Games.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SetUserGameVoteRequest': 'json'}
            Arguments = inspect.signature(self.PatchGamesUniverseidUserVotes)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGamesUniverseidUserVotesRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Games.roblox.com/v1/games/{universeId}/user-votes", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGamesUniverseidUserVotesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGamesUniverseidUserVotesRecivedData)
            
            return ResponseSchema
        
        def PatchVipServersIdPermissions(self, id: int, VipServerUpdatePermissionsRequest: VipServerUpdatePermissionsRequest) -> VipServerPermissionsResponse:
            """
            Update friend/clan access and allowed friends/clan list
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.PatchVipServersIdPermissions(id=integer, VipServerUpdatePermissionsRequest=Games.VipServerUpdatePermissionsRequest())
        
            Args:
                id: int
            VipServerUpdatePermissionsRequest: VipServerUpdatePermissionsRequest
            Returns:
                Games.VipServerPermissionsResponse: Games.VipServerPermissionsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VipServerUpdatePermissionsRequest': 'json'}
            Arguments = inspect.signature(self.PatchVipServersIdPermissions)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchVipServersIdPermissionsRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Games.roblox.com/v1/vip-servers/{id}/permissions", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.VipServerPermissionsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchVipServersIdPermissionsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchVipServersIdPermissionsRecivedData)
            
            return ResponseSchema
        
        def PatchVipServersIdSubscription(self, id: int, VipServerUpdateSubscriptionRequest: VipServerUpdateSubscriptionRequest) -> VipServerSubscriptionResponse:
            """
            Updates subscription status of a vip server
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.PatchVipServersIdSubscription(id=integer, VipServerUpdateSubscriptionRequest=Games.VipServerUpdateSubscriptionRequest())
        
            Args:
                id: int
            VipServerUpdateSubscriptionRequest: VipServerUpdateSubscriptionRequest
            Returns:
                Games.VipServerSubscriptionResponse: Games.VipServerSubscriptionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VipServerUpdateSubscriptionRequest': 'json'}
            Arguments = inspect.signature(self.PatchVipServersIdSubscription)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchVipServersIdSubscriptionRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Games.roblox.com/v1/vip-servers/{id}/subscription", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.VipServerSubscriptionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchVipServersIdSubscriptionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchVipServersIdSubscriptionRecivedData)
            
            return ResponseSchema
        
        def PatchVipServersIdVoicesettings(self, id: int, VipServerUpdateVoiceSettingsRequest: VipServerUpdateVoiceSettingsRequest) -> VipServerVoiceSettingsResponse:
            """
            Update voice settings for a private server.
            
            Usage:
                import Games
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GamesApi = Games.GamesApi(RobloxClient=RobloxClient)
                Response = GamesApi.PatchVipServersIdVoicesettings(id=integer, VipServerUpdateVoiceSettingsRequest=Games.VipServerUpdateVoiceSettingsRequest())
        
            Args:
                id: int
            VipServerUpdateVoiceSettingsRequest: VipServerUpdateVoiceSettingsRequest
            Returns:
                Games.VipServerVoiceSettingsResponse: Games.VipServerVoiceSettingsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VipServerUpdateVoiceSettingsRequest': 'json'}
            Arguments = inspect.signature(self.PatchVipServersIdVoicesettings)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchVipServersIdVoicesettingsRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Games.roblox.com/v1/vip-servers/{id}/voicesettings", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Games.VipServerVoiceSettingsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchVipServersIdVoicesettingsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchVipServersIdVoicesettingsRecivedData)
            
            return ResponseSchema
        
    class GameJoin:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class GameJoinRequest:
            def __init__(ClassObject, isoContext: str = None, eventId: str = None, gameJoinAttemptId: str = None, placeId: int = None, gamerTag: str = None, isPlayTogetherGame: bool = None, browserTrackerId: int = None, isTeleport: bool = None, isQueueAllowedOverride: bool = None, isImmersiveAdsTeleport: bool = None, channelName: str = None, joinOrigin: str = None, partyId: str = None):
                ClassObject.isoContext = isoContext
                ClassObject.eventId = eventId
                ClassObject.gameJoinAttemptId = gameJoinAttemptId
                ClassObject.placeId = placeId
                ClassObject.gamerTag = gamerTag
                ClassObject.isPlayTogetherGame = isPlayTogetherGame
                ClassObject.browserTrackerId = browserTrackerId
                ClassObject.isTeleport = isTeleport
                ClassObject.isQueueAllowedOverride = isQueueAllowedOverride
                ClassObject.isImmersiveAdsTeleport = isImmersiveAdsTeleport
                ClassObject.channelName = channelName
                ClassObject.joinOrigin = joinOrigin
                ClassObject.partyId = partyId
                ClassObject.response: requests.Response = None


        class CreatorExperienceBanData:
            def __init__(ClassObject, startTime: str = None, durationSeconds: int = None, displayReason: str = None, displayReasonTextFilterStatus: int = None, isInherited: bool = None):
                ClassObject.startTime = startTime
                ClassObject.durationSeconds = durationSeconds
                ClassObject.displayReason = displayReason
                ClassObject.displayReasonTextFilterStatus = displayReasonTextFilterStatus
                ClassObject.isInherited = isInherited
                ClassObject.response: requests.Response = None


        class StatusData:
            def __init__(ClassObject, creatorExperienceBan: "RobloxClient.GameJoin.CreatorExperienceBanData" = None):
                ClassObject.creatorExperienceBan = creatorExperienceBan
                ClassObject.response: requests.Response = None


        class ServerConnection:
            def __init__(ClassObject, Address: str = None, Port: int = None):
                ClassObject.Address = Address
                ClassObject.Port = Port
                ClassObject.response: requests.Response = None


        class UdmuxEndpoint:
            def __init__(ClassObject, Address: str = None, Port: int = None):
                ClassObject.Address = Address
                ClassObject.Port = Port
                ClassObject.response: requests.Response = None


        class JoinInformation:
            def __init__(ClassObject, ClientPort: int = None, MachineAddress: str = None, ServerPort: int = None, ServerConnections: list["RobloxClient.GameJoin.ServerConnection"] = None, UdmuxEndpoints: list["RobloxClient.GameJoin.UdmuxEndpoint"] = None, DirectServerReturn: bool = None, TokenGenAlgorithm: int = None, PepperId: int = None, TokenValue: str = None, PingUrl: str = None, PingInterval: int = None, UserName: str = None, DisplayName: str = None, HasVerifiedBadge: bool = None, SeleniumTestMode: bool = None, UserId: int = None, RobloxLocale: str = None, GameLocale: str = None, SuperSafeChat: bool = None, FlexibleChatEnabled: bool = None, CharacterAppearance: str = None, ClientTicket: str = None, GameId: str = None, PlaceId: int = None, BaseUrl: str = None, ChatStyle: str = None, CreatorId: int = None, CreatorTypeEnum: str = None, MembershipType: str = None, AccountAge: int = None, CookieStoreFirstTimePlayKey: str = None, CookieStoreFiveMinutePlayKey: str = None, CookieStoreEnabled: bool = None, IsUnknownOrUnder13: bool = None, GameChatType: str = None, SessionId: str = None, AnalyticsSessionId: str = None, DataCenterId: int = None, UniverseId: int = None, FollowUserId: int = None, characterAppearanceId: int = None, CountryCode: str = None, AlternateName: str = None, RandomSeed1: str = None, ClientPublicKeyData: str = None, RccVersion: str = None, ChannelName: str = None, VerifiedAMP: int = None, PrivateServerOwnerID: int = None, PrivateServerID: str = None, EventID: str = None, EphemeralEarlyPubKey: str = None, PartyId: str = None):
                ClassObject.ClientPort = ClientPort
                ClassObject.MachineAddress = MachineAddress
                ClassObject.ServerPort = ServerPort
                ClassObject.ServerConnections = ServerConnections
                ClassObject.UdmuxEndpoints = UdmuxEndpoints
                ClassObject.DirectServerReturn = DirectServerReturn
                ClassObject.TokenGenAlgorithm = TokenGenAlgorithm
                ClassObject.PepperId = PepperId
                ClassObject.TokenValue = TokenValue
                ClassObject.PingUrl = PingUrl
                ClassObject.PingInterval = PingInterval
                ClassObject.UserName = UserName
                ClassObject.DisplayName = DisplayName
                ClassObject.HasVerifiedBadge = HasVerifiedBadge
                ClassObject.SeleniumTestMode = SeleniumTestMode
                ClassObject.UserId = UserId
                ClassObject.RobloxLocale = RobloxLocale
                ClassObject.GameLocale = GameLocale
                ClassObject.SuperSafeChat = SuperSafeChat
                ClassObject.FlexibleChatEnabled = FlexibleChatEnabled
                ClassObject.CharacterAppearance = CharacterAppearance
                ClassObject.ClientTicket = ClientTicket
                ClassObject.GameId = GameId
                ClassObject.PlaceId = PlaceId
                ClassObject.BaseUrl = BaseUrl
                ClassObject.ChatStyle = ChatStyle
                ClassObject.CreatorId = CreatorId
                ClassObject.CreatorTypeEnum = CreatorTypeEnum
                ClassObject.MembershipType = MembershipType
                ClassObject.AccountAge = AccountAge
                ClassObject.CookieStoreFirstTimePlayKey = CookieStoreFirstTimePlayKey
                ClassObject.CookieStoreFiveMinutePlayKey = CookieStoreFiveMinutePlayKey
                ClassObject.CookieStoreEnabled = CookieStoreEnabled
                ClassObject.IsUnknownOrUnder13 = IsUnknownOrUnder13
                ClassObject.GameChatType = GameChatType
                ClassObject.SessionId = SessionId
                ClassObject.AnalyticsSessionId = AnalyticsSessionId
                ClassObject.DataCenterId = DataCenterId
                ClassObject.UniverseId = UniverseId
                ClassObject.FollowUserId = FollowUserId
                ClassObject.characterAppearanceId = characterAppearanceId
                ClassObject.CountryCode = CountryCode
                ClassObject.AlternateName = AlternateName
                ClassObject.RandomSeed1 = RandomSeed1
                ClassObject.ClientPublicKeyData = ClientPublicKeyData
                ClassObject.RccVersion = RccVersion
                ClassObject.ChannelName = ChannelName
                ClassObject.VerifiedAMP = VerifiedAMP
                ClassObject.PrivateServerOwnerID = PrivateServerOwnerID
                ClassObject.PrivateServerID = PrivateServerID
                ClassObject.EventID = EventID
                ClassObject.EphemeralEarlyPubKey = EphemeralEarlyPubKey
                ClassObject.PartyId = PartyId
                ClassObject.response: requests.Response = None


        class GameJoinResponse:
            def __init__(ClassObject, jobId: str = None, status: int = None, statusData: "RobloxClient.GameJoin.StatusData" = None, joinScriptUrl: str = None, authenticationUrl: str = None, authenticationTicket: str = None, message: str = None, joinScript: "RobloxClient.GameJoin.JoinInformation" = None, queuePosition: int = None):
                ClassObject.jobId = jobId
                ClassObject.status = status
                ClassObject.statusData = statusData
                ClassObject.joinScriptUrl = joinScriptUrl
                ClassObject.authenticationUrl = authenticationUrl
                ClassObject.authenticationTicket = authenticationTicket
                ClassObject.message = message
                ClassObject.joinScript = joinScript
                ClassObject.queuePosition = queuePosition
                ClassObject.response: requests.Response = None


        class JoinGameInstanceRequest:
            def __init__(ClassObject, gameId: str = None, cId: str = None, gameJoinAttemptId: str = None, placeId: int = None, gamerTag: str = None, isPlayTogetherGame: bool = None, browserTrackerId: int = None, isTeleport: bool = None, isQueueAllowedOverride: bool = None, isImmersiveAdsTeleport: bool = None, channelName: str = None, joinOrigin: str = None, partyId: str = None):
                ClassObject.gameId = gameId
                ClassObject.cId = cId
                ClassObject.gameJoinAttemptId = gameJoinAttemptId
                ClassObject.placeId = placeId
                ClassObject.gamerTag = gamerTag
                ClassObject.isPlayTogetherGame = isPlayTogetherGame
                ClassObject.browserTrackerId = browserTrackerId
                ClassObject.isTeleport = isTeleport
                ClassObject.isQueueAllowedOverride = isQueueAllowedOverride
                ClassObject.isImmersiveAdsTeleport = isImmersiveAdsTeleport
                ClassObject.channelName = channelName
                ClassObject.joinOrigin = joinOrigin
                ClassObject.partyId = partyId
                ClassObject.response: requests.Response = None


        class JoinPlayTogetherGameRequest:
            def __init__(ClassObject, conversationId: int = None, gameJoinAttemptId: str = None, placeId: int = None, gamerTag: str = None, isPlayTogetherGame: bool = None, browserTrackerId: int = None, isTeleport: bool = None, isQueueAllowedOverride: bool = None, isImmersiveAdsTeleport: bool = None, channelName: str = None, joinOrigin: str = None, partyId: str = None):
                ClassObject.conversationId = conversationId
                ClassObject.gameJoinAttemptId = gameJoinAttemptId
                ClassObject.placeId = placeId
                ClassObject.gamerTag = gamerTag
                ClassObject.isPlayTogetherGame = isPlayTogetherGame
                ClassObject.browserTrackerId = browserTrackerId
                ClassObject.isTeleport = isTeleport
                ClassObject.isQueueAllowedOverride = isQueueAllowedOverride
                ClassObject.isImmersiveAdsTeleport = isImmersiveAdsTeleport
                ClassObject.channelName = channelName
                ClassObject.joinOrigin = joinOrigin
                ClassObject.partyId = partyId
                ClassObject.response: requests.Response = None


        class JoinPrivateGameRequest:
            def __init__(ClassObject, accessCode: str = None, linkCode: str = None, gameJoinAttemptId: str = None, placeId: int = None, gamerTag: str = None, isPlayTogetherGame: bool = None, browserTrackerId: int = None, isTeleport: bool = None, isQueueAllowedOverride: bool = None, isImmersiveAdsTeleport: bool = None, channelName: str = None, joinOrigin: str = None, partyId: str = None):
                ClassObject.accessCode = accessCode
                ClassObject.linkCode = linkCode
                ClassObject.gameJoinAttemptId = gameJoinAttemptId
                ClassObject.placeId = placeId
                ClassObject.gamerTag = gamerTag
                ClassObject.isPlayTogetherGame = isPlayTogetherGame
                ClassObject.browserTrackerId = browserTrackerId
                ClassObject.isTeleport = isTeleport
                ClassObject.isQueueAllowedOverride = isQueueAllowedOverride
                ClassObject.isImmersiveAdsTeleport = isImmersiveAdsTeleport
                ClassObject.channelName = channelName
                ClassObject.joinOrigin = joinOrigin
                ClassObject.partyId = partyId
                ClassObject.response: requests.Response = None


        class JoinReservedGameRequest:
            def __init__(ClassObject, accessCode: str = None, cId: str = None, gameJoinAttemptId: str = None, placeId: int = None, gamerTag: str = None, isPlayTogetherGame: bool = None, browserTrackerId: int = None, isTeleport: bool = None, isQueueAllowedOverride: bool = None, isImmersiveAdsTeleport: bool = None, channelName: str = None, joinOrigin: str = None, partyId: str = None):
                ClassObject.accessCode = accessCode
                ClassObject.cId = cId
                ClassObject.gameJoinAttemptId = gameJoinAttemptId
                ClassObject.placeId = placeId
                ClassObject.gamerTag = gamerTag
                ClassObject.isPlayTogetherGame = isPlayTogetherGame
                ClassObject.browserTrackerId = browserTrackerId
                ClassObject.isTeleport = isTeleport
                ClassObject.isQueueAllowedOverride = isQueueAllowedOverride
                ClassObject.isImmersiveAdsTeleport = isImmersiveAdsTeleport
                ClassObject.channelName = channelName
                ClassObject.joinOrigin = joinOrigin
                ClassObject.partyId = partyId
                ClassObject.response: requests.Response = None


        class PlayWithUserRequest:
            def __init__(ClassObject, userIdToFollow: int = None, gameJoinAttemptId: str = None, placeId: int = None, gamerTag: str = None, isPlayTogetherGame: bool = None, browserTrackerId: int = None, isTeleport: bool = None, isQueueAllowedOverride: bool = None, isImmersiveAdsTeleport: bool = None, channelName: str = None, joinOrigin: str = None, partyId: str = None):
                ClassObject.userIdToFollow = userIdToFollow
                ClassObject.gameJoinAttemptId = gameJoinAttemptId
                ClassObject.placeId = placeId
                ClassObject.gamerTag = gamerTag
                ClassObject.isPlayTogetherGame = isPlayTogetherGame
                ClassObject.browserTrackerId = browserTrackerId
                ClassObject.isTeleport = isTeleport
                ClassObject.isQueueAllowedOverride = isQueueAllowedOverride
                ClassObject.isImmersiveAdsTeleport = isImmersiveAdsTeleport
                ClassObject.channelName = channelName
                ClassObject.joinOrigin = joinOrigin
                ClassObject.partyId = partyId
                ClassObject.response: requests.Response = None


        class TeamCreateRequest:
            def __init__(ClassObject, gameJoinAttemptId: str = None, placeId: int = None, gamerTag: str = None, isPlayTogetherGame: bool = None, browserTrackerId: int = None, isTeleport: bool = None, isQueueAllowedOverride: bool = None, isImmersiveAdsTeleport: bool = None, channelName: str = None, joinOrigin: str = None, partyId: str = None):
                ClassObject.gameJoinAttemptId = gameJoinAttemptId
                ClassObject.placeId = placeId
                ClassObject.gamerTag = gamerTag
                ClassObject.isPlayTogetherGame = isPlayTogetherGame
                ClassObject.browserTrackerId = browserTrackerId
                ClassObject.isTeleport = isTeleport
                ClassObject.isQueueAllowedOverride = isQueueAllowedOverride
                ClassObject.isImmersiveAdsTeleport = isImmersiveAdsTeleport
                ClassObject.channelName = channelName
                ClassObject.joinOrigin = joinOrigin
                ClassObject.partyId = partyId
                ClassObject.response: requests.Response = None


        class TeamCreateResponse:
            def __init__(ClassObject, status: int = None, message: str = None, settings: dict = None):
                ClassObject.status = status
                ClassObject.message = message
                ClassObject.settings = settings
                ClassObject.response: requests.Response = None



        
        def PostJoinGame(self, GameJoinRequest: GameJoinRequest) -> GameJoinResponse:
            """
            Endpoint to join a game
            
            Usage:
                import GameJoin
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameJoinApi = GameJoin.GameJoinApi(RobloxClient=RobloxClient)
                Response = GameJoinApi.PostJoinGame(GameJoinRequest=GameJoin.GameJoinRequest())
        
            Args:
                GameJoinRequest: GameJoinRequest
            Returns:
                GameJoin.GameJoinResponse: GameJoin.GameJoinResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'GameJoinRequest': 'json'}
            Arguments = inspect.signature(self.PostJoinGame)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostJoinGameRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameJoin.roblox.com/v1/join-game", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameJoin.GameJoinResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostJoinGameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostJoinGameRecivedData)
            
            return ResponseSchema
        
        def PostJoinGameInstance(self, JoinGameInstanceRequest: JoinGameInstanceRequest) -> GameJoinResponse:
            """
            Endpoint to join a particular game instance
            
            Usage:
                import GameJoin
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameJoinApi = GameJoin.GameJoinApi(RobloxClient=RobloxClient)
                Response = GameJoinApi.PostJoinGameInstance(JoinGameInstanceRequest=GameJoin.JoinGameInstanceRequest())
        
            Args:
                JoinGameInstanceRequest: JoinGameInstanceRequest
            Returns:
                GameJoin.GameJoinResponse: GameJoin.GameJoinResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'JoinGameInstanceRequest': 'json'}
            Arguments = inspect.signature(self.PostJoinGameInstance)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostJoinGameInstanceRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameJoin.roblox.com/v1/join-game-instance", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameJoin.GameJoinResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostJoinGameInstanceRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostJoinGameInstanceRecivedData)
            
            return ResponseSchema
        
        def PostJoinPlayTogetherGame(self, JoinPlayTogetherGameRequest: JoinPlayTogetherGameRequest) -> GameJoinResponse:
            """
            Endpoint to join play together game
            
            Usage:
                import GameJoin
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameJoinApi = GameJoin.GameJoinApi(RobloxClient=RobloxClient)
                Response = GameJoinApi.PostJoinPlayTogetherGame(JoinPlayTogetherGameRequest=GameJoin.JoinPlayTogetherGameRequest())
        
            Args:
                JoinPlayTogetherGameRequest: JoinPlayTogetherGameRequest
            Returns:
                GameJoin.GameJoinResponse: GameJoin.GameJoinResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'JoinPlayTogetherGameRequest': 'json'}
            Arguments = inspect.signature(self.PostJoinPlayTogetherGame)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostJoinPlayTogetherGameRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameJoin.roblox.com/v1/join-play-together-game", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameJoin.GameJoinResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostJoinPlayTogetherGameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostJoinPlayTogetherGameRecivedData)
            
            return ResponseSchema
        
        def PostJoinPrivateGame(self, JoinPrivateGameRequest: JoinPrivateGameRequest) -> GameJoinResponse:
            """
            Endpoint to join a private game
            
            Usage:
                import GameJoin
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameJoinApi = GameJoin.GameJoinApi(RobloxClient=RobloxClient)
                Response = GameJoinApi.PostJoinPrivateGame(JoinPrivateGameRequest=GameJoin.JoinPrivateGameRequest())
        
            Args:
                JoinPrivateGameRequest: JoinPrivateGameRequest
            Returns:
                GameJoin.GameJoinResponse: GameJoin.GameJoinResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'JoinPrivateGameRequest': 'json'}
            Arguments = inspect.signature(self.PostJoinPrivateGame)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostJoinPrivateGameRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameJoin.roblox.com/v1/join-private-game", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameJoin.GameJoinResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostJoinPrivateGameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostJoinPrivateGameRecivedData)
            
            return ResponseSchema
        
        def PostJoinReservedGame(self, JoinReservedGameRequest: JoinReservedGameRequest) -> GameJoinResponse:
            """
            Endpoint to join a reserved game
            
            Usage:
                import GameJoin
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameJoinApi = GameJoin.GameJoinApi(RobloxClient=RobloxClient)
                Response = GameJoinApi.PostJoinReservedGame(JoinReservedGameRequest=GameJoin.JoinReservedGameRequest())
        
            Args:
                JoinReservedGameRequest: JoinReservedGameRequest
            Returns:
                GameJoin.GameJoinResponse: GameJoin.GameJoinResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'JoinReservedGameRequest': 'json'}
            Arguments = inspect.signature(self.PostJoinReservedGame)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostJoinReservedGameRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameJoin.roblox.com/v1/join-reserved-game", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameJoin.GameJoinResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostJoinReservedGameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostJoinReservedGameRecivedData)
            
            return ResponseSchema
        
        def PostPlayWithUser(self, PlayWithUserRequest: PlayWithUserRequest) -> GameJoinResponse:
            """
            Endpoint to play with user
            
            Usage:
                import GameJoin
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameJoinApi = GameJoin.GameJoinApi(RobloxClient=RobloxClient)
                Response = GameJoinApi.PostPlayWithUser(PlayWithUserRequest=GameJoin.PlayWithUserRequest())
        
            Args:
                PlayWithUserRequest: PlayWithUserRequest
            Returns:
                GameJoin.GameJoinResponse: GameJoin.GameJoinResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PlayWithUserRequest': 'json'}
            Arguments = inspect.signature(self.PostPlayWithUser)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPlayWithUserRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameJoin.roblox.com/v1/play-with-user", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameJoin.GameJoinResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostPlayWithUserRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPlayWithUserRecivedData)
            
            return ResponseSchema
        
        def PostTeamCreate(self, TeamCreateRequest: TeamCreateRequest) -> TeamCreateResponse:
            """
            Endpoint to join team create session
            
            Usage:
                import GameJoin
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameJoinApi = GameJoin.GameJoinApi(RobloxClient=RobloxClient)
                Response = GameJoinApi.PostTeamCreate(TeamCreateRequest=GameJoin.TeamCreateRequest())
        
            Args:
                TeamCreateRequest: TeamCreateRequest
            Returns:
                GameJoin.TeamCreateResponse: GameJoin.TeamCreateResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'TeamCreateRequest': 'json'}
            Arguments = inspect.signature(self.PostTeamCreate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostTeamCreateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameJoin.roblox.com/v1/team-create", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameJoin.TeamCreateResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostTeamCreateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTeamCreateRecivedData)
            
            return ResponseSchema
        
        def PostTeamCreatePreemptive(self, TeamCreateRequest: TeamCreateRequest) -> TeamCreateResponse:
            """
            Endpoint to preemptively start team create session.
            
            Usage:
                import GameJoin
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameJoinApi = GameJoin.GameJoinApi(RobloxClient=RobloxClient)
                Response = GameJoinApi.PostTeamCreatePreemptive(TeamCreateRequest=GameJoin.TeamCreateRequest())
        
            Args:
                TeamCreateRequest: TeamCreateRequest
            Returns:
                GameJoin.TeamCreateResponse: GameJoin.TeamCreateResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'TeamCreateRequest': 'json'}
            Arguments = inspect.signature(self.PostTeamCreatePreemptive)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostTeamCreatePreemptiveRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameJoin.roblox.com/v1/team-create-preemptive", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameJoin.TeamCreateResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostTeamCreatePreemptiveRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTeamCreatePreemptiveRecivedData)
            
            return ResponseSchema
        
    class GameInternationalization:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class LocalizationTableGameAssociation:
            def __init__(ClassObject, id: str = None, dissociate: bool = None):
                ClassObject.id = id
                ClassObject.dissociate = dissociate
                ClassObject.response: requests.Response = None


        class AssociateLocalizationTablesToGameRequest:
            def __init__(ClassObject, tables: list["RobloxClient.GameInternationalization.LocalizationTableGameAssociation"] = None):
                ClassObject.tables = tables
                ClassObject.response: requests.Response = None


        class AssociateLocalizationTablesToGameResponse:
            def __init__(ClassObject, success: bool = None):
                ClassObject.success = success
                ClassObject.response: requests.Response = None


        class AutoLocalizationMetadataResponse:
            def __init__(ClassObject, isReactVersionEnabledForAutoLocalizationSettings: bool = None, isTabbedUIEnabledForConfigureLocalizationPage: bool = None, isAutomaticTranslationToggleUIEnabled: bool = None, isAutomaticTranslationQuotaUIEnabled: bool = None):
                ClassObject.isReactVersionEnabledForAutoLocalizationSettings = isReactVersionEnabledForAutoLocalizationSettings
                ClassObject.isTabbedUIEnabledForConfigureLocalizationPage = isTabbedUIEnabledForConfigureLocalizationPage
                ClassObject.isAutomaticTranslationToggleUIEnabled = isAutomaticTranslationToggleUIEnabled
                ClassObject.isAutomaticTranslationQuotaUIEnabled = isAutomaticTranslationQuotaUIEnabled
                ClassObject.response: requests.Response = None


        class AutomaticTranslationStatusTargetLanguage:
            def __init__(ClassObject, languageCode: str = None, isAutomaticTranslationAllowed: bool = None):
                ClassObject.languageCode = languageCode
                ClassObject.isAutomaticTranslationAllowed = isAutomaticTranslationAllowed
                ClassObject.response: requests.Response = None


        class EditAutomaticTranslationStatusForGameAndLanguageResponse:
            def __init__(ClassObject, gameId: int = None, languageCode: str = None, isAutomaticTranslationEnabled: bool = None):
                ClassObject.gameId = gameId
                ClassObject.languageCode = languageCode
                ClassObject.isAutomaticTranslationEnabled = isAutomaticTranslationEnabled
                ClassObject.response: requests.Response = None


        class FailedNameDescription:
            def __init__(ClassObject, languageCode: str = None, errorCode: int = None):
                ClassObject.languageCode = languageCode
                ClassObject.errorCode = errorCode
                ClassObject.response: requests.Response = None


        class GameAutolocalizationInformationResponse:
            def __init__(ClassObject, isAutolocalizationEnabled: bool = None, shouldUseLocalizationTable: bool = None, autoLocalizationTableId: str = None, assetId: int = None):
                ClassObject.isAutolocalizationEnabled = isAutolocalizationEnabled
                ClassObject.shouldUseLocalizationTable = shouldUseLocalizationTable
                ClassObject.autoLocalizationTableId = autoLocalizationTableId
                ClassObject.assetId = assetId
                ClassObject.response: requests.Response = None


        class GetAllowedAutomaticTranslationStatusForLanguagesResponse:
            def __init__(ClassObject, sourceLanguage: str = None, targetLanguages: list["RobloxClient.GameInternationalization.AutomaticTranslationStatusTargetLanguage"] = None):
                ClassObject.sourceLanguage = sourceLanguage
                ClassObject.targetLanguages = targetLanguages
                ClassObject.response: requests.Response = None


        class GetAutomaticTranslationFeatureStatusForGameResponse:
            def __init__(ClassObject, gameId: int = None, isAutomaticTranslationAllowed: bool = None, isAutomaticTranslationSwitchesUIEnabled: bool = None):
                ClassObject.gameId = gameId
                ClassObject.isAutomaticTranslationAllowed = isAutomaticTranslationAllowed
                ClassObject.isAutomaticTranslationSwitchesUIEnabled = isAutomaticTranslationSwitchesUIEnabled
                ClassObject.response: requests.Response = None


        class MonthlyQuotaModel:
            def __init__(ClassObject, previousRefreshDate: str = None, nextRefreshDate: str = None, remaining: int = None, capacity: int = None):
                ClassObject.previousRefreshDate = previousRefreshDate
                ClassObject.nextRefreshDate = nextRefreshDate
                ClassObject.remaining = remaining
                ClassObject.capacity = capacity
                ClassObject.response: requests.Response = None


        class QuotaModel:
            def __init__(ClassObject, remaining: int = None, capacity: int = None):
                ClassObject.remaining = remaining
                ClassObject.capacity = capacity
                ClassObject.response: requests.Response = None


        class GetAutomaticTranslationQuotaForGameResponse:
            def __init__(ClassObject, monthlyQuota: "RobloxClient.GameInternationalization.MonthlyQuotaModel" = None, bankQuota: "RobloxClient.GameInternationalization.QuotaModel" = None):
                ClassObject.monthlyQuota = monthlyQuota
                ClassObject.bankQuota = bankQuota
                ClassObject.response: requests.Response = None


        class GetBadgeIconResponse:
            def __init__(ClassObject, imageId: str = None, imageUrl: str = None, state: enum.Enum = None, languageCode: str = None):
                ClassObject.imageId = imageId
                ClassObject.imageUrl = imageUrl
                ClassObject.state = state
                ClassObject.languageCode = languageCode
                ClassObject.response: requests.Response = None


        class GetDeveloperProductIconResponse:
            def __init__(ClassObject, imageId: str = None, imageUrl: str = None, state: enum.Enum = None, languageCode: str = None):
                ClassObject.imageId = imageId
                ClassObject.imageUrl = imageUrl
                ClassObject.state = state
                ClassObject.languageCode = languageCode
                ClassObject.response: requests.Response = None


        class GetGameIconResponse:
            def __init__(ClassObject, imageId: str = None, imageUrl: str = None, state: enum.Enum = None, languageCode: str = None):
                ClassObject.imageId = imageId
                ClassObject.imageUrl = imageUrl
                ClassObject.state = state
                ClassObject.languageCode = languageCode
                ClassObject.response: requests.Response = None


        class GetGamePassIconResponse:
            def __init__(ClassObject, imageId: str = None, imageUrl: str = None, state: enum.Enum = None, languageCode: str = None):
                ClassObject.imageId = imageId
                ClassObject.imageUrl = imageUrl
                ClassObject.state = state
                ClassObject.languageCode = languageCode
                ClassObject.response: requests.Response = None


        class MediaAssetResponse:
            def __init__(ClassObject, mediaAssetId: str = None, mediaAssetAltText: str = None, state: enum.Enum = None, mediaAssetUrl: str = None):
                ClassObject.mediaAssetId = mediaAssetId
                ClassObject.mediaAssetAltText = mediaAssetAltText
                ClassObject.state = state
                ClassObject.mediaAssetUrl = mediaAssetUrl
                ClassObject.response: requests.Response = None


        class GetGameThumbnailsResponse:
            def __init__(ClassObject, languageCode: str = None, mediaAssets: list["RobloxClient.GameInternationalization.MediaAssetResponse"] = None):
                ClassObject.languageCode = languageCode
                ClassObject.mediaAssets = mediaAssets
                ClassObject.response: requests.Response = None


        class GetNameDescriptionHistoryRequest:
            def __init__(ClassObject, requestType: enum.Enum = None, languageCode: str = None, cursor: str = None, count: int = None, sortOrder: enum.Enum = None):
                ClassObject.requestType = requestType
                ClassObject.languageCode = languageCode
                ClassObject.cursor = cursor
                ClassObject.count = count
                ClassObject.sortOrder = sortOrder
                ClassObject.response: requests.Response = None


        class Translator:
            def __init__(ClassObject, id: int = None, agentType: enum.Enum = None):
                ClassObject.id = id
                ClassObject.agentType = agentType
                ClassObject.response: requests.Response = None


        class TranslationHistory:
            def __init__(ClassObject, translationText: str = None, translator: "RobloxClient.GameInternationalization.Translator" = None, created: str = None):
                ClassObject.translationText = translationText
                ClassObject.translator = translator
                ClassObject.created = created
                ClassObject.response: requests.Response = None


        class GetNameDescriptionHistoryResponse:
            def __init__(ClassObject, history: list["RobloxClient.GameInternationalization.TranslationHistory"] = None, lastEvaluatedId: str = None):
                ClassObject.history = history
                ClassObject.lastEvaluatedId = lastEvaluatedId
                ClassObject.response: requests.Response = None


        class GetNameDescriptionHistoryV2Request:
            def __init__(ClassObject, contentId: int = None, contentType: enum.Enum = None, languageCode: str = None, cursor: str = None, count: int = None, sortOrder: enum.Enum = None):
                ClassObject.contentId = contentId
                ClassObject.contentType = contentType
                ClassObject.languageCode = languageCode
                ClassObject.cursor = cursor
                ClassObject.count = count
                ClassObject.sortOrder = sortOrder
                ClassObject.response: requests.Response = None


        class GetPlayerPoliciesResponse:
            def __init__(ClassObject, isSubjectToChinaPolicies: bool = None, arePaidRandomItemsRestricted: bool = None, isPaidItemTradingAllowed: bool = None, areAdsAllowed: bool = None, allowedExternalLinkReferences: list[str] = None):
                ClassObject.isSubjectToChinaPolicies = isSubjectToChinaPolicies
                ClassObject.arePaidRandomItemsRestricted = arePaidRandomItemsRestricted
                ClassObject.isPaidItemTradingAllowed = isPaidItemTradingAllowed
                ClassObject.areAdsAllowed = areAdsAllowed
                ClassObject.allowedExternalLinkReferences = allowedExternalLinkReferences
                ClassObject.response: requests.Response = None


        class TranslationCount:
            def __init__(ClassObject, count: int = None, translationStatus: enum.Enum = None, translatorType: enum.Enum = None):
                ClassObject.count = count
                ClassObject.translationStatus = translationStatus
                ClassObject.translatorType = translatorType
                ClassObject.response: requests.Response = None


        class TranslationCountCategoryInfoResponse:
            def __init__(ClassObject, category: enum.Enum = None, translationCounts: list["RobloxClient.GameInternationalization.TranslationCount"] = None, totalTranslatableItemCount: int = None):
                ClassObject.category = category
                ClassObject.translationCounts = translationCounts
                ClassObject.totalTranslatableItemCount = totalTranslatableItemCount
                ClassObject.response: requests.Response = None


        class TranslationCountLanguageOrLocaleResponse:
            def __init__(ClassObject, status: enum.Enum = None, categories: list["RobloxClient.GameInternationalization.TranslationCountCategoryInfoResponse"] = None, name: str = None, languageCodeType: enum.Enum = None, languageCode: str = None):
                ClassObject.status = status
                ClassObject.categories = categories
                ClassObject.name = name
                ClassObject.languageCodeType = languageCodeType
                ClassObject.languageCode = languageCode
                ClassObject.response: requests.Response = None


        class GetTranslationCountsForGameResponse:
            def __init__(ClassObject, gameId: int = None, languagesOrLocales: list["RobloxClient.GameInternationalization.TranslationCountLanguageOrLocaleResponse"] = None):
                ClassObject.gameId = gameId
                ClassObject.languagesOrLocales = languagesOrLocales
                ClassObject.response: requests.Response = None


        class TranslationCountGameInfoResponse:
            def __init__(ClassObject, gameId: int = None, status: enum.Enum = None, categories: list["RobloxClient.GameInternationalization.TranslationCountCategoryInfoResponse"] = None):
                ClassObject.gameId = gameId
                ClassObject.status = status
                ClassObject.categories = categories
                ClassObject.response: requests.Response = None


        class GetTranslationCountsForLanguageOrLocaleResponse:
            def __init__(ClassObject, languageOrLocaleCode: str = None, languageOrLocaleType: enum.Enum = None, games: list["RobloxClient.GameInternationalization.TranslationCountGameInfoResponse"] = None):
                ClassObject.languageOrLocaleCode = languageOrLocaleCode
                ClassObject.languageOrLocaleType = languageOrLocaleType
                ClassObject.games = games
                ClassObject.response: requests.Response = None


        class GetUiConfigurationsResponse:
            def __init__(ClassObject, isGameProductsEnabled: bool = None, isBadgeIconEnabled: bool = None, isGamePassEnabled: bool = None, isDeveloperProductEnabled: bool = None):
                ClassObject.isGameProductsEnabled = isGameProductsEnabled
                ClassObject.isBadgeIconEnabled = isBadgeIconEnabled
                ClassObject.isGamePassEnabled = isGamePassEnabled
                ClassObject.isDeveloperProductEnabled = isDeveloperProductEnabled
                ClassObject.response: requests.Response = None


        class Language:
            def __init__(ClassObject, name: str = None, nativeName: str = None, languageCode: str = None):
                ClassObject.name = name
                ClassObject.nativeName = nativeName
                ClassObject.languageCode = languageCode
                ClassObject.response: requests.Response = None


        class LanguageOrLocale:
            def __init__(ClassObject, name: str = None, languageCodeType: enum.Enum = None, languageCode: str = None):
                ClassObject.name = name
                ClassObject.languageCodeType = languageCodeType
                ClassObject.languageCode = languageCode
                ClassObject.response: requests.Response = None


        class LanguageOrLocaleSettings:
            def __init__(ClassObject, languageCodeType: enum.Enum = None, languageCode: str = None, isAutomaticTranslationEnabled: bool = None):
                ClassObject.languageCodeType = languageCodeType
                ClassObject.languageCode = languageCode
                ClassObject.isAutomaticTranslationEnabled = isAutomaticTranslationEnabled
                ClassObject.response: requests.Response = None


        class UserUniverseLocalizationSettingValue:
            def __init__(ClassObject, settingType: enum.Enum = None, settingTargetId: int = None):
                ClassObject.settingType = settingType
                ClassObject.settingTargetId = settingTargetId
                ClassObject.response: requests.Response = None


        class SetUserLocalizationSettingsRequest:
            def __init__(ClassObject, settingValue: "RobloxClient.GameInternationalization.UserUniverseLocalizationSettingValue" = None):
                ClassObject.settingValue = settingValue
                ClassObject.response: requests.Response = None


        class GameNameDescriptionMetadataResponse:
            def __init__(ClassObject, isNameDescriptionMigrationEnabled: bool = None):
                ClassObject.isNameDescriptionMigrationEnabled = isNameDescriptionMigrationEnabled
                ClassObject.response: requests.Response = None


        class GetUserLocalizationSettingsForUniverseResponse:
            def __init__(ClassObject, userUniverseLocalizationSettingValue: "RobloxClient.GameInternationalization.UserUniverseLocalizationSettingValue" = None):
                ClassObject.userUniverseLocalizationSettingValue = userUniverseLocalizationSettingValue
                ClassObject.response: requests.Response = None


        class SetUserLocalizationSettingsResponse:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class UploadImageForGameThumbnailResponse:
            def __init__(ClassObject, mediaAssetId: str = None):
                ClassObject.mediaAssetId = mediaAssetId
                ClassObject.response: requests.Response = None


        class NameDescription:
            def __init__(ClassObject, name: str = None, description: str = None, updateType: enum.Enum = None, languageCode: str = None):
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.updateType = updateType
                ClassObject.languageCode = languageCode
                ClassObject.response: requests.Response = None


        class PatchLanguage:
            def __init__(ClassObject, languageCodeType: enum.Enum = None, languageCode: str = None, delete: bool = None):
                ClassObject.languageCodeType = languageCodeType
                ClassObject.languageCode = languageCode
                ClassObject.delete = delete
                ClassObject.response: requests.Response = None


        class RequestTranslationAnalyticsReportRequest:
            def __init__(ClassObject, startDateTime: str = None, endDateTime: str = None, reportType: enum.Enum = None, reportSubjectTargetId: int = None):
                ClassObject.startDateTime = startDateTime
                ClassObject.endDateTime = endDateTime
                ClassObject.reportType = reportType
                ClassObject.reportSubjectTargetId = reportSubjectTargetId
                ClassObject.response: requests.Response = None


        class RequestTranslationAnalyticsReportResponse:
            def __init__(ClassObject, reportGenerationStatus: enum.Enum = None):
                ClassObject.reportGenerationStatus = reportGenerationStatus
                ClassObject.response: requests.Response = None


        class SetAutolocalizationSettingsForGameRequest:
            def __init__(ClassObject, isAutolocalizationEnabled: bool = None, shouldUseLocalizationTable: bool = None):
                ClassObject.isAutolocalizationEnabled = isAutolocalizationEnabled
                ClassObject.shouldUseLocalizationTable = shouldUseLocalizationTable
                ClassObject.response: requests.Response = None


        class SetAutolocalizationTableForGameRequest:
            def __init__(ClassObject, tableId: str = None):
                ClassObject.tableId = tableId
                ClassObject.response: requests.Response = None


        class SortImageIdsRequest:
            def __init__(ClassObject, mediaAssetIds: list[int] = None):
                ClassObject.mediaAssetIds = mediaAssetIds
                ClassObject.response: requests.Response = None


        class SupportedLanguagesMetadataResponse:
            def __init__(ClassObject, isFeatureEnabled: bool = None, areAllLanguagesEnabled: bool = None, minimumUniverseIdForFeature: int = None, isHumanTranslationProgressUIEnabled: bool = None, isAutomaticTranslationProgressUIEnabled: bool = None, isSupportedLanguagesChildLocalesUIEnabled: bool = None):
                ClassObject.isFeatureEnabled = isFeatureEnabled
                ClassObject.areAllLanguagesEnabled = areAllLanguagesEnabled
                ClassObject.minimumUniverseIdForFeature = minimumUniverseIdForFeature
                ClassObject.isHumanTranslationProgressUIEnabled = isHumanTranslationProgressUIEnabled
                ClassObject.isAutomaticTranslationProgressUIEnabled = isAutomaticTranslationProgressUIEnabled
                ClassObject.isSupportedLanguagesChildLocalesUIEnabled = isSupportedLanguagesChildLocalesUIEnabled
                ClassObject.response: requests.Response = None


        class TranslationAnalyticsMetadataResponse:
            def __init__(ClassObject, isFeatureEnabledOnUI: bool = None, reportRequestPollingIntervalSeconds: int = None, minimumDateTimeForAnalyticsReport: str = None):
                ClassObject.isFeatureEnabledOnUI = isFeatureEnabledOnUI
                ClassObject.reportRequestPollingIntervalSeconds = reportRequestPollingIntervalSeconds
                ClassObject.minimumDateTimeForAnalyticsReport = minimumDateTimeForAnalyticsReport
                ClassObject.response: requests.Response = None


        class UniverseDisplayInfoAutomaticTranslationSettings:
            def __init__(ClassObject, languageCode: str = None, isUniverseDisplayInfoAutomaticTranslationEnabled: bool = None):
                ClassObject.languageCode = languageCode
                ClassObject.isUniverseDisplayInfoAutomaticTranslationEnabled = isUniverseDisplayInfoAutomaticTranslationEnabled
                ClassObject.response: requests.Response = None


        class UpdateBadgeDescriptionRequest:
            def __init__(ClassObject, description: str = None):
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateBadgeDescriptionResponse:
            def __init__(ClassObject, description: str = None):
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateBadgeNameDescriptionRequest:
            def __init__(ClassObject, name: str = None, description: str = None):
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateBadgeNameDescriptionResponse:
            def __init__(ClassObject, name: str = None, description: str = None):
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateBadgeNameRequest:
            def __init__(ClassObject, name: str = None):
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class UpdateBadgeNameResponse:
            def __init__(ClassObject, name: str = None):
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class UpdateDeveloperProductDescriptionRequest:
            def __init__(ClassObject, description: str = None):
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateDeveloperProductDescriptionResponse:
            def __init__(ClassObject, description: str = None):
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateDeveloperProductNameDescriptionRequest:
            def __init__(ClassObject, name: str = None, description: str = None):
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateDeveloperProductNameDescriptionResponse:
            def __init__(ClassObject, name: str = None, description: str = None):
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateDeveloperProductNameRequest:
            def __init__(ClassObject, name: str = None):
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class UpdateDeveloperProductNameResponse:
            def __init__(ClassObject, name: str = None):
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class UpdateGamePassDescriptionRequest:
            def __init__(ClassObject, description: str = None):
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateGamePassDescriptionResponse:
            def __init__(ClassObject, description: str = None):
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateGamePassNameDescriptionRequest:
            def __init__(ClassObject, name: str = None, description: str = None):
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateGamePassNameDescriptionResponse:
            def __init__(ClassObject, name: str = None, description: str = None):
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class UpdateGamePassNameRequest:
            def __init__(ClassObject, name: str = None):
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class UpdateGamePassNameResponse:
            def __init__(ClassObject, name: str = None):
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class UpdateNameDescriptionsRequest:
            def __init__(ClassObject, data: list["RobloxClient.GameInternationalization.NameDescription"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class UpdateNameDescriptionsResponse:
            def __init__(ClassObject, successOperations: list["RobloxClient.GameInternationalization.NameDescription"] = None, failedOperations: list["RobloxClient.GameInternationalization.FailedNameDescription"] = None):
                ClassObject.successOperations = successOperations
                ClassObject.failedOperations = failedOperations
                ClassObject.response: requests.Response = None


        class UpdateThumbnailAltTextRequest:
            def __init__(ClassObject, thumbnailId: int = None, altText: str = None):
                ClassObject.thumbnailId = thumbnailId
                ClassObject.altText = altText
                ClassObject.response: requests.Response = None


        class UpdateUniverseDisplayInfoAutomaticTranslationSettingsResponse:
            def __init__(ClassObject, gameId: int = None, languageCode: str = None, isUniverseDisplayInfoAutomaticTranslationEnabled: bool = None):
                ClassObject.gameId = gameId
                ClassObject.languageCode = languageCode
                ClassObject.isUniverseDisplayInfoAutomaticTranslationEnabled = isUniverseDisplayInfoAutomaticTranslationEnabled
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class GetBadgeIconResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.GameInternationalization.GetBadgeIconResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GetDeveloperProductIconResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.GameInternationalization.GetDeveloperProductIconResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GetGameIconResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.GameInternationalization.GetGameIconResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GetGamePassIconResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.GameInternationalization.GetGamePassIconResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GetGameThumbnailsResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.GameInternationalization.GetGameThumbnailsResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class LanguageOrLocaleSettingsExtra:
            def __init__(ClassObject, data: list["RobloxClient.GameInternationalization.LanguageOrLocaleSettings"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class LanguageOrLocaleExtra:
            def __init__(ClassObject, data: list["RobloxClient.GameInternationalization.LanguageOrLocale"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class NameDescriptionExtra:
            def __init__(ClassObject, data: list["RobloxClient.GameInternationalization.NameDescription"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class UniverseDisplayInfoAutomaticTranslationSettingsExtra:
            def __init__(ClassObject, data: list["RobloxClient.GameInternationalization.UniverseDisplayInfoAutomaticTranslationSettings"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class Stream:
            def __init__(ClassObject, CanRead: bool = None, CanWrite: bool = None, CanSeek: bool = None, CanTimeout: bool = None, Length: int = None, Position: int = None, ReadTimeout: int = None, WriteTimeout: int = None):
                ClassObject.CanRead = CanRead
                ClassObject.CanWrite = CanWrite
                ClassObject.CanSeek = CanSeek
                ClassObject.CanTimeout = CanTimeout
                ClassObject.Length = Length
                ClassObject.Position = Position
                ClassObject.ReadTimeout = ReadTimeout
                ClassObject.WriteTimeout = WriteTimeout
                ClassObject.response: requests.Response = None


        class IUploadedFile:
            def __init__(ClassObject, Name: str = None, Stream: "RobloxClient.GameInternationalization.Stream" = None, ContentEncoding: enum.Enum = None):
                ClassObject.Name = Name
                ClassObject.Stream = Stream
                ClassObject.ContentEncoding = ContentEncoding
                ClassObject.response: requests.Response = None



        
        def GetAutolocalizationMetadata(self) -> AutoLocalizationMetadataResponse:
            """
            Metadata for AutoLocalization Configuration
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetAutolocalizationMetadata()
        
            Args:
                
            Returns:
                GameInternationalization.AutoLocalizationMetadataResponse: GameInternationalization.AutoLocalizationMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAutolocalizationMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/autolocalization/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.AutoLocalizationMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAutolocalizationMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAutolocalizationMetadataRecivedData)
            
            return ResponseSchema
        
        def GetAutomaticTranslationGamesGameidFeatureStatus(self, gameId: int) -> GetAutomaticTranslationFeatureStatusForGameResponse:
            """
            Checks if automatic translation can be enabled for a game.

The user must still have proper permissions for the game to get this info.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetAutomaticTranslationGamesGameidFeatureStatus(gameId=integer)
        
            Args:
                gameId: int
            Returns:
                GameInternationalization.GetAutomaticTranslationFeatureStatusForGameResponse: GameInternationalization.GetAutomaticTranslationFeatureStatusForGameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAutomaticTranslationGamesGameidFeatureStatusRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/automatic-translation/games/{gameId}/feature-status", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetAutomaticTranslationFeatureStatusForGameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAutomaticTranslationGamesGameidFeatureStatusRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAutomaticTranslationGamesGameidFeatureStatusRecivedData)
            
            return ResponseSchema
        
        def GetAutomaticTranslationGamesGameidQuota(self, gameId: int) -> GetAutomaticTranslationQuotaForGameResponse:
            """
            Returns the automatic translation quota info for a game.

The user must still have proper permissions for the game to get this info.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetAutomaticTranslationGamesGameidQuota(gameId=integer)
        
            Args:
                gameId: int
            Returns:
                GameInternationalization.GetAutomaticTranslationQuotaForGameResponse: GameInternationalization.GetAutomaticTranslationQuotaForGameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAutomaticTranslationGamesGameidQuotaRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/automatic-translation/games/{gameId}/quota", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetAutomaticTranslationQuotaForGameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAutomaticTranslationGamesGameidQuotaRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAutomaticTranslationGamesGameidQuotaRecivedData)
            
            return ResponseSchema
        
        def GetAutomaticTranslationLanguagesLanguagecodeTargetLanguages(self, targetLanguages: list, gameId: int, languageCode: str) -> GetAllowedAutomaticTranslationStatusForLanguagesResponse:
            """
            Checks if the requested target languages are allowed for automatic translation based on the source language.

If there are no requested target languages, then all allowed target languages for the source language will be returned.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetAutomaticTranslationLanguagesLanguagecodeTargetLanguages(targetLanguages=array, gameId=integer, languageCode=string)
        
            Args:
                targetLanguages: list
            gameId: int
            languageCode: str
            Returns:
                GameInternationalization.GetAllowedAutomaticTranslationStatusForLanguagesResponse: GameInternationalization.GetAllowedAutomaticTranslationStatusForLanguagesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"targetLanguages": targetLanguages, "gameId": gameId},"headers": {},"cookies": {}}
            
            GetAutomaticTranslationLanguagesLanguagecodeTargetLanguagesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/automatic-translation/languages/{languageCode}/target-languages", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetAllowedAutomaticTranslationStatusForLanguagesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAutomaticTranslationLanguagesLanguagecodeTargetLanguagesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAutomaticTranslationLanguagesLanguagecodeTargetLanguagesRecivedData)
            
            return ResponseSchema
        
        def GetBadgesBadgeidIcons(self, width: int, height: int, badgeId: int) -> GetBadgeIconResponseExtra:
            """
            Get all icons for a badge
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetBadgesBadgeidIcons(width=integer, height=integer, badgeId=integer)
        
            Args:
                width: int
            height: int
            badgeId: int
            Returns:
                GameInternationalization.GetBadgeIconResponseExtra: GameInternationalization.GetBadgeIconResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"width": width, "height": height},"headers": {},"cookies": {}}
            
            GetBadgesBadgeidIconsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/badges/{badgeId}/icons", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetBadgeIconResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetBadgesBadgeidIconsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetBadgesBadgeidIconsRecivedData)
            
            return ResponseSchema
        
        def GetBadgesBadgeidNameDescription(self, badgeId: int) -> NameDescriptionExtra:
            """
            Unknown
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetBadgesBadgeidNameDescription(badgeId=integer)
        
            Args:
                badgeId: int
            Returns:
                GameInternationalization.NameDescriptionExtra: GameInternationalization.NameDescriptionExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetBadgesBadgeidNameDescriptionRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/badges/{badgeId}/name-description", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.NameDescriptionExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetBadgesBadgeidNameDescriptionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetBadgesBadgeidNameDescriptionRecivedData)
            
            return ResponseSchema
        
        def GetDeveloperProductsDeveloperproductidIcons(self, width: int, height: int, developerProductId: int) -> GetDeveloperProductIconResponseExtra:
            """
            Get all icons for a developer product
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetDeveloperProductsDeveloperproductidIcons(width=integer, height=integer, developerProductId=integer)
        
            Args:
                width: int
            height: int
            developerProductId: int
            Returns:
                GameInternationalization.GetDeveloperProductIconResponseExtra: GameInternationalization.GetDeveloperProductIconResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"width": width, "height": height},"headers": {},"cookies": {}}
            
            GetDeveloperProductsDeveloperproductidIconsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/developer-products/{developerProductId}/icons", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetDeveloperProductIconResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetDeveloperProductsDeveloperproductidIconsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetDeveloperProductsDeveloperproductidIconsRecivedData)
            
            return ResponseSchema
        
        def GetDeveloperProductsDeveloperproductidNameDescription(self, developerProductId: int) -> NameDescriptionExtra:
            """
            Get all names and descriptions of a developer product
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetDeveloperProductsDeveloperproductidNameDescription(developerProductId=integer)
        
            Args:
                developerProductId: int
            Returns:
                GameInternationalization.NameDescriptionExtra: GameInternationalization.NameDescriptionExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetDeveloperProductsDeveloperproductidNameDescriptionRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/developer-products/{developerProductId}/name-description", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.NameDescriptionExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetDeveloperProductsDeveloperproductidNameDescriptionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetDeveloperProductsDeveloperproductidNameDescriptionRecivedData)
            
            return ResponseSchema
        
        def GetGameIconGamesGameid(self, width: int, height: int, gameId: int) -> GetGameIconResponseExtra:
            """
            Get all icons for a game
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetGameIconGamesGameid(width=integer, height=integer, gameId=integer)
        
            Args:
                width: int
            height: int
            gameId: int
            Returns:
                GameInternationalization.GetGameIconResponseExtra: GameInternationalization.GetGameIconResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"width": width, "height": height},"headers": {},"cookies": {}}
            
            GetGameIconGamesGameidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/game-icon/games/{gameId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetGameIconResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGameIconGamesGameidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGameIconGamesGameidRecivedData)
            
            return ResponseSchema
        
        def GetGameLocalizationStatusGameidTranslationCounts(self, gameId: int) -> GetTranslationCountsForGameResponse:
            """
            Gets the language translation counts for all languages of a game
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetGameLocalizationStatusGameidTranslationCounts(gameId=integer)
        
            Args:
                gameId: int
            Returns:
                GameInternationalization.GetTranslationCountsForGameResponse: GameInternationalization.GetTranslationCountsForGameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGameLocalizationStatusGameidTranslationCountsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/game-localization-status/{gameId}/translation-counts", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetTranslationCountsForGameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGameLocalizationStatusGameidTranslationCountsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGameLocalizationStatusGameidTranslationCountsRecivedData)
            
            return ResponseSchema
        
        def GetGameLocalizationStatusTranslationCountsForLanguageOrLocale(self, gameIds: list, languageOrLocaleCode: str, languageOrLocaleType: str) -> GetTranslationCountsForLanguageOrLocaleResponse:
            """
            Gets the language translation counts for the specified table.

The languages to retrieve must be provided.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetGameLocalizationStatusTranslationCountsForLanguageOrLocale(gameIds=array, languageOrLocaleCode=string, languageOrLocaleType=string)
        
            Args:
                gameIds: list
            languageOrLocaleCode: str
            languageOrLocaleType: str
            Returns:
                GameInternationalization.GetTranslationCountsForLanguageOrLocaleResponse: GameInternationalization.GetTranslationCountsForLanguageOrLocaleResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"gameIds": gameIds, "languageOrLocaleCode": languageOrLocaleCode, "languageOrLocaleType": languageOrLocaleType},"headers": {},"cookies": {}}
            
            GetGameLocalizationStatusTranslationCountsForLanguageOrLocaleRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/game-localization-status/translation-counts-for-language-or-locale", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetTranslationCountsForLanguageOrLocaleResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGameLocalizationStatusTranslationCountsForLanguageOrLocaleRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGameLocalizationStatusTranslationCountsForLanguageOrLocaleRecivedData)
            
            return ResponseSchema
        
        def GetGamePassesGamepassidIcons(self, width: int, height: int, gamePassId: int) -> GetGamePassIconResponseExtra:
            """
            Get all icons for a game pass
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetGamePassesGamepassidIcons(width=integer, height=integer, gamePassId=integer)
        
            Args:
                width: int
            height: int
            gamePassId: int
            Returns:
                GameInternationalization.GetGamePassIconResponseExtra: GameInternationalization.GetGamePassIconResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"width": width, "height": height},"headers": {},"cookies": {}}
            
            GetGamePassesGamepassidIconsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/game-passes/{gamePassId}/icons", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetGamePassIconResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamePassesGamepassidIconsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamePassesGamepassidIconsRecivedData)
            
            return ResponseSchema
        
        def GetGamePassesGamepassidNameDescription(self, gamePassId: int) -> NameDescriptionExtra:
            """
            Get all names and descriptions of a game pass
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetGamePassesGamepassidNameDescription(gamePassId=integer)
        
            Args:
                gamePassId: int
            Returns:
                GameInternationalization.NameDescriptionExtra: GameInternationalization.NameDescriptionExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGamePassesGamepassidNameDescriptionRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/game-passes/{gamePassId}/name-description", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.NameDescriptionExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGamePassesGamepassidNameDescriptionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGamePassesGamepassidNameDescriptionRecivedData)
            
            return ResponseSchema
        
        def GetGameThumbnailsGamesGameidImages(self, width: int, height: int, gameId: int) -> GetGameThumbnailsResponseExtra:
            """
            Get the localized image ids in all languages for a game.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetGameThumbnailsGamesGameidImages(width=integer, height=integer, gameId=integer)
        
            Args:
                width: int
            height: int
            gameId: int
            Returns:
                GameInternationalization.GetGameThumbnailsResponseExtra: GameInternationalization.GetGameThumbnailsResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"width": width, "height": height},"headers": {},"cookies": {}}
            
            GetGameThumbnailsGamesGameidImagesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/game-thumbnails/games/{gameId}/images", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetGameThumbnailsResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGameThumbnailsGamesGameidImagesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGameThumbnailsGamesGameidImagesRecivedData)
            
            return ResponseSchema
        
        def GetNameDescriptionGamesGameid(self, gameId: int) -> NameDescriptionExtra:
            """
            Gets a game's name and description in all supported languages
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetNameDescriptionGamesGameid(gameId=integer)
        
            Args:
                gameId: int
            Returns:
                GameInternationalization.NameDescriptionExtra: GameInternationalization.NameDescriptionExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetNameDescriptionGamesGameidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/name-description/games/{gameId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.NameDescriptionExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetNameDescriptionGamesGameidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetNameDescriptionGamesGameidRecivedData)
            
            return ResponseSchema
        
        def PatchNameDescriptionGamesGameid(self, gameId: int, UpdateNameDescriptionsRequest: UpdateNameDescriptionsRequest) -> UpdateNameDescriptionsResponse:
            """
            Updates a game's name and/or description in multiple languages.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchNameDescriptionGamesGameid(gameId=integer, UpdateNameDescriptionsRequest=GameInternationalization.UpdateNameDescriptionsRequest())
        
            Args:
                gameId: int
            UpdateNameDescriptionsRequest: UpdateNameDescriptionsRequest
            Returns:
                GameInternationalization.UpdateNameDescriptionsResponse: GameInternationalization.UpdateNameDescriptionsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateNameDescriptionsRequest': 'json'}
            Arguments = inspect.signature(self.PatchNameDescriptionGamesGameid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchNameDescriptionGamesGameidRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/name-description/games/{gameId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UpdateNameDescriptionsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchNameDescriptionGamesGameidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchNameDescriptionGamesGameidRecivedData)
            
            return ResponseSchema
        
        def GetNameDescriptionMetadata(self) -> GameNameDescriptionMetadataResponse:
            """
            Rollout settings for name/description migration to new page
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetNameDescriptionMetadata()
        
            Args:
                
            Returns:
                GameInternationalization.GameNameDescriptionMetadataResponse: GameInternationalization.GameNameDescriptionMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetNameDescriptionMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/name-description/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GameNameDescriptionMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetNameDescriptionMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetNameDescriptionMetadataRecivedData)
            
            return ResponseSchema
        
        def GetPlayerPoliciesClient(self) -> GetPlayerPoliciesResponse:
            """
            Unknown
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetPlayerPoliciesClient()
        
            Args:
                
            Returns:
                GameInternationalization.GetPlayerPoliciesResponse: GameInternationalization.GetPlayerPoliciesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetPlayerPoliciesClientRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/player-policies-client", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetPlayerPoliciesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetPlayerPoliciesClientRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPlayerPoliciesClientRecivedData)
            
            return ResponseSchema
        
        def GetPlayerPoliciesAllValues(self) -> GetPlayerPoliciesResponse:
            """
            Unknown
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetPlayerPoliciesAllValues()
        
            Args:
                
            Returns:
                GameInternationalization.GetPlayerPoliciesResponse: GameInternationalization.GetPlayerPoliciesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetPlayerPoliciesAllValuesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/player-policies/all-values", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetPlayerPoliciesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetPlayerPoliciesAllValuesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPlayerPoliciesAllValuesRecivedData)
            
            return ResponseSchema
        
        def GetSourceLanguageGamesGameid(self, gameId: int) -> Language:
            """
            Gets the source language of a game
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetSourceLanguageGamesGameid(gameId=integer)
        
            Args:
                gameId: int
            Returns:
                GameInternationalization.Language: GameInternationalization.Language
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetSourceLanguageGamesGameidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/source-language/games/{gameId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.Language()
        
            ReturnedJson = None
            try: ReturnedJson = GetSourceLanguageGamesGameidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetSourceLanguageGamesGameidRecivedData)
            
            return ResponseSchema
        
        def PatchSourceLanguageGamesGameid(self, languageCode: str, gameId: int) -> ApiEmptyResponseModel:
            """
            Sets the source language of a game
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchSourceLanguageGamesGameid(languageCode=string, gameId=integer)
        
            Args:
                languageCode: str
            gameId: int
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {"languageCode": languageCode},"headers": {},"cookies": {}}
            
            PatchSourceLanguageGamesGameidRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/source-language/games/{gameId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchSourceLanguageGamesGameidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchSourceLanguageGamesGameidRecivedData)
            
            return ResponseSchema
        
        def GetSupportedLanguagesGamesGameid(self, gameId: int) -> LanguageOrLocaleExtra:
            """
            Get the supported languages for a game.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetSupportedLanguagesGamesGameid(gameId=integer)
        
            Args:
                gameId: int
            Returns:
                GameInternationalization.LanguageOrLocaleExtra: GameInternationalization.LanguageOrLocaleExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetSupportedLanguagesGamesGameidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/supported-languages/games/{gameId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.LanguageOrLocaleExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetSupportedLanguagesGamesGameidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetSupportedLanguagesGamesGameidRecivedData)
            
            return ResponseSchema
        
        def PatchSupportedLanguagesGamesGameid(self, gameId: int, languages: None) -> ApiEmptyResponseModel:
            """
            Add or remove supported languages for a game.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchSupportedLanguagesGamesGameid(gameId=integer, languages=GameInternationalization.None())
        
            Args:
                gameId: int
            languages: None
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {"languages": languages},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PatchSupportedLanguagesGamesGameidRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/supported-languages/games/{gameId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchSupportedLanguagesGamesGameidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchSupportedLanguagesGamesGameidRecivedData)
            
            return ResponseSchema
        
        def GetSupportedLanguagesGamesGameidAutomaticTranslationStatus(self, gameId: int) -> LanguageOrLocaleSettingsExtra:
            """
            Get the automatic translation status of supported languages for a game.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetSupportedLanguagesGamesGameidAutomaticTranslationStatus(gameId=integer)
        
            Args:
                gameId: int
            Returns:
                GameInternationalization.LanguageOrLocaleSettingsExtra: GameInternationalization.LanguageOrLocaleSettingsExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetSupportedLanguagesGamesGameidAutomaticTranslationStatusRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/supported-languages/games/{gameId}/automatic-translation-status", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.LanguageOrLocaleSettingsExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetSupportedLanguagesGamesGameidAutomaticTranslationStatusRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetSupportedLanguagesGamesGameidAutomaticTranslationStatusRecivedData)
            
            return ResponseSchema
        
        def GetSupportedLanguagesGamesGameidUniverseDisplayInfoAutomaticTranslationSettings(self, gameId: int) -> UniverseDisplayInfoAutomaticTranslationSettingsExtra:
            """
            Get UniverseDisplayInfo automatic translation settings.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetSupportedLanguagesGamesGameidUniverseDisplayInfoAutomaticTranslationSettings(gameId=integer)
        
            Args:
                gameId: int
            Returns:
                GameInternationalization.UniverseDisplayInfoAutomaticTranslationSettingsExtra: GameInternationalization.UniverseDisplayInfoAutomaticTranslationSettingsExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetSupportedLanguagesGamesGameidUniverseDisplayInfoAutomaticTranslationSettingsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/supported-languages/games/{gameId}/universe-display-info-automatic-translation-settings", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UniverseDisplayInfoAutomaticTranslationSettingsExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetSupportedLanguagesGamesGameidUniverseDisplayInfoAutomaticTranslationSettingsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetSupportedLanguagesGamesGameidUniverseDisplayInfoAutomaticTranslationSettingsRecivedData)
            
            return ResponseSchema
        
        def GetSupportedLanguagesMetadata(self) -> SupportedLanguagesMetadataResponse:
            """
            Rollout settings for supported languages of a game
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetSupportedLanguagesMetadata()
        
            Args:
                
            Returns:
                GameInternationalization.SupportedLanguagesMetadataResponse: GameInternationalization.SupportedLanguagesMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetSupportedLanguagesMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/supported-languages/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.SupportedLanguagesMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetSupportedLanguagesMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetSupportedLanguagesMetadataRecivedData)
            
            return ResponseSchema
        
        def GetTranslationAnalyticsGamesGameidDownloadTranslationAnalyticsReport(self, startDateTime: str, endDateTime: str, reportType: str, reportSubjectTargetId: int, gameId: int) -> requests.Response:
            """
            Download translation analytics report after the report is ready
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetTranslationAnalyticsGamesGameidDownloadTranslationAnalyticsReport(startDateTime=string, endDateTime=string, reportType=string, reportSubjectTargetId=integer, gameId=integer)
        
            Args:
                startDateTime: str
            endDateTime: str
            reportType: str
            reportSubjectTargetId: int
            gameId: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"startDateTime": startDateTime, "endDateTime": endDateTime, "reportType": reportType, "reportSubjectTargetId": reportSubjectTargetId},"headers": {},"cookies": {}}
            
            GetTranslationAnalyticsGamesGameidDownloadTranslationAnalyticsReportRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/translation-analytics/games/{gameId}/download-translation-analytics-report", Dictinary=Dictinary)
            return GetTranslationAnalyticsGamesGameidDownloadTranslationAnalyticsReportRecivedData
        
        def GetTranslationAnalyticsMetadata(self) -> TranslationAnalyticsMetadataResponse:
            """
            Get metadata related to UI and rollout settings
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetTranslationAnalyticsMetadata()
        
            Args:
                
            Returns:
                GameInternationalization.TranslationAnalyticsMetadataResponse: GameInternationalization.TranslationAnalyticsMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetTranslationAnalyticsMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/translation-analytics/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.TranslationAnalyticsMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetTranslationAnalyticsMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetTranslationAnalyticsMetadataRecivedData)
            
            return ResponseSchema
        
        def GetUiConfigurations(self) -> GetUiConfigurationsResponse:
            """
            Get ui configurations for frontend to use.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetUiConfigurations()
        
            Args:
                
            Returns:
                GameInternationalization.GetUiConfigurationsResponse: GameInternationalization.GetUiConfigurationsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUiConfigurationsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/ui-configurations", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetUiConfigurationsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUiConfigurationsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUiConfigurationsRecivedData)
            
            return ResponseSchema
        
        def GetUserLocalizationSettingsUniverseUniverseid(self, universeId: int) -> GetUserLocalizationSettingsForUniverseResponse:
            """
            Get user localization settings for universe.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.GetUserLocalizationSettingsUniverseUniverseid(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                GameInternationalization.GetUserLocalizationSettingsForUniverseResponse: GameInternationalization.GetUserLocalizationSettingsForUniverseResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUserLocalizationSettingsUniverseUniverseidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://GameInternationalization.roblox.com/v1/user-localization-settings/universe/{universeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetUserLocalizationSettingsForUniverseResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUserLocalizationSettingsUniverseUniverseidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUserLocalizationSettingsUniverseUniverseidRecivedData)
            
            return ResponseSchema
        
        def PostUserLocalizationSettingsUniverseUniverseid(self, universeId: int, SetUserLocalizationSettingsRequest: SetUserLocalizationSettingsRequest) -> SetUserLocalizationSettingsResponse:
            """
            Set user localization settings for universe.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PostUserLocalizationSettingsUniverseUniverseid(universeId=integer, SetUserLocalizationSettingsRequest=GameInternationalization.SetUserLocalizationSettingsRequest())
        
            Args:
                universeId: int
            SetUserLocalizationSettingsRequest: SetUserLocalizationSettingsRequest
            Returns:
                GameInternationalization.SetUserLocalizationSettingsResponse: GameInternationalization.SetUserLocalizationSettingsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SetUserLocalizationSettingsRequest': 'json'}
            Arguments = inspect.signature(self.PostUserLocalizationSettingsUniverseUniverseid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUserLocalizationSettingsUniverseUniverseidRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameInternationalization.roblox.com/v1/user-localization-settings/universe/{universeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.SetUserLocalizationSettingsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUserLocalizationSettingsUniverseUniverseidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUserLocalizationSettingsUniverseUniverseidRecivedData)
            
            return ResponseSchema
        
        def PatchAutolocalizationGamesGameidAutolocalizationtable(self, gameId: int, SetAutolocalizationTableForGameRequest: SetAutolocalizationTableForGameRequest) -> ApiEmptyResponseModel:
            """
            Unknown
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchAutolocalizationGamesGameidAutolocalizationtable(gameId=integer, SetAutolocalizationTableForGameRequest=GameInternationalization.SetAutolocalizationTableForGameRequest())
        
            Args:
                gameId: int
            SetAutolocalizationTableForGameRequest: SetAutolocalizationTableForGameRequest
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SetAutolocalizationTableForGameRequest': 'json'}
            Arguments = inspect.signature(self.PatchAutolocalizationGamesGameidAutolocalizationtable)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchAutolocalizationGamesGameidAutolocalizationtableRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/autolocalization/games/{gameId}/autolocalizationtable", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchAutolocalizationGamesGameidAutolocalizationtableRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchAutolocalizationGamesGameidAutolocalizationtableRecivedData)
            
            return ResponseSchema
        
        def PostAutolocalizationGamesGameidAutolocalizationtable(self, gameId: int) -> GameAutolocalizationInformationResponse:
            """
            Unknown
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PostAutolocalizationGamesGameidAutolocalizationtable(gameId=integer)
        
            Args:
                gameId: int
            Returns:
                GameInternationalization.GameAutolocalizationInformationResponse: GameInternationalization.GameAutolocalizationInformationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostAutolocalizationGamesGameidAutolocalizationtableRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameInternationalization.roblox.com/v1/autolocalization/games/{gameId}/autolocalizationtable", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GameAutolocalizationInformationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAutolocalizationGamesGameidAutolocalizationtableRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAutolocalizationGamesGameidAutolocalizationtableRecivedData)
            
            return ResponseSchema
        
        def DeleteBadgesBadgeidIconsLanguageCodesLanguagecode(self, badgeId: int, languageCode: str) -> ApiEmptyResponseModel:
            """
            Delete a localized icon from a badge
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.DeleteBadgesBadgeidIconsLanguageCodesLanguagecode(badgeId=integer, languageCode=string)
        
            Args:
                badgeId: int
            languageCode: str
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteBadgesBadgeidIconsLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://GameInternationalization.roblox.com/v1/badges/{badgeId}/icons/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteBadgesBadgeidIconsLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteBadgesBadgeidIconsLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PostBadgesBadgeidIconsLanguageCodesLanguagecode(self, badgeId: int, languageCode: str, Files: typing.IO) -> ApiEmptyResponseModel:
            """
            Update a badge's icon
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PostBadgesBadgeidIconsLanguageCodesLanguagecode(badgeId=integer, languageCode=string, Files=file)
        
            Args:
                badgeId: int
            languageCode: str
            Files: typing.IO
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {"Files": Files},"params": {},"headers": {},"cookies": {}}
            
            PostBadgesBadgeidIconsLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameInternationalization.roblox.com/v1/badges/{badgeId}/icons/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostBadgesBadgeidIconsLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostBadgesBadgeidIconsLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def DeleteDeveloperProductsDeveloperproductidIconsLanguageCodesLanguagecode(self, developerProductId: int, languageCode: str) -> ApiEmptyResponseModel:
            """
            Delete a localized icon from a developer product
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.DeleteDeveloperProductsDeveloperproductidIconsLanguageCodesLanguagecode(developerProductId=integer, languageCode=string)
        
            Args:
                developerProductId: int
            languageCode: str
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteDeveloperProductsDeveloperproductidIconsLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://GameInternationalization.roblox.com/v1/developer-products/{developerProductId}/icons/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteDeveloperProductsDeveloperproductidIconsLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteDeveloperProductsDeveloperproductidIconsLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PostDeveloperProductsDeveloperproductidIconsLanguageCodesLanguagecode(self, developerProductId: int, languageCode: str, Files: typing.IO) -> ApiEmptyResponseModel:
            """
            Update a developer product's icon
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PostDeveloperProductsDeveloperproductidIconsLanguageCodesLanguagecode(developerProductId=integer, languageCode=string, Files=file)
        
            Args:
                developerProductId: int
            languageCode: str
            Files: typing.IO
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {"Files": Files},"params": {},"headers": {},"cookies": {}}
            
            PostDeveloperProductsDeveloperproductidIconsLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameInternationalization.roblox.com/v1/developer-products/{developerProductId}/icons/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostDeveloperProductsDeveloperproductidIconsLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostDeveloperProductsDeveloperproductidIconsLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def DeleteGameIconGamesGameidLanguageCodesLanguagecode(self, gameId: int, languageCode: str) -> ApiEmptyResponseModel:
            """
            Delete a localized icon from a game
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.DeleteGameIconGamesGameidLanguageCodesLanguagecode(gameId=integer, languageCode=string)
        
            Args:
                gameId: int
            languageCode: str
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteGameIconGamesGameidLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://GameInternationalization.roblox.com/v1/game-icon/games/{gameId}/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGameIconGamesGameidLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGameIconGamesGameidLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PostGameIconGamesGameidLanguageCodesLanguagecode(self, gameId: int, languageCode: str, Files: typing.IO) -> ApiEmptyResponseModel:
            """
            Update a game's icon
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PostGameIconGamesGameidLanguageCodesLanguagecode(gameId=integer, languageCode=string, Files=file)
        
            Args:
                gameId: int
            languageCode: str
            Files: typing.IO
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {"Files": Files},"params": {},"headers": {},"cookies": {}}
            
            PostGameIconGamesGameidLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameInternationalization.roblox.com/v1/game-icon/games/{gameId}/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGameIconGamesGameidLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGameIconGamesGameidLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def DeleteGamePassesGamepassidIconsLanguageCodesLanguagecode(self, gamePassId: int, languageCode: str) -> ApiEmptyResponseModel:
            """
            Delete a localized icon from a game pass
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.DeleteGamePassesGamepassidIconsLanguageCodesLanguagecode(gamePassId=integer, languageCode=string)
        
            Args:
                gamePassId: int
            languageCode: str
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteGamePassesGamepassidIconsLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://GameInternationalization.roblox.com/v1/game-passes/{gamePassId}/icons/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGamePassesGamepassidIconsLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGamePassesGamepassidIconsLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PostGamePassesGamepassidIconsLanguageCodesLanguagecode(self, gamePassId: int, languageCode: str, Files: typing.IO) -> ApiEmptyResponseModel:
            """
            Update a game pass's icon
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PostGamePassesGamepassidIconsLanguageCodesLanguagecode(gamePassId=integer, languageCode=string, Files=file)
        
            Args:
                gamePassId: int
            languageCode: str
            Files: typing.IO
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {"Files": Files},"params": {},"headers": {},"cookies": {}}
            
            PostGamePassesGamepassidIconsLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameInternationalization.roblox.com/v1/game-passes/{gamePassId}/icons/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGamePassesGamepassidIconsLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGamePassesGamepassidIconsLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeAltText(self, gameId: int, languageCode: str, UpdateThumbnailAltTextRequest: UpdateThumbnailAltTextRequest) -> requests.Response:
            """
            Updates the game thumbnail alt text.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeAltText(gameId=integer, languageCode=string, UpdateThumbnailAltTextRequest=GameInternationalization.UpdateThumbnailAltTextRequest())
        
            Args:
                gameId: int
            languageCode: str
            UpdateThumbnailAltTextRequest: UpdateThumbnailAltTextRequest
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateThumbnailAltTextRequest': 'json'}
            Arguments = inspect.signature(self.PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeAltText)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeAltTextRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameInternationalization.roblox.com/v1/game-thumbnails/games/{gameId}/language-codes/{languageCode}/alt-text", Dictinary=Dictinary)
            return PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeAltTextRecivedData
        
        def PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeImage(self, gameId: int, languageCode: str, Files: typing.IO) -> UploadImageForGameThumbnailResponse:
            """
            Uploads the game thumbnail.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeImage(gameId=integer, languageCode=string, Files=file)
        
            Args:
                gameId: int
            languageCode: str
            Files: typing.IO
            Returns:
                GameInternationalization.UploadImageForGameThumbnailResponse: GameInternationalization.UploadImageForGameThumbnailResponse
            """
        
            Dictinary = {"json": {},"data": {"Files": Files},"params": {},"headers": {},"cookies": {}}
            
            PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeImageRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameInternationalization.roblox.com/v1/game-thumbnails/games/{gameId}/language-codes/{languageCode}/image", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UploadImageForGameThumbnailResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeImageRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeImageRecivedData)
            
            return ResponseSchema
        
        def PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeImagesOrder(self, gameId: int, languageCode: str, SortImageIdsRequest: SortImageIdsRequest) -> ApiEmptyResponseModel:
            """
            Orders the specified image Ids for the game thumbnails.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeImagesOrder(gameId=integer, languageCode=string, SortImageIdsRequest=GameInternationalization.SortImageIdsRequest())
        
            Args:
                gameId: int
            languageCode: str
            SortImageIdsRequest: SortImageIdsRequest
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SortImageIdsRequest': 'json'}
            Arguments = inspect.signature(self.PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeImagesOrder)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeImagesOrderRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameInternationalization.roblox.com/v1/game-thumbnails/games/{gameId}/language-codes/{languageCode}/images/order", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeImagesOrderRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGameThumbnailsGamesGameidLanguageCodesLanguagecodeImagesOrderRecivedData)
            
            return ResponseSchema
        
        def PostNameDescriptionGamesGameidHistory(self, gameId: int, GetNameDescriptionHistoryRequest: GetNameDescriptionHistoryRequest) -> GetNameDescriptionHistoryResponse:
            """
            Gets the history for name or description in a provided language.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PostNameDescriptionGamesGameidHistory(gameId=integer, GetNameDescriptionHistoryRequest=GameInternationalization.GetNameDescriptionHistoryRequest())
        
            Args:
                gameId: int
            GetNameDescriptionHistoryRequest: GetNameDescriptionHistoryRequest
            Returns:
                GameInternationalization.GetNameDescriptionHistoryResponse: GameInternationalization.GetNameDescriptionHistoryResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'GetNameDescriptionHistoryRequest': 'json'}
            Arguments = inspect.signature(self.PostNameDescriptionGamesGameidHistory)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostNameDescriptionGamesGameidHistoryRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameInternationalization.roblox.com/v1/name-description/games/{gameId}/history", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetNameDescriptionHistoryResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostNameDescriptionGamesGameidHistoryRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostNameDescriptionGamesGameidHistoryRecivedData)
            
            return ResponseSchema
        
        def PostNameDescriptionGamesTranslationHistory(self, GetNameDescriptionHistoryV2Request: GetNameDescriptionHistoryV2Request) -> GetNameDescriptionHistoryResponse:
            """
            Gets the history for name or description in a provided language.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PostNameDescriptionGamesTranslationHistory(GetNameDescriptionHistoryV2Request=GameInternationalization.GetNameDescriptionHistoryV2Request())
        
            Args:
                GetNameDescriptionHistoryV2Request: GetNameDescriptionHistoryV2Request
            Returns:
                GameInternationalization.GetNameDescriptionHistoryResponse: GameInternationalization.GetNameDescriptionHistoryResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'GetNameDescriptionHistoryV2Request': 'json'}
            Arguments = inspect.signature(self.PostNameDescriptionGamesTranslationHistory)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostNameDescriptionGamesTranslationHistoryRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameInternationalization.roblox.com/v1/name-description/games/translation-history", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.GetNameDescriptionHistoryResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostNameDescriptionGamesTranslationHistoryRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostNameDescriptionGamesTranslationHistoryRecivedData)
            
            return ResponseSchema
        
        def PostTranslationAnalyticsGamesGameidRequestTranslationAnalyticsReport(self, gameId: int, RequestTranslationAnalyticsReportRequest: RequestTranslationAnalyticsReportRequest) -> RequestTranslationAnalyticsReportResponse:
            """
            Request translation analytics report to be generated
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PostTranslationAnalyticsGamesGameidRequestTranslationAnalyticsReport(gameId=integer, RequestTranslationAnalyticsReportRequest=GameInternationalization.RequestTranslationAnalyticsReportRequest())
        
            Args:
                gameId: int
            RequestTranslationAnalyticsReportRequest: RequestTranslationAnalyticsReportRequest
            Returns:
                GameInternationalization.RequestTranslationAnalyticsReportResponse: GameInternationalization.RequestTranslationAnalyticsReportResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RequestTranslationAnalyticsReportRequest': 'json'}
            Arguments = inspect.signature(self.PostTranslationAnalyticsGamesGameidRequestTranslationAnalyticsReport)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostTranslationAnalyticsGamesGameidRequestTranslationAnalyticsReportRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://GameInternationalization.roblox.com/v1/translation-analytics/games/{gameId}/request-translation-analytics-report", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.RequestTranslationAnalyticsReportResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostTranslationAnalyticsGamesGameidRequestTranslationAnalyticsReportRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTranslationAnalyticsGamesGameidRequestTranslationAnalyticsReportRecivedData)
            
            return ResponseSchema
        
        def PatchAutolocalizationGamesGameidSettings(self, gameId: int, SetAutolocalizationSettingsForGameRequest: SetAutolocalizationSettingsForGameRequest) -> ApiEmptyResponseModel:
            """
            Sets a game's auto-localization related settings
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchAutolocalizationGamesGameidSettings(gameId=integer, SetAutolocalizationSettingsForGameRequest=GameInternationalization.SetAutolocalizationSettingsForGameRequest())
        
            Args:
                gameId: int
            SetAutolocalizationSettingsForGameRequest: SetAutolocalizationSettingsForGameRequest
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SetAutolocalizationSettingsForGameRequest': 'json'}
            Arguments = inspect.signature(self.PatchAutolocalizationGamesGameidSettings)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchAutolocalizationGamesGameidSettingsRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/autolocalization/games/{gameId}/settings", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchAutolocalizationGamesGameidSettingsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchAutolocalizationGamesGameidSettingsRecivedData)
            
            return ResponseSchema
        
        def PatchBadgesBadgeidDescriptionLanguageCodesLanguagecode(self, badgeId: int, languageCode: str, UpdateBadgeDescriptionRequest: UpdateBadgeDescriptionRequest) -> UpdateBadgeDescriptionResponse:
            """
            Update localized description of a badge
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchBadgesBadgeidDescriptionLanguageCodesLanguagecode(badgeId=integer, languageCode=string, UpdateBadgeDescriptionRequest=GameInternationalization.UpdateBadgeDescriptionRequest())
        
            Args:
                badgeId: int
            languageCode: str
            UpdateBadgeDescriptionRequest: UpdateBadgeDescriptionRequest
            Returns:
                GameInternationalization.UpdateBadgeDescriptionResponse: GameInternationalization.UpdateBadgeDescriptionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateBadgeDescriptionRequest': 'json'}
            Arguments = inspect.signature(self.PatchBadgesBadgeidDescriptionLanguageCodesLanguagecode)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchBadgesBadgeidDescriptionLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/badges/{badgeId}/description/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UpdateBadgeDescriptionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchBadgesBadgeidDescriptionLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchBadgesBadgeidDescriptionLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def DeleteBadgesBadgeidNameDescriptionLanguageCodesLanguagecode(self, badgeId: int, languageCode: str) -> ApiEmptyResponseModel:
            """
            Delete localized name and description of a badge
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.DeleteBadgesBadgeidNameDescriptionLanguageCodesLanguagecode(badgeId=integer, languageCode=string)
        
            Args:
                badgeId: int
            languageCode: str
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteBadgesBadgeidNameDescriptionLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://GameInternationalization.roblox.com/v1/badges/{badgeId}/name-description/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteBadgesBadgeidNameDescriptionLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteBadgesBadgeidNameDescriptionLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PatchBadgesBadgeidNameDescriptionLanguageCodesLanguagecode(self, badgeId: int, languageCode: str, UpdateBadgeNameDescriptionRequest: UpdateBadgeNameDescriptionRequest) -> UpdateBadgeNameDescriptionResponse:
            """
            Update localized name and description of a badge
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchBadgesBadgeidNameDescriptionLanguageCodesLanguagecode(badgeId=integer, languageCode=string, UpdateBadgeNameDescriptionRequest=GameInternationalization.UpdateBadgeNameDescriptionRequest())
        
            Args:
                badgeId: int
            languageCode: str
            UpdateBadgeNameDescriptionRequest: UpdateBadgeNameDescriptionRequest
            Returns:
                GameInternationalization.UpdateBadgeNameDescriptionResponse: GameInternationalization.UpdateBadgeNameDescriptionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateBadgeNameDescriptionRequest': 'json'}
            Arguments = inspect.signature(self.PatchBadgesBadgeidNameDescriptionLanguageCodesLanguagecode)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchBadgesBadgeidNameDescriptionLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/badges/{badgeId}/name-description/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UpdateBadgeNameDescriptionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchBadgesBadgeidNameDescriptionLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchBadgesBadgeidNameDescriptionLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PatchBadgesBadgeidNameLanguageCodesLanguagecode(self, badgeId: int, languageCode: str, UpdateBadgeNameRequest: UpdateBadgeNameRequest) -> UpdateBadgeNameResponse:
            """
            Update localized name of a badge
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchBadgesBadgeidNameLanguageCodesLanguagecode(badgeId=integer, languageCode=string, UpdateBadgeNameRequest=GameInternationalization.UpdateBadgeNameRequest())
        
            Args:
                badgeId: int
            languageCode: str
            UpdateBadgeNameRequest: UpdateBadgeNameRequest
            Returns:
                GameInternationalization.UpdateBadgeNameResponse: GameInternationalization.UpdateBadgeNameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateBadgeNameRequest': 'json'}
            Arguments = inspect.signature(self.PatchBadgesBadgeidNameLanguageCodesLanguagecode)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchBadgesBadgeidNameLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/badges/{badgeId}/name/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UpdateBadgeNameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchBadgesBadgeidNameLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchBadgesBadgeidNameLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PatchDeveloperProductsDeveloperproductidDescriptionLanguageCodesLanguagecode(self, developerProductId: int, languageCode: str, UpdateDeveloperProductDescriptionRequest: UpdateDeveloperProductDescriptionRequest) -> UpdateDeveloperProductDescriptionResponse:
            """
            Update localized description of a developer product
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchDeveloperProductsDeveloperproductidDescriptionLanguageCodesLanguagecode(developerProductId=integer, languageCode=string, UpdateDeveloperProductDescriptionRequest=GameInternationalization.UpdateDeveloperProductDescriptionRequest())
        
            Args:
                developerProductId: int
            languageCode: str
            UpdateDeveloperProductDescriptionRequest: UpdateDeveloperProductDescriptionRequest
            Returns:
                GameInternationalization.UpdateDeveloperProductDescriptionResponse: GameInternationalization.UpdateDeveloperProductDescriptionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateDeveloperProductDescriptionRequest': 'json'}
            Arguments = inspect.signature(self.PatchDeveloperProductsDeveloperproductidDescriptionLanguageCodesLanguagecode)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchDeveloperProductsDeveloperproductidDescriptionLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/developer-products/{developerProductId}/description/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UpdateDeveloperProductDescriptionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchDeveloperProductsDeveloperproductidDescriptionLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchDeveloperProductsDeveloperproductidDescriptionLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def DeleteDeveloperProductsDeveloperproductidNameDescriptionLanguageCodesLanguagecode(self, developerProductId: int, languageCode: str) -> ApiEmptyResponseModel:
            """
            Delete localized name and description of a developer product
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.DeleteDeveloperProductsDeveloperproductidNameDescriptionLanguageCodesLanguagecode(developerProductId=integer, languageCode=string)
        
            Args:
                developerProductId: int
            languageCode: str
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteDeveloperProductsDeveloperproductidNameDescriptionLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://GameInternationalization.roblox.com/v1/developer-products/{developerProductId}/name-description/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteDeveloperProductsDeveloperproductidNameDescriptionLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteDeveloperProductsDeveloperproductidNameDescriptionLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PatchDeveloperProductsDeveloperproductidNameDescriptionLanguageCodesLanguagecode(self, developerProductId: int, languageCode: str, UpdateDeveloperProductNameDescriptionRequest: UpdateDeveloperProductNameDescriptionRequest) -> UpdateDeveloperProductNameDescriptionResponse:
            """
            Update localized name and description of a developer product
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchDeveloperProductsDeveloperproductidNameDescriptionLanguageCodesLanguagecode(developerProductId=integer, languageCode=string, UpdateDeveloperProductNameDescriptionRequest=GameInternationalization.UpdateDeveloperProductNameDescriptionRequest())
        
            Args:
                developerProductId: int
            languageCode: str
            UpdateDeveloperProductNameDescriptionRequest: UpdateDeveloperProductNameDescriptionRequest
            Returns:
                GameInternationalization.UpdateDeveloperProductNameDescriptionResponse: GameInternationalization.UpdateDeveloperProductNameDescriptionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateDeveloperProductNameDescriptionRequest': 'json'}
            Arguments = inspect.signature(self.PatchDeveloperProductsDeveloperproductidNameDescriptionLanguageCodesLanguagecode)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchDeveloperProductsDeveloperproductidNameDescriptionLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/developer-products/{developerProductId}/name-description/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UpdateDeveloperProductNameDescriptionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchDeveloperProductsDeveloperproductidNameDescriptionLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchDeveloperProductsDeveloperproductidNameDescriptionLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PatchDeveloperProductsDeveloperproductidNameLanguageCodesLanguagecode(self, developerProductId: int, languageCode: str, UpdateDeveloperProductNameRequest: UpdateDeveloperProductNameRequest) -> UpdateDeveloperProductNameResponse:
            """
            Update localized name of a developer product
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchDeveloperProductsDeveloperproductidNameLanguageCodesLanguagecode(developerProductId=integer, languageCode=string, UpdateDeveloperProductNameRequest=GameInternationalization.UpdateDeveloperProductNameRequest())
        
            Args:
                developerProductId: int
            languageCode: str
            UpdateDeveloperProductNameRequest: UpdateDeveloperProductNameRequest
            Returns:
                GameInternationalization.UpdateDeveloperProductNameResponse: GameInternationalization.UpdateDeveloperProductNameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateDeveloperProductNameRequest': 'json'}
            Arguments = inspect.signature(self.PatchDeveloperProductsDeveloperproductidNameLanguageCodesLanguagecode)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchDeveloperProductsDeveloperproductidNameLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/developer-products/{developerProductId}/name/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UpdateDeveloperProductNameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchDeveloperProductsDeveloperproductidNameLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchDeveloperProductsDeveloperproductidNameLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PatchGamePassesGamepassidDescriptionLanguageCodesLanguagecode(self, gamePassId: int, languageCode: str, UpdateGamePassDescriptionRequest: UpdateGamePassDescriptionRequest) -> UpdateGamePassDescriptionResponse:
            """
            Update localized description of a game pass
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchGamePassesGamepassidDescriptionLanguageCodesLanguagecode(gamePassId=integer, languageCode=string, UpdateGamePassDescriptionRequest=GameInternationalization.UpdateGamePassDescriptionRequest())
        
            Args:
                gamePassId: int
            languageCode: str
            UpdateGamePassDescriptionRequest: UpdateGamePassDescriptionRequest
            Returns:
                GameInternationalization.UpdateGamePassDescriptionResponse: GameInternationalization.UpdateGamePassDescriptionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateGamePassDescriptionRequest': 'json'}
            Arguments = inspect.signature(self.PatchGamePassesGamepassidDescriptionLanguageCodesLanguagecode)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGamePassesGamepassidDescriptionLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/game-passes/{gamePassId}/description/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UpdateGamePassDescriptionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGamePassesGamepassidDescriptionLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGamePassesGamepassidDescriptionLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def DeleteGamePassesGamepassidNameDescriptionLanguageCodesLanguagecode(self, gamePassId: int, languageCode: str) -> ApiEmptyResponseModel:
            """
            Delete localized name and description of a game pass
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.DeleteGamePassesGamepassidNameDescriptionLanguageCodesLanguagecode(gamePassId=integer, languageCode=string)
        
            Args:
                gamePassId: int
            languageCode: str
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteGamePassesGamepassidNameDescriptionLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://GameInternationalization.roblox.com/v1/game-passes/{gamePassId}/name-description/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGamePassesGamepassidNameDescriptionLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGamePassesGamepassidNameDescriptionLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PatchGamePassesGamepassidNameDescriptionLanguageCodesLanguagecode(self, gamePassId: int, languageCode: str, UpdateGamePassNameDescriptionRequest: UpdateGamePassNameDescriptionRequest) -> UpdateGamePassNameDescriptionResponse:
            """
            Update localized name and description of a game pass
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchGamePassesGamepassidNameDescriptionLanguageCodesLanguagecode(gamePassId=integer, languageCode=string, UpdateGamePassNameDescriptionRequest=GameInternationalization.UpdateGamePassNameDescriptionRequest())
        
            Args:
                gamePassId: int
            languageCode: str
            UpdateGamePassNameDescriptionRequest: UpdateGamePassNameDescriptionRequest
            Returns:
                GameInternationalization.UpdateGamePassNameDescriptionResponse: GameInternationalization.UpdateGamePassNameDescriptionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateGamePassNameDescriptionRequest': 'json'}
            Arguments = inspect.signature(self.PatchGamePassesGamepassidNameDescriptionLanguageCodesLanguagecode)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGamePassesGamepassidNameDescriptionLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/game-passes/{gamePassId}/name-description/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UpdateGamePassNameDescriptionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGamePassesGamepassidNameDescriptionLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGamePassesGamepassidNameDescriptionLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PatchGamePassesGamepassidNameLanguageCodesLanguagecode(self, gamePassId: int, languageCode: str, UpdateGamePassNameRequest: UpdateGamePassNameRequest) -> UpdateGamePassNameResponse:
            """
            Update localized name of a game pass
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchGamePassesGamepassidNameLanguageCodesLanguagecode(gamePassId=integer, languageCode=string, UpdateGamePassNameRequest=GameInternationalization.UpdateGamePassNameRequest())
        
            Args:
                gamePassId: int
            languageCode: str
            UpdateGamePassNameRequest: UpdateGamePassNameRequest
            Returns:
                GameInternationalization.UpdateGamePassNameResponse: GameInternationalization.UpdateGamePassNameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateGamePassNameRequest': 'json'}
            Arguments = inspect.signature(self.PatchGamePassesGamepassidNameLanguageCodesLanguagecode)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchGamePassesGamepassidNameLanguageCodesLanguagecodeRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/game-passes/{gamePassId}/name/language-codes/{languageCode}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UpdateGamePassNameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchGamePassesGamepassidNameLanguageCodesLanguagecodeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchGamePassesGamepassidNameLanguageCodesLanguagecodeRecivedData)
            
            return ResponseSchema
        
        def PatchLocalizationtableGametablesGameid(self, gameId: int, AssociateLocalizationTablesToGameRequest: AssociateLocalizationTablesToGameRequest) -> AssociateLocalizationTablesToGameResponse:
            """
            Unknown
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchLocalizationtableGametablesGameid(gameId=integer, AssociateLocalizationTablesToGameRequest=GameInternationalization.AssociateLocalizationTablesToGameRequest())
        
            Args:
                gameId: int
            AssociateLocalizationTablesToGameRequest: AssociateLocalizationTablesToGameRequest
            Returns:
                GameInternationalization.AssociateLocalizationTablesToGameResponse: GameInternationalization.AssociateLocalizationTablesToGameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'AssociateLocalizationTablesToGameRequest': 'json'}
            Arguments = inspect.signature(self.PatchLocalizationtableGametablesGameid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchLocalizationtableGametablesGameidRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/localizationtable/gametables/{gameId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.AssociateLocalizationTablesToGameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchLocalizationtableGametablesGameidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchLocalizationtableGametablesGameidRecivedData)
            
            return ResponseSchema
        
        def PatchSupportedLanguagesGamesGameidLanguagesLanguagecodeAutomaticTranslationStatus(self, gameId: int, languageCode: str, enableAutomaticTranslation: None) -> EditAutomaticTranslationStatusForGameAndLanguageResponse:
            """
            Enable or disable automatic translation for a game and language.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchSupportedLanguagesGamesGameidLanguagesLanguagecodeAutomaticTranslationStatus(gameId=integer, languageCode=string, enableAutomaticTranslation=GameInternationalization.None())
        
            Args:
                gameId: int
            languageCode: str
            enableAutomaticTranslation: None
            Returns:
                GameInternationalization.EditAutomaticTranslationStatusForGameAndLanguageResponse: GameInternationalization.EditAutomaticTranslationStatusForGameAndLanguageResponse
            """
        
            Dictinary = {"json": {"enableAutomaticTranslation": enableAutomaticTranslation},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PatchSupportedLanguagesGamesGameidLanguagesLanguagecodeAutomaticTranslationStatusRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/supported-languages/games/{gameId}/languages/{languageCode}/automatic-translation-status", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.EditAutomaticTranslationStatusForGameAndLanguageResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchSupportedLanguagesGamesGameidLanguagesLanguagecodeAutomaticTranslationStatusRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchSupportedLanguagesGamesGameidLanguagesLanguagecodeAutomaticTranslationStatusRecivedData)
            
            return ResponseSchema
        
        def PatchSupportedLanguagesGamesGameidLanguagesLanguagecodeUniverseDisplayInfoAutomaticTranslationSettings(self, gameId: int, languageCode: str, enableUniverseDisplayInfoAutomaticTranslation: None) -> UpdateUniverseDisplayInfoAutomaticTranslationSettingsResponse:
            """
            Update the switch which controls if the UniverseDisplayInformation should be automatically translated.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.PatchSupportedLanguagesGamesGameidLanguagesLanguagecodeUniverseDisplayInfoAutomaticTranslationSettings(gameId=integer, languageCode=string, enableUniverseDisplayInfoAutomaticTranslation=GameInternationalization.None())
        
            Args:
                gameId: int
            languageCode: str
            enableUniverseDisplayInfoAutomaticTranslation: None
            Returns:
                GameInternationalization.UpdateUniverseDisplayInfoAutomaticTranslationSettingsResponse: GameInternationalization.UpdateUniverseDisplayInfoAutomaticTranslationSettingsResponse
            """
        
            Dictinary = {"json": {"enableUniverseDisplayInfoAutomaticTranslation": enableUniverseDisplayInfoAutomaticTranslation},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PatchSupportedLanguagesGamesGameidLanguagesLanguagecodeUniverseDisplayInfoAutomaticTranslationSettingsRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://GameInternationalization.roblox.com/v1/supported-languages/games/{gameId}/languages/{languageCode}/universe-display-info-automatic-translation-settings", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.UpdateUniverseDisplayInfoAutomaticTranslationSettingsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchSupportedLanguagesGamesGameidLanguagesLanguagecodeUniverseDisplayInfoAutomaticTranslationSettingsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchSupportedLanguagesGamesGameidLanguagesLanguagecodeUniverseDisplayInfoAutomaticTranslationSettingsRecivedData)
            
            return ResponseSchema
        
        def DeleteGameThumbnailsGamesGameidLanguageCodesLanguagecodeImagesImageid(self, gameId: int, languageCode: str, imageId: int) -> ApiEmptyResponseModel:
            """
            Deletes the game thumbnail.
            
            Usage:
                import GameInternationalization
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                GameInternationalizationApi = GameInternationalization.GameInternationalizationApi(RobloxClient=RobloxClient)
                Response = GameInternationalizationApi.DeleteGameThumbnailsGamesGameidLanguageCodesLanguagecodeImagesImageid(gameId=integer, languageCode=string, imageId=integer)
        
            Args:
                gameId: int
            languageCode: str
            imageId: int
            Returns:
                GameInternationalization.ApiEmptyResponseModel: GameInternationalization.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteGameThumbnailsGamesGameidLanguageCodesLanguagecodeImagesImageidRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://GameInternationalization.roblox.com/v1/game-thumbnails/games/{gameId}/language-codes/{languageCode}/images/{imageId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.GameInternationalization.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteGameThumbnailsGamesGameidLanguageCodesLanguagecodeImagesImageidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteGameThumbnailsGamesGameidLanguageCodesLanguagecodeImagesImageidRecivedData)
            
            return ResponseSchema
        
    class Friends:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class CaptchaStatusResponseModel:
            def __init__(ClassObject, success: bool = None, isCaptchaRequired: bool = None):
                ClassObject.success = success
                ClassObject.isCaptchaRequired = isCaptchaRequired
                ClassObject.response: requests.Response = None


        class FollowCountResponse:
            def __init__(ClassObject, count: int = None):
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class FollowingExistsRequestModel:
            def __init__(ClassObject, targetUserIds: list[int] = None):
                ClassObject.targetUserIds = targetUserIds
                ClassObject.response: requests.Response = None


        class FriendRequest:
            def __init__(ClassObject, sentAt: str = None, senderId: int = None, sourceUniverseId: int = None, originSourceType: enum.Enum = None, contactName: str = None, senderNickname: str = None):
                ClassObject.sentAt = sentAt
                ClassObject.senderId = senderId
                ClassObject.sourceUniverseId = sourceUniverseId
                ClassObject.originSourceType = originSourceType
                ClassObject.contactName = contactName
                ClassObject.senderNickname = senderNickname
                ClassObject.response: requests.Response = None


        class FriendRequestResponse:
            def __init__(ClassObject, friendRequest: "RobloxClient.Friends.FriendRequest" = None, mutualFriendsList: list[str] = None, hasVerifiedBadge: bool = None, description: str = None, created: str = None, isBanned: bool = None, externalAppDisplayName: str = None, id: int = None, name: str = None, displayName: str = None):
                ClassObject.friendRequest = friendRequest
                ClassObject.mutualFriendsList = mutualFriendsList
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.description = description
                ClassObject.created = created
                ClassObject.isBanned = isBanned
                ClassObject.externalAppDisplayName = externalAppDisplayName
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class FriendStatusResponse:
            def __init__(ClassObject, id: int = None, status: enum.Enum = None):
                ClassObject.id = id
                ClassObject.status = status
                ClassObject.response: requests.Response = None


        class FriendsCountResponse:
            def __init__(ClassObject, count: int = None):
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class FriendshipRequestModel:
            def __init__(ClassObject, friendshipOriginSourceType: enum.Enum = None, senderNickname: str = None):
                ClassObject.friendshipOriginSourceType = friendshipOriginSourceType
                ClassObject.senderNickname = senderNickname
                ClassObject.response: requests.Response = None


        class FriendingTokenRequestModel:
            def __init__(ClassObject, friendingToken: str = None):
                ClassObject.friendingToken = friendingToken
                ClassObject.response: requests.Response = None


        class DeclineAllFriendRequestsResponse:
            def __init__(ClassObject, backgrounded: bool = None):
                ClassObject.backgrounded = backgrounded
                ClassObject.response: requests.Response = None


        class FollowingExistsResponse:
            def __init__(ClassObject, isFollowing: bool = None, isFollowed: bool = None, userId: int = None):
                ClassObject.isFollowing = isFollowing
                ClassObject.isFollowed = isFollowed
                ClassObject.userId = userId
                ClassObject.response: requests.Response = None


        class FollowingExistsResponseModel:
            def __init__(ClassObject, followings: list["RobloxClient.Friends.FollowingExistsResponse"] = None):
                ClassObject.followings = followings
                ClassObject.response: requests.Response = None


        class FriendResponse:
            def __init__(ClassObject, id: int = None, hasVerifiedBadge: bool = None):
                ClassObject.id = id
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.response: requests.Response = None


        class FriendsPageMetadataResponse:
            def __init__(ClassObject, isFriendsFilterBarEnabled: bool = None, isFriendsPageSortExperimentEnabled: bool = None, isFriendsUserDataStoreCacheEnabled: bool = None, frequentFriendSortRollout: int = None, userName: str = None, displayName: str = None):
                ClassObject.isFriendsFilterBarEnabled = isFriendsFilterBarEnabled
                ClassObject.isFriendsPageSortExperimentEnabled = isFriendsPageSortExperimentEnabled
                ClassObject.isFriendsUserDataStoreCacheEnabled = isFriendsUserDataStoreCacheEnabled
                ClassObject.frequentFriendSortRollout = frequentFriendSortRollout
                ClassObject.userName = userName
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class UserPresenceResponseModel:
            def __init__(ClassObject, UserPresenceType: str = None, UserLocationType: str = None, lastLocation: str = None, placeId: int = None, rootPlaceId: int = None, gameInstanceId: str = None, universeId: int = None, lastOnline: str = None):
                ClassObject.UserPresenceType = UserPresenceType
                ClassObject.UserLocationType = UserLocationType
                ClassObject.lastLocation = lastLocation
                ClassObject.placeId = placeId
                ClassObject.rootPlaceId = rootPlaceId
                ClassObject.gameInstanceId = gameInstanceId
                ClassObject.universeId = universeId
                ClassObject.lastOnline = lastOnline
                ClassObject.response: requests.Response = None


        class UserPresenceResponse:
            def __init__(ClassObject, userPresence: "RobloxClient.Friends.UserPresenceResponseModel" = None, id: int = None, name: str = None, displayName: str = None):
                ClassObject.userPresence = userPresence
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class UserResponse:
            def __init__(ClassObject, isOnline: bool = None, presenceType: enum.Enum = None, isDeleted: bool = None, friendFrequentScore: int = None, friendFrequentRank: int = None, hasVerifiedBadge: bool = None, description: str = None, created: str = None, isBanned: bool = None, externalAppDisplayName: str = None, id: int = None, name: str = None, displayName: str = None):
                ClassObject.isOnline = isOnline
                ClassObject.presenceType = presenceType
                ClassObject.isDeleted = isDeleted
                ClassObject.friendFrequentScore = friendFrequentScore
                ClassObject.friendFrequentRank = friendFrequentRank
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.description = description
                ClassObject.created = created
                ClassObject.isBanned = isBanned
                ClassObject.externalAppDisplayName = externalAppDisplayName
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class PendingFriendRequestCountModel:
            def __init__(ClassObject, count: int = None):
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class FriendResponseExtra:
            def __init__(ClassObject, PreviousCursor: str = None, PageItems: list["RobloxClient.Friends.FriendResponse"] = None, NextCursor: str = None, HasMore: bool = None):
                ClassObject.PreviousCursor = PreviousCursor
                ClassObject.PageItems = PageItems
                ClassObject.NextCursor = NextCursor
                ClassObject.HasMore = HasMore
                ClassObject.response: requests.Response = None


        class Int64Extra:
            def __init__(ClassObject, SortOrder: enum.Enum = None, PagingDirection: enum.Enum = None, Count: int = None):
                ClassObject.SortOrder = SortOrder
                ClassObject.PagingDirection = PagingDirection
                ClassObject.Count = Count
                ClassObject.response: requests.Response = None


        class StringExtra:
            def __init__(ClassObject, key: str = None, sortOrder: enum.Enum = None, pagingDirection: enum.Enum = None, pageNumber: int = None, discriminator: str = None, count: int = None):
                ClassObject.key = key
                ClassObject.sortOrder = sortOrder
                ClassObject.pagingDirection = pagingDirection
                ClassObject.pageNumber = pageNumber
                ClassObject.discriminator = discriminator
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class FriendRequestsPlatformExclusiveStartKeyExtra:
            def __init__(ClassObject, SortOrder: enum.Enum = None, PagingDirection: enum.Enum = None, Count: int = None):
                ClassObject.SortOrder = SortOrder
                ClassObject.PagingDirection = PagingDirection
                ClassObject.Count = Count
                ClassObject.response: requests.Response = None


        class CaptchaTokenRequest:
            def __init__(ClassObject, captchaId: str = None, captchaToken: str = None, captchaProvider: str = None, challengeId: str = None):
                ClassObject.captchaId = captchaId
                ClassObject.captchaToken = captchaToken
                ClassObject.captchaProvider = captchaProvider
                ClassObject.challengeId = challengeId
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class FriendStatusResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Friends.FriendStatusResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class UserPresenceResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Friends.UserPresenceResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class UserResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Friends.UserResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class FriendRequestResponseExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Friends.FriendRequestResponse"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetMetadata(self, targetUserId: int) -> FriendsPageMetadataResponse:
            """
            Unknown
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetMetadata(targetUserId=integer)
        
            Args:
                targetUserId: int
            Returns:
                Friends.FriendsPageMetadataResponse: Friends.FriendsPageMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"targetUserId": targetUserId},"headers": {},"cookies": {}}
            
            GetMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.FriendsPageMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetMetadataRecivedData)
            
            return ResponseSchema
        
        def GetMyFriendsCount(self) -> FriendsCountResponse:
            """
            Get the number of friends a user has
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetMyFriendsCount()
        
            Args:
                
            Returns:
                Friends.FriendsCountResponse: Friends.FriendsCountResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetMyFriendsCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/my/friends/count", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.FriendsCountResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetMyFriendsCountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetMyFriendsCountRecivedData)
            
            return ResponseSchema
        
        def GetMyFriendsRequests(self, limit: int, cursor: str, sortOrder: str) -> FriendRequestResponseExtra:
            """
            Get all users that friend requests with targetUserId using exclusive start paging
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetMyFriendsRequests(limit=integer, cursor=string, sortOrder=string)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            Returns:
                Friends.FriendRequestResponseExtra: Friends.FriendRequestResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetMyFriendsRequestsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/my/friends/requests", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.FriendRequestResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetMyFriendsRequestsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetMyFriendsRequestsRecivedData)
            
            return ResponseSchema
        
        def GetUserFriendRequestsCount(self) -> PendingFriendRequestCountModel:
            """
            Return the number of pending friend requests.
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetUserFriendRequestsCount()
        
            Args:
                
            Returns:
                Friends.PendingFriendRequestCountModel: Friends.PendingFriendRequestCountModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUserFriendRequestsCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/user/friend-requests/count", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.PendingFriendRequestCountModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetUserFriendRequestsCountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUserFriendRequestsCountRecivedData)
            
            return ResponseSchema
        
        def GetUsersTargetuseridFollowers(self, limit: int, cursor: str, sortOrder: str, targetUserId: int) -> UserResponseExtra:
            """
            Get all users that follow user with targetUserId in page response format
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetUsersTargetuseridFollowers(limit=integer, cursor=string, sortOrder=string, targetUserId=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            targetUserId: int
            Returns:
                Friends.UserResponseExtra: Friends.UserResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetUsersTargetuseridFollowersRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/users/{targetUserId}/followers", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.UserResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersTargetuseridFollowersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersTargetuseridFollowersRecivedData)
            
            return ResponseSchema
        
        def GetUsersTargetuseridFollowersCount(self, targetUserId: int) -> FollowCountResponse:
            """
            Get the number of following a user has
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetUsersTargetuseridFollowersCount(targetUserId=integer)
        
            Args:
                targetUserId: int
            Returns:
                Friends.FollowCountResponse: Friends.FollowCountResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersTargetuseridFollowersCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/users/{targetUserId}/followers/count", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.FollowCountResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersTargetuseridFollowersCountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersTargetuseridFollowersCountRecivedData)
            
            return ResponseSchema
        
        def GetUsersTargetuseridFollowings(self, limit: int, cursor: str, sortOrder: str, targetUserId: int) -> UserResponseExtra:
            """
            Get all users that user with targetUserId is following in page response format
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetUsersTargetuseridFollowings(limit=integer, cursor=string, sortOrder=string, targetUserId=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            targetUserId: int
            Returns:
                Friends.UserResponseExtra: Friends.UserResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetUsersTargetuseridFollowingsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/users/{targetUserId}/followings", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.UserResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersTargetuseridFollowingsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersTargetuseridFollowingsRecivedData)
            
            return ResponseSchema
        
        def GetUsersTargetuseridFollowingsCount(self, targetUserId: int) -> FollowCountResponse:
            """
            Get the number of following a user has
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetUsersTargetuseridFollowingsCount(targetUserId=integer)
        
            Args:
                targetUserId: int
            Returns:
                Friends.FollowCountResponse: Friends.FollowCountResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersTargetuseridFollowingsCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/users/{targetUserId}/followings/count", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.FollowCountResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersTargetuseridFollowingsCountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersTargetuseridFollowingsCountRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridFriends(self, userSort: int, userId: int) -> UserResponseExtra:
            """
            Get list of all friends for the specified user.
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetUsersUseridFriends(userSort=integer, userId=integer)
        
            Args:
                userSort: int
            userId: int
            Returns:
                Friends.UserResponseExtra: Friends.UserResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"userSort": userSort},"headers": {},"cookies": {}}
            
            GetUsersUseridFriendsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/users/{userId}/friends", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.UserResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridFriendsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridFriendsRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridFriendsCount(self, userId: int) -> FriendsCountResponse:
            """
            Get the number of friends a user has
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetUsersUseridFriendsCount(userId=integer)
        
            Args:
                userId: int
            Returns:
                Friends.FriendsCountResponse: Friends.FriendsCountResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridFriendsCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/users/{userId}/friends/count", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.FriendsCountResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridFriendsCountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridFriendsCountRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridFriendsFind(self, userSort: int, cursor: str, limit: int, userId: int) -> FriendResponseExtra:
            """
            Get a paginated list of all friends for the specified user.
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetUsersUseridFriendsFind(userSort=integer, cursor=string, limit=integer, userId=integer)
        
            Args:
                userSort: int
            cursor: str
            limit: int
            userId: int
            Returns:
                Friends.FriendResponseExtra: Friends.FriendResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"userSort": userSort, "cursor": cursor, "limit": limit},"headers": {},"cookies": {}}
            
            GetUsersUseridFriendsFindRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/users/{userId}/friends/find", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.FriendResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridFriendsFindRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridFriendsFindRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridFriendsInactive(self, userId: int) -> UserResponseExtra:
            """
            Get list of inactive friends for the specified user.
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetUsersUseridFriendsInactive(userId=integer)
        
            Args:
                userId: int
            Returns:
                Friends.UserResponseExtra: Friends.UserResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridFriendsInactiveRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/users/{userId}/friends/inactive", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.UserResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridFriendsInactiveRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridFriendsInactiveRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridFriendsOnline(self, userSort: int, userId: int) -> UserPresenceResponseExtra:
            """
            Get list of all online friends for the specified user.
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetUsersUseridFriendsOnline(userSort=integer, userId=integer)
        
            Args:
                userSort: int
            userId: int
            Returns:
                Friends.UserPresenceResponseExtra: Friends.UserPresenceResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"userSort": userSort},"headers": {},"cookies": {}}
            
            GetUsersUseridFriendsOnlineRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/users/{userId}/friends/online", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.UserPresenceResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridFriendsOnlineRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridFriendsOnlineRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridFriendsSearch(self, query: str, cursor: str, limit: int, userId: int) -> FriendResponseExtra:
            """
            Search for friends by name using a text query.
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetUsersUseridFriendsSearch(query=string, cursor=string, limit=integer, userId=integer)
        
            Args:
                query: str
            cursor: str
            limit: int
            userId: int
            Returns:
                Friends.FriendResponseExtra: Friends.FriendResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"query": query, "cursor": cursor, "limit": limit},"headers": {},"cookies": {}}
            
            GetUsersUseridFriendsSearchRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/users/{userId}/friends/search", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.FriendResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridFriendsSearchRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridFriendsSearchRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridFriendsStatuses(self, userIds: list, userId: int) -> FriendStatusResponseExtra:
            """
            Gets a list of friend statuses of specified users against the specified user.
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.GetUsersUseridFriendsStatuses(userIds=array, userId=integer)
        
            Args:
                userIds: list
            userId: int
            Returns:
                Friends.FriendStatusResponseExtra: Friends.FriendStatusResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"userIds": userIds},"headers": {},"cookies": {}}
            
            GetUsersUseridFriendsStatusesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Friends.roblox.com/v1/users/{userId}/friends/statuses", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.FriendStatusResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridFriendsStatusesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridFriendsStatusesRecivedData)
            
            return ResponseSchema
        
        def PostContactsTargetcontactidRequestFriendship(self, targetContactId: str) -> CaptchaStatusResponseModel:
            """
            Send a contact friend request to target user
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.PostContactsTargetcontactidRequestFriendship(targetContactId=string)
        
            Args:
                targetContactId: str
            Returns:
                Friends.CaptchaStatusResponseModel: Friends.CaptchaStatusResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostContactsTargetcontactidRequestFriendshipRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Friends.roblox.com/v1/contacts/{targetContactId}/request-friendship", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.CaptchaStatusResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostContactsTargetcontactidRequestFriendshipRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostContactsTargetcontactidRequestFriendshipRecivedData)
            
            return ResponseSchema
        
        def PostUserFollowingExists(self, FollowingExistsRequestModel: FollowingExistsRequestModel) -> FollowingExistsResponseModel:
            """
            Returns whether or not the current user is following each userId in a list of userIds
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.PostUserFollowingExists(FollowingExistsRequestModel=Friends.FollowingExistsRequestModel())
        
            Args:
                FollowingExistsRequestModel: FollowingExistsRequestModel
            Returns:
                Friends.FollowingExistsResponseModel: Friends.FollowingExistsResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'FollowingExistsRequestModel': 'json'}
            Arguments = inspect.signature(self.PostUserFollowingExists)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUserFollowingExistsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Friends.roblox.com/v1/user/following-exists", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.FollowingExistsResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUserFollowingExistsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUserFollowingExistsRecivedData)
            
            return ResponseSchema
        
        def PostUserFriendRequestsDeclineAll(self) -> DeclineAllFriendRequestsResponse:
            """
            Decline all pending friend requests for the authenticated user.
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.PostUserFriendRequestsDeclineAll()
        
            Args:
                
            Returns:
                Friends.DeclineAllFriendRequestsResponse: Friends.DeclineAllFriendRequestsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostUserFriendRequestsDeclineAllRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Friends.roblox.com/v1/user/friend-requests/decline-all", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.DeclineAllFriendRequestsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUserFriendRequestsDeclineAllRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUserFriendRequestsDeclineAllRecivedData)
            
            return ResponseSchema
        
        def PostUsersRequesteruseridAcceptFriendRequest(self, requesterUserId: int) -> ApiEmptyResponseModel:
            """
            Accept a friend request.
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.PostUsersRequesteruseridAcceptFriendRequest(requesterUserId=integer)
        
            Args:
                requesterUserId: int
            Returns:
                Friends.ApiEmptyResponseModel: Friends.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostUsersRequesteruseridAcceptFriendRequestRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Friends.roblox.com/v1/users/{requesterUserId}/accept-friend-request", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersRequesteruseridAcceptFriendRequestRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersRequesteruseridAcceptFriendRequestRecivedData)
            
            return ResponseSchema
        
        def PostUsersRequesteruseridDeclineFriendRequest(self, requesterUserId: int) -> ApiEmptyResponseModel:
            """
            Decline a friend request.
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.PostUsersRequesteruseridDeclineFriendRequest(requesterUserId=integer)
        
            Args:
                requesterUserId: int
            Returns:
                Friends.ApiEmptyResponseModel: Friends.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostUsersRequesteruseridDeclineFriendRequestRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Friends.roblox.com/v1/users/{requesterUserId}/decline-friend-request", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersRequesteruseridDeclineFriendRequestRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersRequesteruseridDeclineFriendRequestRecivedData)
            
            return ResponseSchema
        
        def PostUsersSenderuseridAcceptFriendRequestWithToken(self, senderUserId: int, FriendingTokenRequestModel: FriendingTokenRequestModel) -> ApiEmptyResponseModel:
            """
            Accept a friend request with an Off Network Friending token.
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.PostUsersSenderuseridAcceptFriendRequestWithToken(senderUserId=integer, FriendingTokenRequestModel=Friends.FriendingTokenRequestModel())
        
            Args:
                senderUserId: int
            FriendingTokenRequestModel: FriendingTokenRequestModel
            Returns:
                Friends.ApiEmptyResponseModel: Friends.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'FriendingTokenRequestModel': 'json'}
            Arguments = inspect.signature(self.PostUsersSenderuseridAcceptFriendRequestWithToken)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersSenderuseridAcceptFriendRequestWithTokenRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Friends.roblox.com/v1/users/{senderUserId}/accept-friend-request-with-token", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersSenderuseridAcceptFriendRequestWithTokenRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersSenderuseridAcceptFriendRequestWithTokenRecivedData)
            
            return ResponseSchema
        
        def PostUsersTargetuseridFollow(self, targetUserId: int, CaptchaTokenRequest: CaptchaTokenRequest) -> CaptchaStatusResponseModel:
            """
            Creates the following between a user and user with targetUserId
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.PostUsersTargetuseridFollow(targetUserId=integer, CaptchaTokenRequest=Friends.CaptchaTokenRequest())
        
            Args:
                targetUserId: int
            CaptchaTokenRequest: CaptchaTokenRequest
            Returns:
                Friends.CaptchaStatusResponseModel: Friends.CaptchaStatusResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'CaptchaTokenRequest': 'json'}
            Arguments = inspect.signature(self.PostUsersTargetuseridFollow)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersTargetuseridFollowRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Friends.roblox.com/v1/users/{targetUserId}/follow", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.CaptchaStatusResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersTargetuseridFollowRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersTargetuseridFollowRecivedData)
            
            return ResponseSchema
        
        def PostUsersTargetuseridRequestFriendship(self, targetUserId: int, FriendshipRequestModel: FriendshipRequestModel) -> CaptchaStatusResponseModel:
            """
            Send a friend request to target user
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.PostUsersTargetuseridRequestFriendship(targetUserId=integer, FriendshipRequestModel=Friends.FriendshipRequestModel())
        
            Args:
                targetUserId: int
            FriendshipRequestModel: FriendshipRequestModel
            Returns:
                Friends.CaptchaStatusResponseModel: Friends.CaptchaStatusResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'FriendshipRequestModel': 'json'}
            Arguments = inspect.signature(self.PostUsersTargetuseridRequestFriendship)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsersTargetuseridRequestFriendshipRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Friends.roblox.com/v1/users/{targetUserId}/request-friendship", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.CaptchaStatusResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersTargetuseridRequestFriendshipRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersTargetuseridRequestFriendshipRecivedData)
            
            return ResponseSchema
        
        def PostUsersTargetuseridUnfollow(self, targetUserId: int) -> ApiEmptyResponseModel:
            """
            Deletes the following between a user and user with targetUserId
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.PostUsersTargetuseridUnfollow(targetUserId=integer)
        
            Args:
                targetUserId: int
            Returns:
                Friends.ApiEmptyResponseModel: Friends.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostUsersTargetuseridUnfollowRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Friends.roblox.com/v1/users/{targetUserId}/unfollow", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersTargetuseridUnfollowRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersTargetuseridUnfollowRecivedData)
            
            return ResponseSchema
        
        def PostUsersTargetuseridUnfriend(self, targetUserId: int) -> ApiEmptyResponseModel:
            """
            Unfriend a user
            
            Usage:
                import Friends
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FriendsApi = Friends.FriendsApi(RobloxClient=RobloxClient)
                Response = FriendsApi.PostUsersTargetuseridUnfriend(targetUserId=integer)
        
            Args:
                targetUserId: int
            Returns:
                Friends.ApiEmptyResponseModel: Friends.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostUsersTargetuseridUnfriendRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Friends.roblox.com/v1/users/{targetUserId}/unfriend", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Friends.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersTargetuseridUnfriendRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersTargetuseridUnfriendRecivedData)
            
            return ResponseSchema
        
    class Followings:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class UserFollowingUniverseResponse:
            def __init__(ClassObject, universeId: int = None, userId: int = None):
                ClassObject.universeId = universeId
                ClassObject.userId = userId
                ClassObject.response: requests.Response = None


        class UserFollowingUniverseStatusResponse:
            def __init__(ClassObject, UniverseId: int = None, UserId: int = None, CanFollow: bool = None, IsFollowing: bool = None, FollowingCountByType: int = None, FollowingLimitByType: int = None):
                ClassObject.UniverseId = UniverseId
                ClassObject.UserId = UserId
                ClassObject.CanFollow = CanFollow
                ClassObject.IsFollowing = IsFollowing
                ClassObject.FollowingCountByType = FollowingCountByType
                ClassObject.FollowingLimitByType = FollowingLimitByType
                ClassObject.response: requests.Response = None



        
        def GetUsersUseridUniverses(self, userId: int) -> requests.Response:
            """
            Gets all the followings between a user with userId and universes
            
            Usage:
                import Followings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FollowingsApi = Followings.FollowingsApi(RobloxClient=RobloxClient)
                Response = FollowingsApi.GetUsersUseridUniverses(userId=integer)
        
            Args:
                userId: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridUniversesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Followings.roblox.com/v1/users/{userId}/universes", Dictinary=Dictinary)
            return GetUsersUseridUniversesRecivedData
        
        def GetUsersUseridUniversesUniverseidStatus(self, userId: int, universeId: int) -> UserFollowingUniverseStatusResponse:
            """
            Gets the status of a following relationship between a user and a universe.
            
            Usage:
                import Followings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FollowingsApi = Followings.FollowingsApi(RobloxClient=RobloxClient)
                Response = FollowingsApi.GetUsersUseridUniversesUniverseidStatus(userId=integer, universeId=integer)
        
            Args:
                userId: int
            universeId: int
            Returns:
                Followings.UserFollowingUniverseStatusResponse: Followings.UserFollowingUniverseStatusResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridUniversesUniverseidStatusRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Followings.roblox.com/v1/users/{userId}/universes/{universeId}/status", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Followings.UserFollowingUniverseStatusResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridUniversesUniverseidStatusRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridUniversesUniverseidStatusRecivedData)
            
            return ResponseSchema
        
        def DeleteUsersUseridUniversesUniverseid(self, userId: int, universeId: int) -> UserFollowingUniverseResponse:
            """
            Deletes the following between a user with userId and universe with universeId
            
            Usage:
                import Followings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FollowingsApi = Followings.FollowingsApi(RobloxClient=RobloxClient)
                Response = FollowingsApi.DeleteUsersUseridUniversesUniverseid(userId=integer, universeId=integer)
        
            Args:
                userId: int
            universeId: int
            Returns:
                Followings.UserFollowingUniverseResponse: Followings.UserFollowingUniverseResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteUsersUseridUniversesUniverseidRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Followings.roblox.com/v1/users/{userId}/universes/{universeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Followings.UserFollowingUniverseResponse()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteUsersUseridUniversesUniverseidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteUsersUseridUniversesUniverseidRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridUniversesUniverseid(self, userId: int, universeId: int) -> UserFollowingUniverseResponse:
            """
            Creates the following between a user with userId and universe with universeId
            
            Usage:
                import Followings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                FollowingsApi = Followings.FollowingsApi(RobloxClient=RobloxClient)
                Response = FollowingsApi.PostUsersUseridUniversesUniverseid(userId=integer, universeId=integer)
        
            Args:
                userId: int
            universeId: int
            Returns:
                Followings.UserFollowingUniverseResponse: Followings.UserFollowingUniverseResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostUsersUseridUniversesUniverseidRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Followings.roblox.com/v1/users/{userId}/universes/{universeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Followings.UserFollowingUniverseResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridUniversesUniverseidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridUniversesUniverseidRecivedData)
            
            return ResponseSchema
        
    class EngagementPayouts:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class PayoutResponseModel:
            def __init__(ClassObject, engagementScore: float = None, payoutInRobux: int = None, payoutType: str = None, eligibilityType: str = None):
                ClassObject.engagementScore = engagementScore
                ClassObject.payoutInRobux = payoutInRobux
                ClassObject.payoutType = payoutType
                ClassObject.eligibilityType = eligibilityType
                ClassObject.response: requests.Response = None



        
        def GetUniversePayoutHistory(self, universeId: int, startDate: str, endDate: str) -> requests.Response:
            """
            Gets the engagement payout history for a specific universe and a given date range, specified by start and end dates.
            
            Usage:
                import EngagementPayouts
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                EngagementPayoutsApi = EngagementPayouts.EngagementPayoutsApi(RobloxClient=RobloxClient)
                Response = EngagementPayoutsApi.GetUniversePayoutHistory(universeId=integer, startDate=string, endDate=string)
        
            Args:
                universeId: int
            startDate: str
            endDate: str
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"universeId": universeId, "startDate": startDate, "endDate": endDate},"headers": {},"cookies": {}}
            
            GetUniversePayoutHistoryRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://EngagementPayouts.roblox.com/v1/universe-payout-history", Dictinary=Dictinary)
            return GetUniversePayoutHistoryRecivedData
        
    class EconomyCreatorStats:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class StatisticsResponse:
            def __init__(ClassObject, dataGranularity: enum.Enum = None, data: typing.Dict[str, list[any]] = None):
                ClassObject.dataGranularity = dataGranularity
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetUniversesUniverseidStats(self, Type: str, StartTime: str, EndTime: str, universeId: int) -> StatisticsResponse:
            """
            Get statistics data for a universe.
            
            Usage:
                import EconomyCreatorStats
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                EconomyCreatorStatsApi = EconomyCreatorStats.EconomyCreatorStatsApi(RobloxClient=RobloxClient)
                Response = EconomyCreatorStatsApi.GetUniversesUniverseidStats(Type=string, StartTime=string, EndTime=string, universeId=integer)
        
            Args:
                Type: str
            StartTime: str
            EndTime: str
            universeId: int
            Returns:
                EconomyCreatorStats.StatisticsResponse: EconomyCreatorStats.StatisticsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"Type": Type, "StartTime": StartTime, "EndTime": EndTime},"headers": {},"cookies": {}}
            
            GetUniversesUniverseidStatsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://EconomyCreatorStats.roblox.com/v1/universes/{universeId}/stats", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.EconomyCreatorStats.StatisticsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUniversesUniverseidStatsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUniversesUniverseidStatsRecivedData)
            
            return ResponseSchema
        
    class Economy:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class CurrencyResponse:
            def __init__(ClassObject, robux: int = None):
                ClassObject.robux = robux
                ClassObject.response: requests.Response = None



        
        def GetUserCurrency(self) -> CurrencyResponse:
            """
            Gets currency for the authenticated user.
            
            Usage:
                import Economy
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                EconomyApi = Economy.EconomyApi(RobloxClient=RobloxClient)
                Response = EconomyApi.GetUserCurrency()
        
            Args:
                
            Returns:
                Economy.CurrencyResponse: Economy.CurrencyResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUserCurrencyRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Economy.roblox.com/v1/user/currency", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Economy.CurrencyResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUserCurrencyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUserCurrencyRecivedData)
            
            return ResponseSchema
        
    class Develop:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class UniverseModel:
            def __init__(ClassObject, id: int = None, name: str = None, description: str = None, isArchived: bool = None, rootPlaceId: int = None, isActive: bool = None, privacyType: str = None, creatorType: str = None, creatorTargetId: int = None, creatorName: str = None, created: str = None, updated: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.isArchived = isArchived
                ClassObject.rootPlaceId = rootPlaceId
                ClassObject.isActive = isActive
                ClassObject.privacyType = privacyType
                ClassObject.creatorType = creatorType
                ClassObject.creatorTargetId = creatorTargetId
                ClassObject.creatorName = creatorName
                ClassObject.created = created
                ClassObject.updated = updated
                ClassObject.response: requests.Response = None


        class GameTemplateModel:
            def __init__(ClassObject, gameTemplateType: str = None, hasTutorials: bool = None, universe: "RobloxClient.Develop.UniverseModel" = None):
                ClassObject.gameTemplateType = gameTemplateType
                ClassObject.hasTutorials = hasTutorials
                ClassObject.universe = universe
                ClassObject.response: requests.Response = None


        class GroupModel:
            def __init__(ClassObject, id: int = None, name: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class IPlaceModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class PlaceConfigurationModel:
            def __init__(ClassObject, name: str = None, description: str = None):
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class PlaceModel:
            def __init__(ClassObject, id: int = None, universeId: int = None, name: str = None, description: str = None):
                ClassObject.id = id
                ClassObject.universeId = universeId
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class PrivateServerDetailsResponse:
            def __init__(ClassObject, isEnabled: bool = None, price: int = None, activeServersCount: int = None, activeSubscriptionsCount: int = None):
                ClassObject.isEnabled = isEnabled
                ClassObject.price = price
                ClassObject.activeServersCount = activeServersCount
                ClassObject.activeSubscriptionsCount = activeSubscriptionsCount
                ClassObject.response: requests.Response = None


        class AssetVotingModel:
            def __init__(ClassObject, assetId: int = None, hasUserVoted: bool = None, canUserVote: bool = None, shouldShowVotes: bool = None, upVotes: int = None, downVotes: int = None, reasonForNotAbleToVote: str = None):
                ClassObject.assetId = assetId
                ClassObject.hasUserVoted = hasUserVoted
                ClassObject.canUserVote = canUserVote
                ClassObject.shouldShowVotes = shouldShowVotes
                ClassObject.upVotes = upVotes
                ClassObject.downVotes = downVotes
                ClassObject.reasonForNotAbleToVote = reasonForNotAbleToVote
                ClassObject.response: requests.Response = None


        class TeamCreateSettingsResponse:
            def __init__(ClassObject, isEnabled: bool = None):
                ClassObject.isEnabled = isEnabled
                ClassObject.response: requests.Response = None


        class TeamCreateMembershipRequest:
            def __init__(ClassObject, userId: int = None):
                ClassObject.userId = userId
                ClassObject.response: requests.Response = None


        class UniverseIdPermissionsModel:
            def __init__(ClassObject, universeId: int = None, canManage: bool = None, canCloudEdit: bool = None):
                ClassObject.universeId = universeId
                ClassObject.canManage = canManage
                ClassObject.canCloudEdit = canCloudEdit
                ClassObject.response: requests.Response = None


        class UniversePermissionsModel:
            def __init__(ClassObject, canManage: bool = None, canCloudEdit: bool = None):
                ClassObject.canManage = canManage
                ClassObject.canCloudEdit = canCloudEdit
                ClassObject.response: requests.Response = None


        class UniverseSettingsRequest:
            def __init__(ClassObject, name: str = None, universeAvatarType: enum.Enum = None, universeScaleType: enum.Enum = None, universeAnimationType: enum.Enum = None, universeCollisionType: enum.Enum = None, universeBodyType: enum.Enum = None, universeJointPositioningType: enum.Enum = None, isArchived: bool = None, isFriendsOnly: bool = None, genre: enum.Enum = None, playableDevices: list[int] = None, isForSale: bool = None, price: int = None, isMeshTextureApiAccessAllowed: bool = None):
                ClassObject.name = name
                ClassObject.universeAvatarType = universeAvatarType
                ClassObject.universeScaleType = universeScaleType
                ClassObject.universeAnimationType = universeAnimationType
                ClassObject.universeCollisionType = universeCollisionType
                ClassObject.universeBodyType = universeBodyType
                ClassObject.universeJointPositioningType = universeJointPositioningType
                ClassObject.isArchived = isArchived
                ClassObject.isFriendsOnly = isFriendsOnly
                ClassObject.genre = genre
                ClassObject.playableDevices = playableDevices
                ClassObject.isForSale = isForSale
                ClassObject.price = price
                ClassObject.isMeshTextureApiAccessAllowed = isMeshTextureApiAccessAllowed
                ClassObject.response: requests.Response = None


        class UniverseSettingsResponse:
            def __init__(ClassObject, allowPrivateServers: bool = None, privateServerPrice: int = None, isMeshTextureApiAccessAllowed: bool = None, id: int = None, name: str = None, universeAvatarType: enum.Enum = None, universeScaleType: enum.Enum = None, universeAnimationType: enum.Enum = None, universeCollisionType: enum.Enum = None, universeBodyType: enum.Enum = None, universeJointPositioningType: enum.Enum = None, isArchived: bool = None, isFriendsOnly: bool = None, genre: enum.Enum = None, playableDevices: list[int] = None, isForSale: bool = None, price: int = None, isStudioAccessToApisAllowed: bool = None, privacyType: str = None):
                ClassObject.allowPrivateServers = allowPrivateServers
                ClassObject.privateServerPrice = privateServerPrice
                ClassObject.isMeshTextureApiAccessAllowed = isMeshTextureApiAccessAllowed
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.universeAvatarType = universeAvatarType
                ClassObject.universeScaleType = universeScaleType
                ClassObject.universeAnimationType = universeAnimationType
                ClassObject.universeCollisionType = universeCollisionType
                ClassObject.universeBodyType = universeBodyType
                ClassObject.universeJointPositioningType = universeJointPositioningType
                ClassObject.isArchived = isArchived
                ClassObject.isFriendsOnly = isFriendsOnly
                ClassObject.genre = genre
                ClassObject.playableDevices = playableDevices
                ClassObject.isForSale = isForSale
                ClassObject.price = price
                ClassObject.isStudioAccessToApisAllowed = isStudioAccessToApisAllowed
                ClassObject.privacyType = privacyType
                ClassObject.response: requests.Response = None


        class UniverseTeamCreateSettingsModel:
            def __init__(ClassObject, id: int = None, isEnabled: bool = None):
                ClassObject.id = id
                ClassObject.isEnabled = isEnabled
                ClassObject.response: requests.Response = None


        class UpdateTeamCreateSettingsRequest:
            def __init__(ClassObject, isEnabled: bool = None):
                ClassObject.isEnabled = isEnabled
                ClassObject.response: requests.Response = None


        class UpdatePluginRequest:
            def __init__(ClassObject, name: str = None, description: str = None, commentsEnabled: bool = None):
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.commentsEnabled = commentsEnabled
                ClassObject.response: requests.Response = None


        class StartIndexCursor:
            def __init__(ClassObject, startIndex: int = None, discriminator: str = None, count: int = None):
                ClassObject.startIndex = startIndex
                ClassObject.discriminator = discriminator
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class Int64Extra:
            def __init__(ClassObject, SortOrder: enum.Enum = None, PagingDirection: enum.Enum = None, Count: int = None):
                ClassObject.SortOrder = SortOrder
                ClassObject.PagingDirection = PagingDirection
                ClassObject.Count = Count
                ClassObject.response: requests.Response = None


        class PluginResponse:
            def __init__(ClassObject, id: int = None, name: str = None, description: str = None, commentsEnabled: bool = None, versionId: int = None, created: str = None, updated: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.commentsEnabled = commentsEnabled
                ClassObject.versionId = versionId
                ClassObject.created = created
                ClassObject.updated = updated
                ClassObject.response: requests.Response = None


        class SkinnyUserResponse:
            def __init__(ClassObject, id: int = None, name: str = None, displayName: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class GameTemplateModelExtra:
            def __init__(ClassObject, data: list["RobloxClient.Develop.GameTemplateModel"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GroupModelExtra:
            def __init__(ClassObject, data: list["RobloxClient.Develop.GroupModel"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class AssetVotingModelExtra:
            def __init__(ClassObject, data: list["RobloxClient.Develop.AssetVotingModel"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class UniverseIdPermissionsModelExtra:
            def __init__(ClassObject, data: list["RobloxClient.Develop.UniverseIdPermissionsModel"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class UniverseModelExtra:
            def __init__(ClassObject, data: list["RobloxClient.Develop.UniverseModel"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class UniverseTeamCreateSettingsModelExtra:
            def __init__(ClassObject, data: list["RobloxClient.Develop.UniverseTeamCreateSettingsModel"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class PluginResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Develop.PluginResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class SkinnyUserResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Develop.SkinnyUserResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class IPlaceModelExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Develop.IPlaceModel"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetAssetsVoting(self, assetIds: list) -> AssetVotingModelExtra:
            """
            Gets the voting information of the given assets
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetAssetsVoting(assetIds=array)
        
            Args:
                assetIds: list
            Returns:
                Develop.AssetVotingModelExtra: Develop.AssetVotingModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"assetIds": assetIds},"headers": {},"cookies": {}}
            
            GetAssetsVotingRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/assets/voting", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.AssetVotingModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetAssetsVotingRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAssetsVotingRecivedData)
            
            return ResponseSchema
        
        def GetGametemplates(self) -> GameTemplateModelExtra:
            """
            Gets a page of templates that can be used to start off making games.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetGametemplates()
        
            Args:
                
            Returns:
                Develop.GameTemplateModelExtra: Develop.GameTemplateModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGametemplatesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/gametemplates", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.GameTemplateModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGametemplatesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGametemplatesRecivedData)
            
            return ResponseSchema
        
        def GetGroupsGroupidUniverses(self, isArchived: bool, limit: int, cursor: str, sortOrder: str, groupId: int) -> UniverseModelExtra:
            """
            Gets a list of universes for the given group.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetGroupsGroupidUniverses(isArchived=boolean, limit=integer, cursor=string, sortOrder=string, groupId=integer)
        
            Args:
                isArchived: bool
            limit: int
            cursor: str
            sortOrder: str
            groupId: int
            Returns:
                Develop.UniverseModelExtra: Develop.UniverseModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"isArchived": isArchived, "limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetGroupsGroupidUniversesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/groups/{groupId}/universes", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.UniverseModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetGroupsGroupidUniversesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGroupsGroupidUniversesRecivedData)
            
            return ResponseSchema
        
        def GetPlacesPlaceidTeamcreateActive_SessionMembers(self, limit: int, cursor: str, placeId: int) -> SkinnyUserResponseExtra:
            """
            List of users in the active Team Create session
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetPlacesPlaceidTeamcreateActive_SessionMembers(limit=integer, cursor=string, placeId=integer)
        
            Args:
                limit: int
            cursor: str
            placeId: int
            Returns:
                Develop.SkinnyUserResponseExtra: Develop.SkinnyUserResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor},"headers": {},"cookies": {}}
            
            GetPlacesPlaceidTeamcreateActive_SessionMembersRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/places/{placeId}/teamcreate/active_session/members", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.SkinnyUserResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetPlacesPlaceidTeamcreateActive_SessionMembersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPlacesPlaceidTeamcreateActive_SessionMembersRecivedData)
            
            return ResponseSchema
        
        def GetPlugins(self, pluginIds: list) -> PluginResponseExtra:
            """
            Gets plugin details by ids.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetPlugins(pluginIds=array)
        
            Args:
                pluginIds: list
            Returns:
                Develop.PluginResponseExtra: Develop.PluginResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"pluginIds": pluginIds},"headers": {},"cookies": {}}
            
            GetPluginsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/plugins", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.PluginResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetPluginsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPluginsRecivedData)
            
            return ResponseSchema
        
        def GetUniversesUniverseid(self, universeId: int) -> UniverseModel:
            """
            Gets a Roblox.Api.Develop.Models.UniverseModel.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetUniversesUniverseid(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Develop.UniverseModel: Develop.UniverseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUniversesUniverseidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/universes/{universeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.UniverseModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetUniversesUniverseidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUniversesUniverseidRecivedData)
            
            return ResponseSchema
        
        def GetUniversesUniverseidConfiguration(self, universeId: int) -> UniverseSettingsResponse:
            """
            Get settings for an owned universe.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetUniversesUniverseidConfiguration(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Develop.UniverseSettingsResponse: Develop.UniverseSettingsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUniversesUniverseidConfigurationRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/universes/{universeId}/configuration", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.UniverseSettingsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUniversesUniverseidConfigurationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUniversesUniverseidConfigurationRecivedData)
            
            return ResponseSchema
        
        def PatchUniversesUniverseidConfiguration(self, universeId: int, UniverseSettingsRequest: UniverseSettingsRequest) -> UniverseSettingsResponse:
            """
            Update universe settings for an owned universe.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.PatchUniversesUniverseidConfiguration(universeId=integer, UniverseSettingsRequest=Develop.UniverseSettingsRequest())
        
            Args:
                universeId: int
            UniverseSettingsRequest: UniverseSettingsRequest
            Returns:
                Develop.UniverseSettingsResponse: Develop.UniverseSettingsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UniverseSettingsRequest': 'json'}
            Arguments = inspect.signature(self.PatchUniversesUniverseidConfiguration)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchUniversesUniverseidConfigurationRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Develop.roblox.com/v1/universes/{universeId}/configuration", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.UniverseSettingsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchUniversesUniverseidConfigurationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchUniversesUniverseidConfigurationRecivedData)
            
            return ResponseSchema
        
        def GetUniversesUniverseidConfigurationVipServers(self, universeId: int) -> PrivateServerDetailsResponse:
            """
            Get settings for an owned universe's VIP servers.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetUniversesUniverseidConfigurationVipServers(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Develop.PrivateServerDetailsResponse: Develop.PrivateServerDetailsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUniversesUniverseidConfigurationVipServersRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/universes/{universeId}/configuration/vip-servers", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.PrivateServerDetailsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUniversesUniverseidConfigurationVipServersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUniversesUniverseidConfigurationVipServersRecivedData)
            
            return ResponseSchema
        
        def GetUniversesUniverseidPermissions(self, universeId: int) -> UniversePermissionsModel:
            """
            Returns list of granted and declined permissions related to the universe with the id universeId for authenticated user
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetUniversesUniverseidPermissions(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Develop.UniversePermissionsModel: Develop.UniversePermissionsModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUniversesUniverseidPermissionsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/universes/{universeId}/permissions", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.UniversePermissionsModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetUniversesUniverseidPermissionsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUniversesUniverseidPermissionsRecivedData)
            
            return ResponseSchema
        
        def GetUniversesUniverseidPlaces(self, isUniverseCreation: bool, limit: int, cursor: str, sortOrder: str, universeId: int) -> IPlaceModelExtra:
            """
            Gets a list of places for a universe.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetUniversesUniverseidPlaces(isUniverseCreation=boolean, limit=integer, cursor=string, sortOrder=string, universeId=integer)
        
            Args:
                isUniverseCreation: bool
            limit: int
            cursor: str
            sortOrder: str
            universeId: int
            Returns:
                Develop.IPlaceModelExtra: Develop.IPlaceModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"isUniverseCreation": isUniverseCreation, "limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetUniversesUniverseidPlacesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/universes/{universeId}/places", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.IPlaceModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUniversesUniverseidPlacesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUniversesUniverseidPlacesRecivedData)
            
            return ResponseSchema
        
        def GetUniversesUniverseidTeamcreate(self, universeId: int) -> TeamCreateSettingsResponse:
            """
            Gets TeamCreate settings for an Roblox.Platform.Universes.IUniverse.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetUniversesUniverseidTeamcreate(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Develop.TeamCreateSettingsResponse: Develop.TeamCreateSettingsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUniversesUniverseidTeamcreateRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/universes/{universeId}/teamcreate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.TeamCreateSettingsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUniversesUniverseidTeamcreateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUniversesUniverseidTeamcreateRecivedData)
            
            return ResponseSchema
        
        def PatchUniversesUniverseidTeamcreate(self, universeId: int, UpdateTeamCreateSettingsRequest: UpdateTeamCreateSettingsRequest) -> ApiEmptyResponseModel:
            """
            Edit team create settings for a universe.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.PatchUniversesUniverseidTeamcreate(universeId=integer, UpdateTeamCreateSettingsRequest=Develop.UpdateTeamCreateSettingsRequest())
        
            Args:
                universeId: int
            UpdateTeamCreateSettingsRequest: UpdateTeamCreateSettingsRequest
            Returns:
                Develop.ApiEmptyResponseModel: Develop.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateTeamCreateSettingsRequest': 'json'}
            Arguments = inspect.signature(self.PatchUniversesUniverseidTeamcreate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchUniversesUniverseidTeamcreateRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Develop.roblox.com/v1/universes/{universeId}/teamcreate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchUniversesUniverseidTeamcreateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchUniversesUniverseidTeamcreateRecivedData)
            
            return ResponseSchema
        
        def GetUniversesMultiget(self, ids: list) -> UniverseModelExtra:
            """
            Gets a System.Collections.Generic.List`1.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetUniversesMultiget(ids=array)
        
            Args:
                ids: list
            Returns:
                Develop.UniverseModelExtra: Develop.UniverseModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"ids": ids},"headers": {},"cookies": {}}
            
            GetUniversesMultigetRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/universes/multiget", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.UniverseModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUniversesMultigetRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUniversesMultigetRecivedData)
            
            return ResponseSchema
        
        def GetUniversesMultigetPermissions(self, ids: list) -> UniverseIdPermissionsModelExtra:
            """
            Returns an array of granted and declined permissions related to the universes with the ids in ids for the authenticated user.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetUniversesMultigetPermissions(ids=array)
        
            Args:
                ids: list
            Returns:
                Develop.UniverseIdPermissionsModelExtra: Develop.UniverseIdPermissionsModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"ids": ids},"headers": {},"cookies": {}}
            
            GetUniversesMultigetPermissionsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/universes/multiget/permissions", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.UniverseIdPermissionsModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUniversesMultigetPermissionsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUniversesMultigetPermissionsRecivedData)
            
            return ResponseSchema
        
        def GetUniversesMultigetTeamcreate(self, ids: list) -> UniverseTeamCreateSettingsModelExtra:
            """
            Gets TeamCreate settings for multiple universes specified by Ids
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetUniversesMultigetTeamcreate(ids=array)
        
            Args:
                ids: list
            Returns:
                Develop.UniverseTeamCreateSettingsModelExtra: Develop.UniverseTeamCreateSettingsModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"ids": ids},"headers": {},"cookies": {}}
            
            GetUniversesMultigetTeamcreateRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/universes/multiget/teamcreate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.UniverseTeamCreateSettingsModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUniversesMultigetTeamcreateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUniversesMultigetTeamcreateRecivedData)
            
            return ResponseSchema
        
        def GetUserGroupsCanmanage(self) -> GroupModelExtra:
            """
            Gets a list of Groups that a user can manage.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetUserGroupsCanmanage()
        
            Args:
                
            Returns:
                Develop.GroupModelExtra: Develop.GroupModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUserGroupsCanmanageRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/user/groups/canmanage", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.GroupModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUserGroupsCanmanageRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUserGroupsCanmanageRecivedData)
            
            return ResponseSchema
        
        def GetUserGroupsCanmanagegamesoritems(self) -> GroupModelExtra:
            """
            Gets a list of groups a user can manage games or items for.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetUserGroupsCanmanagegamesoritems()
        
            Args:
                
            Returns:
                Develop.GroupModelExtra: Develop.GroupModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUserGroupsCanmanagegamesoritemsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/user/groups/canmanagegamesoritems", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.GroupModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUserGroupsCanmanagegamesoritemsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUserGroupsCanmanagegamesoritemsRecivedData)
            
            return ResponseSchema
        
        def GetUserUniverses(self, isArchived: bool, limit: int, cursor: str, sortOrder: str) -> UniverseModelExtra:
            """
            Gets a list of universes for the authenticated user.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.GetUserUniverses(isArchived=boolean, limit=integer, cursor=string, sortOrder=string)
        
            Args:
                isArchived: bool
            limit: int
            cursor: str
            sortOrder: str
            Returns:
                Develop.UniverseModelExtra: Develop.UniverseModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"isArchived": isArchived, "limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetUserUniversesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Develop.roblox.com/v1/user/universes", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.UniverseModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUserUniversesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUserUniversesRecivedData)
            
            return ResponseSchema
        
        def PatchPlacesPlaceid(self, placeId: int, PlaceConfigurationModel: PlaceConfigurationModel) -> PlaceModel:
            """
            Updates the place configuration for the place with the id placeId
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.PatchPlacesPlaceid(placeId=integer, PlaceConfigurationModel=Develop.PlaceConfigurationModel())
        
            Args:
                placeId: int
            PlaceConfigurationModel: PlaceConfigurationModel
            Returns:
                Develop.PlaceModel: Develop.PlaceModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PlaceConfigurationModel': 'json'}
            Arguments = inspect.signature(self.PatchPlacesPlaceid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchPlacesPlaceidRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Develop.roblox.com/v1/places/{placeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.PlaceModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchPlacesPlaceidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchPlacesPlaceidRecivedData)
            
            return ResponseSchema
        
        def PostPlacesPlaceid(self, placeId: int, PlaceConfigurationModel: PlaceConfigurationModel) -> PlaceModel:
            """
            Updates the place configuration for the place with the id placeId
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.PostPlacesPlaceid(placeId=integer, PlaceConfigurationModel=Develop.PlaceConfigurationModel())
        
            Args:
                placeId: int
            PlaceConfigurationModel: PlaceConfigurationModel
            Returns:
                Develop.PlaceModel: Develop.PlaceModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PlaceConfigurationModel': 'json'}
            Arguments = inspect.signature(self.PostPlacesPlaceid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPlacesPlaceidRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Develop.roblox.com/v1/places/{placeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.PlaceModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPlacesPlaceidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPlacesPlaceidRecivedData)
            
            return ResponseSchema
        
        def PostUniversesUniverseidActivate(self, universeId: int) -> ApiEmptyResponseModel:
            """
            Activates a universes.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.PostUniversesUniverseidActivate(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Develop.ApiEmptyResponseModel: Develop.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostUniversesUniverseidActivateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Develop.roblox.com/v1/universes/{universeId}/activate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUniversesUniverseidActivateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUniversesUniverseidActivateRecivedData)
            
            return ResponseSchema
        
        def PostUniversesUniverseidDeactivate(self, universeId: int) -> ApiEmptyResponseModel:
            """
            Deactivates a universe.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.PostUniversesUniverseidDeactivate(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Develop.ApiEmptyResponseModel: Develop.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostUniversesUniverseidDeactivateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Develop.roblox.com/v1/universes/{universeId}/deactivate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUniversesUniverseidDeactivateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUniversesUniverseidDeactivateRecivedData)
            
            return ResponseSchema
        
        def PatchPluginsPluginid(self, pluginId: int, UpdatePluginRequest: UpdatePluginRequest) -> ApiEmptyResponseModel:
            """
            Updates a plugin.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.PatchPluginsPluginid(pluginId=integer, UpdatePluginRequest=Develop.UpdatePluginRequest())
        
            Args:
                pluginId: int
            UpdatePluginRequest: UpdatePluginRequest
            Returns:
                Develop.ApiEmptyResponseModel: Develop.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdatePluginRequest': 'json'}
            Arguments = inspect.signature(self.PatchPluginsPluginid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchPluginsPluginidRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Develop.roblox.com/v1/plugins/{pluginId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchPluginsPluginidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchPluginsPluginidRecivedData)
            
            return ResponseSchema
        
        def DeleteUniversesUniverseidTeamcreateMemberships(self, universeId: int, TeamCreateMembershipRequest: TeamCreateMembershipRequest) -> ApiEmptyResponseModel:
            """
            Removes a user from a TeamCreate permissions list.
            
            Usage:
                import Develop
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                DevelopApi = Develop.DevelopApi(RobloxClient=RobloxClient)
                Response = DevelopApi.DeleteUniversesUniverseidTeamcreateMemberships(universeId=integer, TeamCreateMembershipRequest=Develop.TeamCreateMembershipRequest())
        
            Args:
                universeId: int
            TeamCreateMembershipRequest: TeamCreateMembershipRequest
            Returns:
                Develop.ApiEmptyResponseModel: Develop.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'TeamCreateMembershipRequest': 'json'}
            Arguments = inspect.signature(self.DeleteUniversesUniverseidTeamcreateMemberships)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            DeleteUniversesUniverseidTeamcreateMembershipsRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Develop.roblox.com/v1/universes/{universeId}/teamcreate/memberships", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Develop.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteUniversesUniverseidTeamcreateMembershipsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteUniversesUniverseidTeamcreateMembershipsRecivedData)
            
            return ResponseSchema
        
    class Contacts:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class ContactsMetadataResponseModel:
            def __init__(ClassObject, multiGetContactsMaxSize: int = None, multiGetContactsCacheTTLinMS: int = None):
                ClassObject.multiGetContactsMaxSize = multiGetContactsMaxSize
                ClassObject.multiGetContactsCacheTTLinMS = multiGetContactsCacheTTLinMS
                ClassObject.response: requests.Response = None


        class GetUserTagsRequestModel:
            def __init__(ClassObject, targetUserIds: list[int] = None):
                ClassObject.targetUserIds = targetUserIds
                ClassObject.response: requests.Response = None


        class SetUserTagRequestModel:
            def __init__(ClassObject, targetUserId: int = None, userTag: str = None):
                ClassObject.targetUserId = targetUserId
                ClassObject.userTag = userTag
                ClassObject.response: requests.Response = None


        class GetUserTagsResponseModel:
            def __init__(ClassObject, targetUserId: int = None, targetUserTag: str = None):
                ClassObject.targetUserId = targetUserId
                ClassObject.targetUserTag = targetUserTag
                ClassObject.response: requests.Response = None


        class SetUserTagResponseModel:
            def __init__(ClassObject, status: enum.Enum = None):
                ClassObject.status = status
                ClassObject.response: requests.Response = None


        class ValidateUserTagResponseModel:
            def __init__(ClassObject, status: enum.Enum = None):
                ClassObject.status = status
                ClassObject.response: requests.Response = None



        
        def GetContactsMetadata(self) -> ContactsMetadataResponseModel:
            """
            Gets contextual information for contacts and usertags
            
            Usage:
                import Contacts
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ContactsApi = Contacts.ContactsApi(RobloxClient=RobloxClient)
                Response = ContactsApi.GetContactsMetadata()
        
            Args:
                
            Returns:
                Contacts.ContactsMetadataResponseModel: Contacts.ContactsMetadataResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetContactsMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Contacts.roblox.com/v1/contacts/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Contacts.ContactsMetadataResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetContactsMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetContactsMetadataRecivedData)
            
            return ResponseSchema
        
        def GetUserTagValidate(self, alias: str) -> ValidateUserTagResponseModel:
            """
            Validates the tag for a user
            
            Usage:
                import Contacts
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ContactsApi = Contacts.ContactsApi(RobloxClient=RobloxClient)
                Response = ContactsApi.GetUserTagValidate(alias=string)
        
            Args:
                alias: str
            Returns:
                Contacts.ValidateUserTagResponseModel: Contacts.ValidateUserTagResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {"alias": alias},"headers": {},"cookies": {}}
            
            GetUserTagValidateRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Contacts.roblox.com/v1/user/tag/validate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Contacts.ValidateUserTagResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetUserTagValidateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUserTagValidateRecivedData)
            
            return ResponseSchema
        
        def PostUserGetTags(self, GetUserTagsRequestModel: GetUserTagsRequestModel) -> requests.Response:
            """
            Gets the tags for multiple users
            
            Usage:
                import Contacts
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ContactsApi = Contacts.ContactsApi(RobloxClient=RobloxClient)
                Response = ContactsApi.PostUserGetTags(GetUserTagsRequestModel=Contacts.GetUserTagsRequestModel())
        
            Args:
                GetUserTagsRequestModel: GetUserTagsRequestModel
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'GetUserTagsRequestModel': 'json'}
            Arguments = inspect.signature(self.PostUserGetTags)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUserGetTagsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Contacts.roblox.com/v1/user/get-tags", Dictinary=Dictinary)
            return PostUserGetTagsRecivedData
        
        def PostUserTag(self, SetUserTagRequestModel: SetUserTagRequestModel) -> SetUserTagResponseModel:
            """
            Sets the tag for a user
            
            Usage:
                import Contacts
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ContactsApi = Contacts.ContactsApi(RobloxClient=RobloxClient)
                Response = ContactsApi.PostUserTag(SetUserTagRequestModel=Contacts.SetUserTagRequestModel())
        
            Args:
                SetUserTagRequestModel: SetUserTagRequestModel
            Returns:
                Contacts.SetUserTagResponseModel: Contacts.SetUserTagResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SetUserTagRequestModel': 'json'}
            Arguments = inspect.signature(self.PostUserTag)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUserTagRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Contacts.roblox.com/v1/user/tag", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Contacts.SetUserTagResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUserTagRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUserTagRecivedData)
            
            return ResponseSchema
        
    class ClientSettingsCdn:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class ClientVersionResponse:
            def __init__(ClassObject, version: str = None, clientVersionUpload: str = None, bootstrapperVersion: str = None, nextClientVersionUpload: str = None, nextClientVersion: str = None):
                ClassObject.version = version
                ClassObject.clientVersionUpload = clientVersionUpload
                ClassObject.bootstrapperVersion = bootstrapperVersion
                ClassObject.nextClientVersionUpload = nextClientVersionUpload
                ClassObject.nextClientVersion = nextClientVersion
                ClassObject.response: requests.Response = None


        class UserChannelResponse:
            def __init__(ClassObject, channelName: str = None, channelAssignmentType: enum.Enum = None, token: str = None):
                ClassObject.channelName = channelName
                ClassObject.channelAssignmentType = channelAssignmentType
                ClassObject.token = token
                ClassObject.response: requests.Response = None



        
        def GetClientVersionBinarytype(self, binaryType: str) -> ClientVersionResponse:
            """
            Get client version information for specific binary type
            
            Usage:
                import ClientSettingsCdn
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ClientSettingsCdnApi = ClientSettingsCdn.ClientSettingsCdnApi(RobloxClient=RobloxClient)
                Response = ClientSettingsCdnApi.GetClientVersionBinarytype(binaryType=string)
        
            Args:
                binaryType: str
            Returns:
                ClientSettingsCdn.ClientVersionResponse: ClientSettingsCdn.ClientVersionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetClientVersionBinarytypeRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ClientSettingsCdn.roblox.com/v2/client-version/{binaryType}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ClientSettingsCdn.ClientVersionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetClientVersionBinarytypeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetClientVersionBinarytypeRecivedData)
            
            return ResponseSchema
        
        def GetClientVersionBinarytypeChannelChannelname(self, binaryType: str, channelName: str) -> ClientVersionResponse:
            """
            Get client version information for specific binary type
            
            Usage:
                import ClientSettingsCdn
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ClientSettingsCdnApi = ClientSettingsCdn.ClientSettingsCdnApi(RobloxClient=RobloxClient)
                Response = ClientSettingsCdnApi.GetClientVersionBinarytypeChannelChannelname(binaryType=string, channelName=string)
        
            Args:
                binaryType: str
            channelName: str
            Returns:
                ClientSettingsCdn.ClientVersionResponse: ClientSettingsCdn.ClientVersionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetClientVersionBinarytypeChannelChannelnameRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ClientSettingsCdn.roblox.com/v2/client-version/{binaryType}/channel/{channelName}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ClientSettingsCdn.ClientVersionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetClientVersionBinarytypeChannelChannelnameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetClientVersionBinarytypeChannelChannelnameRecivedData)
            
            return ResponseSchema
        
        def GetUserChannel(self, binaryType: str) -> UserChannelResponse:
            """
            Get channel name for currently logged in user
            
            Usage:
                import ClientSettingsCdn
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ClientSettingsCdnApi = ClientSettingsCdn.ClientSettingsCdnApi(RobloxClient=RobloxClient)
                Response = ClientSettingsCdnApi.GetUserChannel(binaryType=string)
        
            Args:
                binaryType: str
            Returns:
                ClientSettingsCdn.UserChannelResponse: ClientSettingsCdn.UserChannelResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"binaryType": binaryType},"headers": {},"cookies": {}}
            
            GetUserChannelRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ClientSettingsCdn.roblox.com/v2/user-channel", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ClientSettingsCdn.UserChannelResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUserChannelRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUserChannelRecivedData)
            
            return ResponseSchema
        
    class ClientSettings:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class ClientVersionResponse:
            def __init__(ClassObject, version: str = None, clientVersionUpload: str = None, bootstrapperVersion: str = None, nextClientVersionUpload: str = None, nextClientVersion: str = None):
                ClassObject.version = version
                ClassObject.clientVersionUpload = clientVersionUpload
                ClassObject.bootstrapperVersion = bootstrapperVersion
                ClassObject.nextClientVersionUpload = nextClientVersionUpload
                ClassObject.nextClientVersion = nextClientVersion
                ClassObject.response: requests.Response = None


        class UserChannelResponse:
            def __init__(ClassObject, channelName: str = None, channelAssignmentType: enum.Enum = None, token: str = None):
                ClassObject.channelName = channelName
                ClassObject.channelAssignmentType = channelAssignmentType
                ClassObject.token = token
                ClassObject.response: requests.Response = None



        
        def GetClientVersionBinarytype(self, binaryType: str) -> ClientVersionResponse:
            """
            Get client version information for specific binary type
            
            Usage:
                import ClientSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ClientSettingsApi = ClientSettings.ClientSettingsApi(RobloxClient=RobloxClient)
                Response = ClientSettingsApi.GetClientVersionBinarytype(binaryType=string)
        
            Args:
                binaryType: str
            Returns:
                ClientSettings.ClientVersionResponse: ClientSettings.ClientVersionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetClientVersionBinarytypeRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ClientSettings.roblox.com/v2/client-version/{binaryType}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ClientSettings.ClientVersionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetClientVersionBinarytypeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetClientVersionBinarytypeRecivedData)
            
            return ResponseSchema
        
        def GetClientVersionBinarytypeChannelChannelname(self, binaryType: str, channelName: str) -> ClientVersionResponse:
            """
            Get client version information for specific binary type
            
            Usage:
                import ClientSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ClientSettingsApi = ClientSettings.ClientSettingsApi(RobloxClient=RobloxClient)
                Response = ClientSettingsApi.GetClientVersionBinarytypeChannelChannelname(binaryType=string, channelName=string)
        
            Args:
                binaryType: str
            channelName: str
            Returns:
                ClientSettings.ClientVersionResponse: ClientSettings.ClientVersionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetClientVersionBinarytypeChannelChannelnameRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ClientSettings.roblox.com/v2/client-version/{binaryType}/channel/{channelName}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ClientSettings.ClientVersionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetClientVersionBinarytypeChannelChannelnameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetClientVersionBinarytypeChannelChannelnameRecivedData)
            
            return ResponseSchema
        
        def GetUserChannel(self, binaryType: str) -> UserChannelResponse:
            """
            Get channel name for currently logged in user
            
            Usage:
                import ClientSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ClientSettingsApi = ClientSettings.ClientSettingsApi(RobloxClient=RobloxClient)
                Response = ClientSettingsApi.GetUserChannel(binaryType=string)
        
            Args:
                binaryType: str
            Returns:
                ClientSettings.UserChannelResponse: ClientSettings.UserChannelResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"binaryType": binaryType},"headers": {},"cookies": {}}
            
            GetUserChannelRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://ClientSettings.roblox.com/v2/user-channel", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.ClientSettings.UserChannelResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUserChannelRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUserChannelRecivedData)
            
            return ResponseSchema
        
    class Chat:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class RejectedChatParticipant:
            def __init__(ClassObject, rejectedReason: str = None, type: enum.Enum = None, targetId: int = None, name: str = None, displayName: str = None, hasVerifiedBadge: bool = None):
                ClassObject.rejectedReason = rejectedReason
                ClassObject.type = type
                ClassObject.targetId = targetId
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.response: requests.Response = None


        class AddUserToConversationResponse:
            def __init__(ClassObject, conversationId: int = None, rejectedParticipants: list["RobloxClient.Chat.RejectedChatParticipant"] = None, resultType: enum.Enum = None, statusMessage: str = None):
                ClassObject.conversationId = conversationId
                ClassObject.rejectedParticipants = rejectedParticipants
                ClassObject.resultType = resultType
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class AddUsersToConversationRequest:
            def __init__(ClassObject, participantUserIds: list[int] = None, conversationId: int = None):
                ClassObject.participantUserIds = participantUserIds
                ClassObject.conversationId = conversationId
                ClassObject.response: requests.Response = None


        class GameLink:
            def __init__(ClassObject, universeId: int = None):
                ClassObject.universeId = universeId
                ClassObject.response: requests.Response = None


        class Link:
            def __init__(ClassObject, type: enum.Enum = None, game: "RobloxClient.Chat.GameLink" = None):
                ClassObject.type = type
                ClassObject.game = game
                ClassObject.response: requests.Response = None


        class SetConversationUniverseEventBased:
            def __init__(ClassObject, actorUserId: int = None, universeId: int = None):
                ClassObject.actorUserId = actorUserId
                ClassObject.universeId = universeId
                ClassObject.response: requests.Response = None


        class EventBased:
            def __init__(ClassObject, type: enum.Enum = None, setConversationUniverse: "RobloxClient.Chat.SetConversationUniverseEventBased" = None):
                ClassObject.type = type
                ClassObject.setConversationUniverse = setConversationUniverse
                ClassObject.response: requests.Response = None


        class ChatMessage:
            def __init__(ClassObject, id: str = None, senderType: enum.Enum = None, sent: str = None, read: bool = None, messageType: enum.Enum = None, decorators: list[str] = None, senderTargetId: int = None, content: str = None, link: "RobloxClient.Chat.Link" = None, eventBased: "RobloxClient.Chat.EventBased" = None):
                ClassObject.id = id
                ClassObject.senderType = senderType
                ClassObject.sent = sent
                ClassObject.read = read
                ClassObject.messageType = messageType
                ClassObject.decorators = decorators
                ClassObject.senderTargetId = senderTargetId
                ClassObject.content = content
                ClassObject.link = link
                ClassObject.eventBased = eventBased
                ClassObject.response: requests.Response = None


        class ChatMetadataResponse:
            def __init__(ClassObject, isChatEnabledByPrivacySetting: enum.Enum = None, languageForPrivacySettingUnavailable: str = None, maxConversationTitleLength: int = None, numberOfMembersForPartyChrome: int = None, partyChromeDisplayTimeStampInterval: int = None, signalRDisconnectionResponseInMilliseconds: int = None, typingInChatFromSenderThrottleMs: int = None, typingInChatForReceiverExpirationMs: int = None, relativeValueToRecordUiPerformance: float = None, isChatDataFromLocalStorageEnabled: bool = None, chatDataFromLocalStorageExpirationSeconds: int = None, isUsingCacheToLoadFriendsInfoEnabled: bool = None, cachedDataFromLocalStorageExpirationMS: int = None, senderTypesForUnknownMessageTypeError: list[str] = None, isInvalidMessageTypeFallbackEnabled: bool = None, isRespectingMessageTypeEnabled: bool = None, validMessageTypesWhiteList: list[str] = None, shouldRespectConversationHasUnreadMessageToMarkAsRead: bool = None, isAliasChatForClientSideEnabled: bool = None, isPlayTogetherForGameCardsEnabled: bool = None, isRoactChatEnabled: bool = None, webChatEventSampleRate: int = None, isPlatformChatApiEnabled: bool = None):
                ClassObject.isChatEnabledByPrivacySetting = isChatEnabledByPrivacySetting
                ClassObject.languageForPrivacySettingUnavailable = languageForPrivacySettingUnavailable
                ClassObject.maxConversationTitleLength = maxConversationTitleLength
                ClassObject.numberOfMembersForPartyChrome = numberOfMembersForPartyChrome
                ClassObject.partyChromeDisplayTimeStampInterval = partyChromeDisplayTimeStampInterval
                ClassObject.signalRDisconnectionResponseInMilliseconds = signalRDisconnectionResponseInMilliseconds
                ClassObject.typingInChatFromSenderThrottleMs = typingInChatFromSenderThrottleMs
                ClassObject.typingInChatForReceiverExpirationMs = typingInChatForReceiverExpirationMs
                ClassObject.relativeValueToRecordUiPerformance = relativeValueToRecordUiPerformance
                ClassObject.isChatDataFromLocalStorageEnabled = isChatDataFromLocalStorageEnabled
                ClassObject.chatDataFromLocalStorageExpirationSeconds = chatDataFromLocalStorageExpirationSeconds
                ClassObject.isUsingCacheToLoadFriendsInfoEnabled = isUsingCacheToLoadFriendsInfoEnabled
                ClassObject.cachedDataFromLocalStorageExpirationMS = cachedDataFromLocalStorageExpirationMS
                ClassObject.senderTypesForUnknownMessageTypeError = senderTypesForUnknownMessageTypeError
                ClassObject.isInvalidMessageTypeFallbackEnabled = isInvalidMessageTypeFallbackEnabled
                ClassObject.isRespectingMessageTypeEnabled = isRespectingMessageTypeEnabled
                ClassObject.validMessageTypesWhiteList = validMessageTypesWhiteList
                ClassObject.shouldRespectConversationHasUnreadMessageToMarkAsRead = shouldRespectConversationHasUnreadMessageToMarkAsRead
                ClassObject.isAliasChatForClientSideEnabled = isAliasChatForClientSideEnabled
                ClassObject.isPlayTogetherForGameCardsEnabled = isPlayTogetherForGameCardsEnabled
                ClassObject.isRoactChatEnabled = isRoactChatEnabled
                ClassObject.webChatEventSampleRate = webChatEventSampleRate
                ClassObject.isPlatformChatApiEnabled = isPlatformChatApiEnabled
                ClassObject.response: requests.Response = None


        class ChatParticipant:
            def __init__(ClassObject, type: enum.Enum = None, targetId: int = None, name: str = None, displayName: str = None, hasVerifiedBadge: bool = None):
                ClassObject.type = type
                ClassObject.targetId = targetId
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.response: requests.Response = None


        class ChatSettingsResponse:
            def __init__(ClassObject, chatEnabled: bool = None, isActiveChatUser: bool = None, isConnectTabEnabled: bool = None):
                ClassObject.chatEnabled = chatEnabled
                ClassObject.isActiveChatUser = isActiveChatUser
                ClassObject.isConnectTabEnabled = isConnectTabEnabled
                ClassObject.response: requests.Response = None


        class ConversationTitle:
            def __init__(ClassObject, titleForViewer: str = None, isDefaultTitle: bool = None):
                ClassObject.titleForViewer = titleForViewer
                ClassObject.isDefaultTitle = isDefaultTitle
                ClassObject.response: requests.Response = None


        class ConversationUniverse:
            def __init__(ClassObject, universeId: int = None, rootPlaceId: int = None):
                ClassObject.universeId = universeId
                ClassObject.rootPlaceId = rootPlaceId
                ClassObject.response: requests.Response = None


        class Conversation:
            def __init__(ClassObject, id: int = None, title: str = None, initiator: "RobloxClient.Chat.ChatParticipant" = None, hasUnreadMessages: bool = None, participants: list["RobloxClient.Chat.ChatParticipant"] = None, conversationType: enum.Enum = None, conversationTitle: "RobloxClient.Chat.ConversationTitle" = None, lastUpdated: str = None, conversationUniverse: "RobloxClient.Chat.ConversationUniverse" = None):
                ClassObject.id = id
                ClassObject.title = title
                ClassObject.initiator = initiator
                ClassObject.hasUnreadMessages = hasUnreadMessages
                ClassObject.participants = participants
                ClassObject.conversationType = conversationType
                ClassObject.conversationTitle = conversationTitle
                ClassObject.lastUpdated = lastUpdated
                ClassObject.conversationUniverse = conversationUniverse
                ClassObject.response: requests.Response = None


        class CreateCloudEditConversationRequest:
            def __init__(ClassObject, placeId: int = None):
                ClassObject.placeId = placeId
                ClassObject.response: requests.Response = None


        class CreateGroupConversationRequest:
            def __init__(ClassObject, participantUserIds: list[int] = None, title: str = None):
                ClassObject.participantUserIds = participantUserIds
                ClassObject.title = title
                ClassObject.response: requests.Response = None


        class CreateOneToOneConversationRequest:
            def __init__(ClassObject, participantUserId: int = None):
                ClassObject.participantUserId = participantUserId
                ClassObject.response: requests.Response = None


        class MarkAsReadRequest:
            def __init__(ClassObject, conversationId: int = None, endMessageId: str = None):
                ClassObject.conversationId = conversationId
                ClassObject.endMessageId = endMessageId
                ClassObject.response: requests.Response = None


        class MarkAsReadResponse:
            def __init__(ClassObject, resultType: enum.Enum = None):
                ClassObject.resultType = resultType
                ClassObject.response: requests.Response = None


        class MarkAsSeenRequest:
            def __init__(ClassObject, conversationsToMarkSeen: list[int] = None):
                ClassObject.conversationsToMarkSeen = conversationsToMarkSeen
                ClassObject.response: requests.Response = None


        class MarkAsSeenResponse:
            def __init__(ClassObject, resultType: enum.Enum = None):
                ClassObject.resultType = resultType
                ClassObject.response: requests.Response = None


        class MultigetConversationMessagesResponse:
            def __init__(ClassObject, conversationId: int = None, chatMessages: list["RobloxClient.Chat.ChatMessage"] = None):
                ClassObject.conversationId = conversationId
                ClassObject.chatMessages = chatMessages
                ClassObject.response: requests.Response = None


        class RemoveUserFromConversationRequest:
            def __init__(ClassObject, participantUserId: int = None, conversationId: int = None):
                ClassObject.participantUserId = participantUserId
                ClassObject.conversationId = conversationId
                ClassObject.response: requests.Response = None


        class RemoveUserFromConversationResponse:
            def __init__(ClassObject, conversationId: int = None, resultType: enum.Enum = None, statusMessage: str = None):
                ClassObject.conversationId = conversationId
                ClassObject.resultType = resultType
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class RenameConversationResponse:
            def __init__(ClassObject, conversationTitle: str = None, resultType: enum.Enum = None, title: "RobloxClient.Chat.ConversationTitle" = None, statusMessage: str = None):
                ClassObject.conversationTitle = conversationTitle
                ClassObject.resultType = resultType
                ClassObject.title = title
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class RenameGroupConversationRequest:
            def __init__(ClassObject, conversationId: int = None, newTitle: str = None):
                ClassObject.conversationId = conversationId
                ClassObject.newTitle = newTitle
                ClassObject.response: requests.Response = None


        class RolloutSettingModel:
            def __init__(ClassObject, featureName: enum.Enum = None, isRolloutEnabled: bool = None):
                ClassObject.featureName = featureName
                ClassObject.isRolloutEnabled = isRolloutEnabled
                ClassObject.response: requests.Response = None


        class RolloutSettingsResponse:
            def __init__(ClassObject, rolloutFeatures: list["RobloxClient.Chat.RolloutSettingModel"] = None):
                ClassObject.rolloutFeatures = rolloutFeatures
                ClassObject.response: requests.Response = None


        class SendGameLinkChatMessageRequest:
            def __init__(ClassObject, universeId: int = None, isExperienceInvite: bool = None, userId: int = None, placeId: int = None, conversationId: int = None, decorators: list[str] = None):
                ClassObject.universeId = universeId
                ClassObject.isExperienceInvite = isExperienceInvite
                ClassObject.userId = userId
                ClassObject.placeId = placeId
                ClassObject.conversationId = conversationId
                ClassObject.decorators = decorators
                ClassObject.response: requests.Response = None


        class SendLinkChatResponse:
            def __init__(ClassObject, chatMessageLinkType: enum.Enum = None, messageId: str = None, sent: str = None, messageType: enum.Enum = None, resultType: enum.Enum = None, statusMessage: str = None):
                ClassObject.chatMessageLinkType = chatMessageLinkType
                ClassObject.messageId = messageId
                ClassObject.sent = sent
                ClassObject.messageType = messageType
                ClassObject.resultType = resultType
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class SendPlainTextChatMessageRequest:
            def __init__(ClassObject, message: str = None, isExperienceInvite: bool = None, userId: int = None, conversationId: int = None, decorators: list[str] = None):
                ClassObject.message = message
                ClassObject.isExperienceInvite = isExperienceInvite
                ClassObject.userId = userId
                ClassObject.conversationId = conversationId
                ClassObject.decorators = decorators
                ClassObject.response: requests.Response = None


        class SendPlainTextChatMessageResponse:
            def __init__(ClassObject, content: str = None, filteredForReceivers: bool = None, messageId: str = None, sent: str = None, messageType: enum.Enum = None, resultType: enum.Enum = None, statusMessage: str = None):
                ClassObject.content = content
                ClassObject.filteredForReceivers = filteredForReceivers
                ClassObject.messageId = messageId
                ClassObject.sent = sent
                ClassObject.messageType = messageType
                ClassObject.resultType = resultType
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class StartNewConversationResponse:
            def __init__(ClassObject, conversation: "RobloxClient.Chat.Conversation" = None, rejectedParticipants: list["RobloxClient.Chat.RejectedChatParticipant"] = None, resultType: enum.Enum = None, statusMessage: str = None):
                ClassObject.conversation = conversation
                ClassObject.rejectedParticipants = rejectedParticipants
                ClassObject.resultType = resultType
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None


        class UnreadConversationCountResponse:
            def __init__(ClassObject, count: int = None):
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class UpdateUserTypingStatusRequest:
            def __init__(ClassObject, conversationId: int = None, isTyping: bool = None):
                ClassObject.conversationId = conversationId
                ClassObject.isTyping = isTyping
                ClassObject.response: requests.Response = None


        class UserVisibleStatusResponse:
            def __init__(ClassObject, statusMessage: str = None):
                ClassObject.statusMessage = statusMessage
                ClassObject.response: requests.Response = None



        
        def GetChatSettings(self) -> ChatSettingsResponse:
            """
            For every authenticated user, the clients hit this endpoint to get the chat related settings. Example : Chat is enabled or not
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.GetChatSettings()
        
            Args:
                
            Returns:
                Chat.ChatSettingsResponse: Chat.ChatSettingsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetChatSettingsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Chat.roblox.com/v2/chat-settings", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.ChatSettingsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetChatSettingsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetChatSettingsRecivedData)
            
            return ResponseSchema
        
        def GetGetConversations(self, conversationIds: list) -> requests.Response:
            """
            Gets conversations for the conversationIds specified in the parameters
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.GetGetConversations(conversationIds=array)
        
            Args:
                conversationIds: list
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"conversationIds": conversationIds},"headers": {},"cookies": {}}
            
            GetGetConversationsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Chat.roblox.com/v2/get-conversations", Dictinary=Dictinary)
            return GetGetConversationsRecivedData
        
        def GetGetMessages(self, conversationId: int, pageSize: int, exclusiveStartMessageId: str) -> requests.Response:
            """
            Gets messages corresponding to the given conversationId
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.GetGetMessages(conversationId=integer, pageSize=integer, exclusiveStartMessageId=string)
        
            Args:
                conversationId: int
            pageSize: int
            exclusiveStartMessageId: str
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"conversationId": conversationId, "pageSize": pageSize, "exclusiveStartMessageId": exclusiveStartMessageId},"headers": {},"cookies": {}}
            
            GetGetMessagesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Chat.roblox.com/v2/get-messages", Dictinary=Dictinary)
            return GetGetMessagesRecivedData
        
        def GetGetRolloutSettings(self, featureNames: list) -> RolloutSettingsResponse:
            """
            Gets the rollout settings for requested feature
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.GetGetRolloutSettings(featureNames=array)
        
            Args:
                featureNames: list
            Returns:
                Chat.RolloutSettingsResponse: Chat.RolloutSettingsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"featureNames": featureNames},"headers": {},"cookies": {}}
            
            GetGetRolloutSettingsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Chat.roblox.com/v2/get-rollout-settings", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.RolloutSettingsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGetRolloutSettingsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGetRolloutSettingsRecivedData)
            
            return ResponseSchema
        
        def GetGetUnreadConversationCount(self) -> UnreadConversationCountResponse:
            """
            Gets the count of unread conversations
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.GetGetUnreadConversationCount()
        
            Args:
                
            Returns:
                Chat.UnreadConversationCountResponse: Chat.UnreadConversationCountResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGetUnreadConversationCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Chat.roblox.com/v2/get-unread-conversation-count", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.UnreadConversationCountResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGetUnreadConversationCountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGetUnreadConversationCountRecivedData)
            
            return ResponseSchema
        
        def GetGetUnreadConversations(self, pageNumber: int, pageSize: int) -> requests.Response:
            """
            Gets a list of unread conversations
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.GetGetUnreadConversations(pageNumber=integer, pageSize=integer)
        
            Args:
                pageNumber: int
            pageSize: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"pageNumber": pageNumber, "pageSize": pageSize},"headers": {},"cookies": {}}
            
            GetGetUnreadConversationsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Chat.roblox.com/v2/get-unread-conversations", Dictinary=Dictinary)
            return GetGetUnreadConversationsRecivedData
        
        def GetGetUnreadMessages(self, conversationIds: list, pageSize: int) -> requests.Response:
            """
            Gets the unread messages for the conversationIds specified in the parameters
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.GetGetUnreadMessages(conversationIds=array, pageSize=integer)
        
            Args:
                conversationIds: list
            pageSize: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"conversationIds": conversationIds, "pageSize": pageSize},"headers": {},"cookies": {}}
            
            GetGetUnreadMessagesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Chat.roblox.com/v2/get-unread-messages", Dictinary=Dictinary)
            return GetGetUnreadMessagesRecivedData
        
        def GetGetUserConversations(self, pageNumber: int, pageSize: int) -> requests.Response:
            """
            Gets all conversations associated with the logged-in User
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.GetGetUserConversations(pageNumber=integer, pageSize=integer)
        
            Args:
                pageNumber: int
            pageSize: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"pageNumber": pageNumber, "pageSize": pageSize},"headers": {},"cookies": {}}
            
            GetGetUserConversationsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Chat.roblox.com/v2/get-user-conversations", Dictinary=Dictinary)
            return GetGetUserConversationsRecivedData
        
        def GetMetadata(self) -> ChatMetadataResponse:
            """
            Get Chat metadata.
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.GetMetadata()
        
            Args:
                
            Returns:
                Chat.ChatMetadataResponse: Chat.ChatMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Chat.roblox.com/v2/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.ChatMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetMetadataRecivedData)
            
            return ResponseSchema
        
        def GetMultiGetLatestMessages(self, conversationIds: list, pageSize: int) -> requests.Response:
            """
            Gets latest messages corresponding to the given list of conversation Ids
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.GetMultiGetLatestMessages(conversationIds=array, pageSize=integer)
        
            Args:
                conversationIds: list
            pageSize: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"conversationIds": conversationIds, "pageSize": pageSize},"headers": {},"cookies": {}}
            
            GetMultiGetLatestMessagesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Chat.roblox.com/v2/multi-get-latest-messages", Dictinary=Dictinary)
            return GetMultiGetLatestMessagesRecivedData
        
        def PostAddToConversation(self, AddUsersToConversationRequest: AddUsersToConversationRequest) -> AddUserToConversationResponse:
            """
            Adds users to an existing conversation
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.PostAddToConversation(AddUsersToConversationRequest=Chat.AddUsersToConversationRequest())
        
            Args:
                AddUsersToConversationRequest: AddUsersToConversationRequest
            Returns:
                Chat.AddUserToConversationResponse: Chat.AddUserToConversationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'AddUsersToConversationRequest': 'json'}
            Arguments = inspect.signature(self.PostAddToConversation)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostAddToConversationRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Chat.roblox.com/v2/add-to-conversation", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.AddUserToConversationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAddToConversationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAddToConversationRecivedData)
            
            return ResponseSchema
        
        def PostMarkAsRead(self, MarkAsReadRequest: MarkAsReadRequest) -> MarkAsReadResponse:
            """
            Mark the specified conversation messages as read
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.PostMarkAsRead(MarkAsReadRequest=Chat.MarkAsReadRequest())
        
            Args:
                MarkAsReadRequest: MarkAsReadRequest
            Returns:
                Chat.MarkAsReadResponse: Chat.MarkAsReadResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'MarkAsReadRequest': 'json'}
            Arguments = inspect.signature(self.PostMarkAsRead)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostMarkAsReadRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Chat.roblox.com/v2/mark-as-read", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.MarkAsReadResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostMarkAsReadRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostMarkAsReadRecivedData)
            
            return ResponseSchema
        
        def PostMarkAsSeen(self, MarkAsSeenRequest: MarkAsSeenRequest) -> MarkAsSeenResponse:
            """
            Mark the specified conversation messages as seen
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.PostMarkAsSeen(MarkAsSeenRequest=Chat.MarkAsSeenRequest())
        
            Args:
                MarkAsSeenRequest: MarkAsSeenRequest
            Returns:
                Chat.MarkAsSeenResponse: Chat.MarkAsSeenResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'MarkAsSeenRequest': 'json'}
            Arguments = inspect.signature(self.PostMarkAsSeen)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostMarkAsSeenRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Chat.roblox.com/v2/mark-as-seen", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.MarkAsSeenResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostMarkAsSeenRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostMarkAsSeenRecivedData)
            
            return ResponseSchema
        
        def PostRemoveFromConversation(self, RemoveUserFromConversationRequest: RemoveUserFromConversationRequest) -> RemoveUserFromConversationResponse:
            """
            Removes a user from an existing conversation
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.PostRemoveFromConversation(RemoveUserFromConversationRequest=Chat.RemoveUserFromConversationRequest())
        
            Args:
                RemoveUserFromConversationRequest: RemoveUserFromConversationRequest
            Returns:
                Chat.RemoveUserFromConversationResponse: Chat.RemoveUserFromConversationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RemoveUserFromConversationRequest': 'json'}
            Arguments = inspect.signature(self.PostRemoveFromConversation)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostRemoveFromConversationRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Chat.roblox.com/v2/remove-from-conversation", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.RemoveUserFromConversationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostRemoveFromConversationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostRemoveFromConversationRecivedData)
            
            return ResponseSchema
        
        def PostRenameGroupConversation(self, RenameGroupConversationRequest: RenameGroupConversationRequest) -> RenameConversationResponse:
            """
            Renames the title of an existing conversation
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.PostRenameGroupConversation(RenameGroupConversationRequest=Chat.RenameGroupConversationRequest())
        
            Args:
                RenameGroupConversationRequest: RenameGroupConversationRequest
            Returns:
                Chat.RenameConversationResponse: Chat.RenameConversationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RenameGroupConversationRequest': 'json'}
            Arguments = inspect.signature(self.PostRenameGroupConversation)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostRenameGroupConversationRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Chat.roblox.com/v2/rename-group-conversation", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.RenameConversationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostRenameGroupConversationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostRenameGroupConversationRecivedData)
            
            return ResponseSchema
        
        def PostSendGameLinkMessage(self, SendGameLinkChatMessageRequest: SendGameLinkChatMessageRequest) -> SendLinkChatResponse:
            """
            Unknown
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.PostSendGameLinkMessage(SendGameLinkChatMessageRequest=Chat.SendGameLinkChatMessageRequest())
        
            Args:
                SendGameLinkChatMessageRequest: SendGameLinkChatMessageRequest
            Returns:
                Chat.SendLinkChatResponse: Chat.SendLinkChatResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SendGameLinkChatMessageRequest': 'json'}
            Arguments = inspect.signature(self.PostSendGameLinkMessage)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostSendGameLinkMessageRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Chat.roblox.com/v2/send-game-link-message", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.SendLinkChatResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostSendGameLinkMessageRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostSendGameLinkMessageRecivedData)
            
            return ResponseSchema
        
        def PostSendMessage(self, SendPlainTextChatMessageRequest: SendPlainTextChatMessageRequest) -> SendPlainTextChatMessageResponse:
            """
            Sends a chat message
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.PostSendMessage(SendPlainTextChatMessageRequest=Chat.SendPlainTextChatMessageRequest())
        
            Args:
                SendPlainTextChatMessageRequest: SendPlainTextChatMessageRequest
            Returns:
                Chat.SendPlainTextChatMessageResponse: Chat.SendPlainTextChatMessageResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SendPlainTextChatMessageRequest': 'json'}
            Arguments = inspect.signature(self.PostSendMessage)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostSendMessageRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Chat.roblox.com/v2/send-message", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.SendPlainTextChatMessageResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostSendMessageRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostSendMessageRecivedData)
            
            return ResponseSchema
        
        def PostStartCloudEditConversation(self, CreateCloudEditConversationRequest: CreateCloudEditConversationRequest) -> StartNewConversationResponse:
            """
            Creates a new cloud edit conversation
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.PostStartCloudEditConversation(CreateCloudEditConversationRequest=Chat.CreateCloudEditConversationRequest())
        
            Args:
                CreateCloudEditConversationRequest: CreateCloudEditConversationRequest
            Returns:
                Chat.StartNewConversationResponse: Chat.StartNewConversationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'CreateCloudEditConversationRequest': 'json'}
            Arguments = inspect.signature(self.PostStartCloudEditConversation)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostStartCloudEditConversationRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Chat.roblox.com/v2/start-cloud-edit-conversation", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.StartNewConversationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostStartCloudEditConversationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostStartCloudEditConversationRecivedData)
            
            return ResponseSchema
        
        def PostStartGroupConversation(self, CreateGroupConversationRequest: CreateGroupConversationRequest) -> StartNewConversationResponse:
            """
            Creates a new group conversation
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.PostStartGroupConversation(CreateGroupConversationRequest=Chat.CreateGroupConversationRequest())
        
            Args:
                CreateGroupConversationRequest: CreateGroupConversationRequest
            Returns:
                Chat.StartNewConversationResponse: Chat.StartNewConversationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'CreateGroupConversationRequest': 'json'}
            Arguments = inspect.signature(self.PostStartGroupConversation)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostStartGroupConversationRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Chat.roblox.com/v2/start-group-conversation", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.StartNewConversationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostStartGroupConversationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostStartGroupConversationRecivedData)
            
            return ResponseSchema
        
        def PostStartOneToOneConversation(self, CreateOneToOneConversationRequest: CreateOneToOneConversationRequest) -> StartNewConversationResponse:
            """
            Creates a new one-on-one conversation
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.PostStartOneToOneConversation(CreateOneToOneConversationRequest=Chat.CreateOneToOneConversationRequest())
        
            Args:
                CreateOneToOneConversationRequest: CreateOneToOneConversationRequest
            Returns:
                Chat.StartNewConversationResponse: Chat.StartNewConversationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'CreateOneToOneConversationRequest': 'json'}
            Arguments = inspect.signature(self.PostStartOneToOneConversation)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostStartOneToOneConversationRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Chat.roblox.com/v2/start-one-to-one-conversation", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.StartNewConversationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostStartOneToOneConversationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostStartOneToOneConversationRecivedData)
            
            return ResponseSchema
        
        def PostUpdateUserTypingStatus(self, UpdateUserTypingStatusRequest: UpdateUserTypingStatusRequest) -> UserVisibleStatusResponse:
            """
            Updates the status for whether a user is typing currently
            
            Usage:
                import Chat
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                ChatApi = Chat.ChatApi(RobloxClient=RobloxClient)
                Response = ChatApi.PostUpdateUserTypingStatus(UpdateUserTypingStatusRequest=Chat.UpdateUserTypingStatusRequest())
        
            Args:
                UpdateUserTypingStatusRequest: UpdateUserTypingStatusRequest
            Returns:
                Chat.UserVisibleStatusResponse: Chat.UserVisibleStatusResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateUserTypingStatusRequest': 'json'}
            Arguments = inspect.signature(self.PostUpdateUserTypingStatus)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUpdateUserTypingStatusRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Chat.roblox.com/v2/update-user-typing-status", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Chat.UserVisibleStatusResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUpdateUserTypingStatusRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUpdateUserTypingStatusRecivedData)
            
            return ResponseSchema
        
    class Catalog:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class AssetFavoriteModel:
            def __init__(ClassObject, assetId: int = None, userId: int = None, created: str = None):
                ClassObject.assetId = assetId
                ClassObject.userId = userId
                ClassObject.created = created
                ClassObject.response: requests.Response = None


        class BundleCreatorModel:
            def __init__(ClassObject, id: int = None, name: str = None, type: str = None, hasVerifiedBadge: bool = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.type = type
                ClassObject.hasVerifiedBadge = hasVerifiedBadge
                ClassObject.response: requests.Response = None


        class BundleItemDetailModel:
            def __init__(ClassObject, owned: bool = None, id: int = None, name: str = None, type: str = None):
                ClassObject.owned = owned
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.type = type
                ClassObject.response: requests.Response = None


        class PremiumPricingModel:
            def __init__(ClassObject, premiumDiscountPercentage: int = None, premiumPriceInRobux: int = None):
                ClassObject.premiumDiscountPercentage = premiumDiscountPercentage
                ClassObject.premiumPriceInRobux = premiumPriceInRobux
                ClassObject.response: requests.Response = None


        class BundleProductModel:
            def __init__(ClassObject, id: int = None, type: str = None, isPublicDomain: bool = None, isForSale: bool = None, priceInRobux: int = None, isFree: bool = None, noPriceText: str = None, premiumPricing: "RobloxClient.Catalog.PremiumPricingModel" = None):
                ClassObject.id = id
                ClassObject.type = type
                ClassObject.isPublicDomain = isPublicDomain
                ClassObject.isForSale = isForSale
                ClassObject.priceInRobux = priceInRobux
                ClassObject.isFree = isFree
                ClassObject.noPriceText = noPriceText
                ClassObject.premiumPricing = premiumPricing
                ClassObject.response: requests.Response = None


        class SaleLocation:
            def __init__(ClassObject, saleLocationType: enum.Enum = None, saleLocationTypeId: int = None, universeIds: list[int] = None, enabledUniverseIds: list[int] = None):
                ClassObject.saleLocationType = saleLocationType
                ClassObject.saleLocationTypeId = saleLocationTypeId
                ClassObject.universeIds = universeIds
                ClassObject.enabledUniverseIds = enabledUniverseIds
                ClassObject.response: requests.Response = None


        class CollectibleItemDetail:
            def __init__(ClassObject, collectibleItemId: str = None, collectibleProductId: str = None, price: int = None, lowestPrice: int = None, lowestResalePrice: int = None, totalQuantity: int = None, unitsAvailable: int = None, saleLocation: "RobloxClient.Catalog.SaleLocation" = None, hasResellers: bool = None, saleStatus: enum.Enum = None, quantityLimitPerUser: int = None, offSaleDeadline: str = None, collectibleItemType: enum.Enum = None, lowestAvailableResaleProductId: str = None, lowestAvailableResaleItemInstanceId: str = None, resaleRestriction: enum.Enum = None):
                ClassObject.collectibleItemId = collectibleItemId
                ClassObject.collectibleProductId = collectibleProductId
                ClassObject.price = price
                ClassObject.lowestPrice = lowestPrice
                ClassObject.lowestResalePrice = lowestResalePrice
                ClassObject.totalQuantity = totalQuantity
                ClassObject.unitsAvailable = unitsAvailable
                ClassObject.saleLocation = saleLocation
                ClassObject.hasResellers = hasResellers
                ClassObject.saleStatus = saleStatus
                ClassObject.quantityLimitPerUser = quantityLimitPerUser
                ClassObject.offSaleDeadline = offSaleDeadline
                ClassObject.collectibleItemType = collectibleItemType
                ClassObject.lowestAvailableResaleProductId = lowestAvailableResaleProductId
                ClassObject.lowestAvailableResaleItemInstanceId = lowestAvailableResaleItemInstanceId
                ClassObject.resaleRestriction = resaleRestriction
                ClassObject.response: requests.Response = None


        class BundleDetailsModel:
            def __init__(ClassObject, id: int = None, name: str = None, description: str = None, bundleType: str = None, items: list["RobloxClient.Catalog.BundleItemDetailModel"] = None, creator: "RobloxClient.Catalog.BundleCreatorModel" = None, product: "RobloxClient.Catalog.BundleProductModel" = None, itemRestrictions: list[int] = None, collectibleItemDetail: "RobloxClient.Catalog.CollectibleItemDetail" = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.bundleType = bundleType
                ClassObject.items = items
                ClassObject.creator = creator
                ClassObject.product = product
                ClassObject.itemRestrictions = itemRestrictions
                ClassObject.collectibleItemDetail = collectibleItemDetail
                ClassObject.response: requests.Response = None


        class BundleFavoriteModel:
            def __init__(ClassObject, bundleId: int = None, userId: int = None, created: str = None):
                ClassObject.bundleId = bundleId
                ClassObject.userId = userId
                ClassObject.created = created
                ClassObject.response: requests.Response = None


        class CatalogSearchDetailedResponseItem:
            def __init__(ClassObject, id: int = None, itemType: enum.Enum = None, assetType: enum.Enum = None, bundleType: enum.Enum = None, name: str = None, description: str = None, productId: int = None, bundledItems: list["RobloxClient.Catalog.BundleItemDetailModel"] = None, itemStatus: list[int] = None, itemRestrictions: list[int] = None, creatorHasVerifiedBadge: bool = None, creatorType: enum.Enum = None, creatorTargetId: int = None, creatorName: str = None, price: int = None, lowestPrice: int = None, lowestResalePrice: int = None, priceStatus: str = None, unitsAvailableForConsumption: int = None, favoriteCount: int = None, offSaleDeadline: str = None, collectibleItemId: str = None, totalQuantity: int = None, saleLocationType: enum.Enum = None, hasResellers: bool = None, isOffSale: bool = None, quantityLimitPerUser: int = None):
                ClassObject.id = id
                ClassObject.itemType = itemType
                ClassObject.assetType = assetType
                ClassObject.bundleType = bundleType
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.productId = productId
                ClassObject.bundledItems = bundledItems
                ClassObject.itemStatus = itemStatus
                ClassObject.itemRestrictions = itemRestrictions
                ClassObject.creatorHasVerifiedBadge = creatorHasVerifiedBadge
                ClassObject.creatorType = creatorType
                ClassObject.creatorTargetId = creatorTargetId
                ClassObject.creatorName = creatorName
                ClassObject.price = price
                ClassObject.lowestPrice = lowestPrice
                ClassObject.lowestResalePrice = lowestResalePrice
                ClassObject.priceStatus = priceStatus
                ClassObject.unitsAvailableForConsumption = unitsAvailableForConsumption
                ClassObject.favoriteCount = favoriteCount
                ClassObject.offSaleDeadline = offSaleDeadline
                ClassObject.collectibleItemId = collectibleItemId
                ClassObject.totalQuantity = totalQuantity
                ClassObject.saleLocationType = saleLocationType
                ClassObject.hasResellers = hasResellers
                ClassObject.isOffSale = isOffSale
                ClassObject.quantityLimitPerUser = quantityLimitPerUser
                ClassObject.response: requests.Response = None


        class FavoriteBundlesResponse:
            def __init__(ClassObject, favorites: list["RobloxClient.Catalog.BundleDetailsModel"] = None, moreFavorites: bool = None, nextCursor: str = None, previousCursor: str = None):
                ClassObject.favorites = favorites
                ClassObject.moreFavorites = moreFavorites
                ClassObject.nextCursor = nextCursor
                ClassObject.previousCursor = previousCursor
                ClassObject.response: requests.Response = None


        class MultigetItemDetailsRequestItem:
            def __init__(ClassObject, itemType: enum.Enum = None, id: int = None):
                ClassObject.itemType = itemType
                ClassObject.id = id
                ClassObject.response: requests.Response = None


        class MultigetItemDetailsRequestModel:
            def __init__(ClassObject, items: list["RobloxClient.Catalog.MultigetItemDetailsRequestItem"] = None):
                ClassObject.items = items
                ClassObject.response: requests.Response = None


        class OwnedBundleModel:
            def __init__(ClassObject, id: int = None, name: str = None, bundleType: str = None, creator: "RobloxClient.Catalog.BundleCreatorModel" = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.bundleType = bundleType
                ClassObject.creator = creator
                ClassObject.response: requests.Response = None


        class TopicModel:
            def __init__(ClassObject, displayName: str = None, originalTopicName: str = None):
                ClassObject.displayName = displayName
                ClassObject.originalTopicName = originalTopicName
                ClassObject.response: requests.Response = None


        class AvatarItem:
            def __init__(ClassObject, TargetId: int = None, ItemType: enum.Enum = None):
                ClassObject.TargetId = TargetId
                ClassObject.ItemType = ItemType
                ClassObject.response: requests.Response = None


        class TopicRequestModel:
            def __init__(ClassObject, items: list["RobloxClient.Catalog.AvatarItem"] = None, selectTopics: list[str] = None, inputQuery: str = None, maxResult: int = None, genderType: enum.Enum = None):
                ClassObject.items = items
                ClassObject.selectTopics = selectTopics
                ClassObject.inputQuery = inputQuery
                ClassObject.maxResult = maxResult
                ClassObject.genderType = genderType
                ClassObject.response: requests.Response = None


        class Error:
            def __init__(ClassObject, Message: str = None, Code: int = None):
                ClassObject.Message = Message
                ClassObject.Code = Code
                ClassObject.response: requests.Response = None


        class TopicResponse:
            def __init__(ClassObject, topics: list["RobloxClient.Catalog.TopicModel"] = None, error: "RobloxClient.Catalog.Error" = None):
                ClassObject.topics = topics
                ClassObject.error = error
                ClassObject.response: requests.Response = None


        class Int64Extra:
            def __init__(ClassObject, key: int = None, sortOrder: enum.Enum = None, pagingDirection: enum.Enum = None, pageNumber: int = None, discriminator: str = None, count: int = None):
                ClassObject.key = key
                ClassObject.sortOrder = sortOrder
                ClassObject.pagingDirection = pagingDirection
                ClassObject.pageNumber = pageNumber
                ClassObject.discriminator = discriminator
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class IBundleInstanceExtra:
            def __init__(ClassObject, SortOrder: enum.Enum = None, PagingDirection: enum.Enum = None, Count: int = None):
                ClassObject.SortOrder = SortOrder
                ClassObject.PagingDirection = PagingDirection
                ClassObject.Count = Count
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class BundleDetailsModelExtra:
            def __init__(ClassObject, data: list["RobloxClient.Catalog.BundleDetailsModel"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class CatalogSearchDetailedResponseItemExtra:
            def __init__(ClassObject, data: list["RobloxClient.Catalog.CatalogSearchDetailedResponseItem"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class OwnedBundleModelExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Catalog.OwnedBundleModel"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetAssetToCategory(self) -> requests.Response:
            """
            Lists a mapping for assets to category IDs to convert from inventory ID to catalog ID. Creates a mapping to link 'Get More' button in inventory page to the relevant catalog page.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetAssetToCategory()
        
            Args:
                
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAssetToCategoryRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/asset-to-category", Dictinary=Dictinary)
            return GetAssetToCategoryRecivedData
        
        def GetAssetToSubcategory(self) -> requests.Response:
            """
            Lists a mapping for assets to subcategory IDs to convert from inventory ID to catalog ID. Creates a mapping to link 'Get More' button in inventory page to the relevant catalog page.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetAssetToSubcategory()
        
            Args:
                
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAssetToSubcategoryRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/asset-to-subcategory", Dictinary=Dictinary)
            return GetAssetToSubcategoryRecivedData
        
        def GetAssetsAssetidBundles(self, limit: int, cursor: str, sortOrder: str, assetId: int) -> BundleDetailsModelExtra:
            """
            Lists the bundles a particular asset belongs to. Use the Id of the last bundle in the response to get the next page.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetAssetsAssetidBundles(limit=integer, cursor=string, sortOrder=string, assetId=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            assetId: int
            Returns:
                Catalog.BundleDetailsModelExtra: Catalog.BundleDetailsModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetAssetsAssetidBundlesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/assets/{assetId}/bundles", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.BundleDetailsModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetAssetsAssetidBundlesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAssetsAssetidBundlesRecivedData)
            
            return ResponseSchema
        
        def GetBundlesBundleidDetails(self, bundleId: int) -> BundleDetailsModel:
            """
            Returns details about the given bundleId.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetBundlesBundleidDetails(bundleId=integer)
        
            Args:
                bundleId: int
            Returns:
                Catalog.BundleDetailsModel: Catalog.BundleDetailsModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetBundlesBundleidDetailsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/bundles/{bundleId}/details", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.BundleDetailsModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetBundlesBundleidDetailsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetBundlesBundleidDetailsRecivedData)
            
            return ResponseSchema
        
        def GetBundlesBundleidRecommendations(self, numItems: int, bundleId: int) -> BundleDetailsModelExtra:
            """
            Gets recommendations for a given bundle, bundleId of 0 returns randomized bundles

- Accepts both public and authenticated users
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetBundlesBundleidRecommendations(numItems=integer, bundleId=integer)
        
            Args:
                numItems: int
            bundleId: int
            Returns:
                Catalog.BundleDetailsModelExtra: Catalog.BundleDetailsModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"numItems": numItems},"headers": {},"cookies": {}}
            
            GetBundlesBundleidRecommendationsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/bundles/{bundleId}/recommendations", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.BundleDetailsModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetBundlesBundleidRecommendationsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetBundlesBundleidRecommendationsRecivedData)
            
            return ResponseSchema
        
        def GetBundlesDetails(self, bundleIds: list) -> requests.Response:
            """
            Returns details about the given bundleIds.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetBundlesDetails(bundleIds=array)
        
            Args:
                bundleIds: list
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"bundleIds": bundleIds},"headers": {},"cookies": {}}
            
            GetBundlesDetailsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/bundles/details", Dictinary=Dictinary)
            return GetBundlesDetailsRecivedData
        
        def GetCategories(self) -> requests.Response:
            """
            Lists Category Names and their Ids
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetCategories()
        
            Args:
                
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetCategoriesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/categories", Dictinary=Dictinary)
            return GetCategoriesRecivedData
        
        def GetFavoritesAssetsAssetidCount(self, assetId: int) -> requests.Response:
            """
            Gets the favorite count for the given asset Id.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetFavoritesAssetsAssetidCount(assetId=integer)
        
            Args:
                assetId: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetFavoritesAssetsAssetidCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/favorites/assets/{assetId}/count", Dictinary=Dictinary)
            return GetFavoritesAssetsAssetidCountRecivedData
        
        def GetFavoritesBundlesBundleidCount(self, bundleId: int) -> requests.Response:
            """
            Gets the favorite count for the given bundle Id.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetFavoritesBundlesBundleidCount(bundleId=integer)
        
            Args:
                bundleId: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetFavoritesBundlesBundleidCountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/favorites/bundles/{bundleId}/count", Dictinary=Dictinary)
            return GetFavoritesBundlesBundleidCountRecivedData
        
        def DeleteFavoritesUsersUseridAssetsAssetidFavorite(self, userId: int, assetId: int) -> ApiEmptyResponseModel:
            """
            Delete a favorite for an asset by the authenticated user.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.DeleteFavoritesUsersUseridAssetsAssetidFavorite(userId=integer, assetId=integer)
        
            Args:
                userId: int
            assetId: int
            Returns:
                Catalog.ApiEmptyResponseModel: Catalog.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteFavoritesUsersUseridAssetsAssetidFavoriteRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Catalog.roblox.com/v1/favorites/users/{userId}/assets/{assetId}/favorite", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteFavoritesUsersUseridAssetsAssetidFavoriteRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteFavoritesUsersUseridAssetsAssetidFavoriteRecivedData)
            
            return ResponseSchema
        
        def GetFavoritesUsersUseridAssetsAssetidFavorite(self, userId: int, assetId: int) -> AssetFavoriteModel:
            """
            Gets the favorite model for the asset and user.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetFavoritesUsersUseridAssetsAssetidFavorite(userId=integer, assetId=integer)
        
            Args:
                userId: int
            assetId: int
            Returns:
                Catalog.AssetFavoriteModel: Catalog.AssetFavoriteModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetFavoritesUsersUseridAssetsAssetidFavoriteRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/favorites/users/{userId}/assets/{assetId}/favorite", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.AssetFavoriteModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetFavoritesUsersUseridAssetsAssetidFavoriteRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetFavoritesUsersUseridAssetsAssetidFavoriteRecivedData)
            
            return ResponseSchema
        
        def PostFavoritesUsersUseridAssetsAssetidFavorite(self, userId: int, assetId: int) -> ApiEmptyResponseModel:
            """
            Create a favorite for an asset by the authenticated user.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.PostFavoritesUsersUseridAssetsAssetidFavorite(userId=integer, assetId=integer)
        
            Args:
                userId: int
            assetId: int
            Returns:
                Catalog.ApiEmptyResponseModel: Catalog.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostFavoritesUsersUseridAssetsAssetidFavoriteRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Catalog.roblox.com/v1/favorites/users/{userId}/assets/{assetId}/favorite", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostFavoritesUsersUseridAssetsAssetidFavoriteRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostFavoritesUsersUseridAssetsAssetidFavoriteRecivedData)
            
            return ResponseSchema
        
        def DeleteFavoritesUsersUseridBundlesBundleidFavorite(self, userId: int, bundleId: int) -> ApiEmptyResponseModel:
            """
            Delete favorite for the bundle by the authenticated user.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.DeleteFavoritesUsersUseridBundlesBundleidFavorite(userId=integer, bundleId=integer)
        
            Args:
                userId: int
            bundleId: int
            Returns:
                Catalog.ApiEmptyResponseModel: Catalog.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteFavoritesUsersUseridBundlesBundleidFavoriteRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Catalog.roblox.com/v1/favorites/users/{userId}/bundles/{bundleId}/favorite", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteFavoritesUsersUseridBundlesBundleidFavoriteRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteFavoritesUsersUseridBundlesBundleidFavoriteRecivedData)
            
            return ResponseSchema
        
        def GetFavoritesUsersUseridBundlesBundleidFavorite(self, userId: int, bundleId: int) -> BundleFavoriteModel:
            """
            Gets the favorite model for the bundle and user.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetFavoritesUsersUseridBundlesBundleidFavorite(userId=integer, bundleId=integer)
        
            Args:
                userId: int
            bundleId: int
            Returns:
                Catalog.BundleFavoriteModel: Catalog.BundleFavoriteModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetFavoritesUsersUseridBundlesBundleidFavoriteRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/favorites/users/{userId}/bundles/{bundleId}/favorite", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.BundleFavoriteModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetFavoritesUsersUseridBundlesBundleidFavoriteRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetFavoritesUsersUseridBundlesBundleidFavoriteRecivedData)
            
            return ResponseSchema
        
        def PostFavoritesUsersUseridBundlesBundleidFavorite(self, userId: int, bundleId: int) -> ApiEmptyResponseModel:
            """
            Create a favorite for the bundle by the authenticated user.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.PostFavoritesUsersUseridBundlesBundleidFavorite(userId=integer, bundleId=integer)
        
            Args:
                userId: int
            bundleId: int
            Returns:
                Catalog.ApiEmptyResponseModel: Catalog.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostFavoritesUsersUseridBundlesBundleidFavoriteRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Catalog.roblox.com/v1/favorites/users/{userId}/bundles/{bundleId}/favorite", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostFavoritesUsersUseridBundlesBundleidFavoriteRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostFavoritesUsersUseridBundlesBundleidFavoriteRecivedData)
            
            return ResponseSchema
        
        def GetFavoritesUsersUseridFavoritesSubtypeidBundles(self, pageNumber: int, itemsPerPage: int, cursor: str, isPrevious: bool, userId: int, subtypeId: int) -> FavoriteBundlesResponse:
            """
            Lists the bundles favorited by a given user with the given bundle subtypeId.

After 5/31/2024, only cursor based pagination will be supported.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetFavoritesUsersUseridFavoritesSubtypeidBundles(pageNumber=integer, itemsPerPage=integer, cursor=string, isPrevious=boolean, userId=integer, subtypeId=integer)
        
            Args:
                pageNumber: int
            itemsPerPage: int
            cursor: str
            isPrevious: bool
            userId: int
            subtypeId: int
            Returns:
                Catalog.FavoriteBundlesResponse: Catalog.FavoriteBundlesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"pageNumber": pageNumber, "itemsPerPage": itemsPerPage, "cursor": cursor, "isPrevious": isPrevious},"headers": {},"cookies": {}}
            
            GetFavoritesUsersUseridFavoritesSubtypeidBundlesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/favorites/users/{userId}/favorites/{subtypeId}/bundles", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.FavoriteBundlesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetFavoritesUsersUseridFavoritesSubtypeidBundlesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetFavoritesUsersUseridFavoritesSubtypeidBundlesRecivedData)
            
            return ResponseSchema
        
        def GetSubcategories(self) -> requests.Response:
            """
            Lists Subcategory Names and their Ids
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetSubcategories()
        
            Args:
                
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetSubcategoriesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/subcategories", Dictinary=Dictinary)
            return GetSubcategoriesRecivedData
        
        def GetUsersUseridBundles(self, limit: int, cursor: str, sortOrder: str, userId: int) -> OwnedBundleModelExtra:
            """
            Lists the bundles owned by a given user.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetUsersUseridBundles(limit=integer, cursor=string, sortOrder=string, userId=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            userId: int
            Returns:
                Catalog.OwnedBundleModelExtra: Catalog.OwnedBundleModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetUsersUseridBundlesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/users/{userId}/bundles", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.OwnedBundleModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridBundlesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridBundlesRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridBundlesBundletype(self, limit: int, cursor: str, sortOrder: str, userId: int, bundleType: int) -> OwnedBundleModelExtra:
            """
            Unknown
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.GetUsersUseridBundlesBundletype(limit=integer, cursor=string, sortOrder=string, userId=integer, bundleType=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            userId: int
            bundleType: int
            Returns:
                Catalog.OwnedBundleModelExtra: Catalog.OwnedBundleModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetUsersUseridBundlesBundletypeRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Catalog.roblox.com/v1/users/{userId}/bundles/{bundleType}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.OwnedBundleModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridBundlesBundletypeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridBundlesBundletypeRecivedData)
            
            return ResponseSchema
        
        def PostCatalogItemsDetails(self, MultigetItemDetailsRequestModel: MultigetItemDetailsRequestModel) -> CatalogSearchDetailedResponseItemExtra:
            """
            Returns list of item details.
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.PostCatalogItemsDetails(MultigetItemDetailsRequestModel=Catalog.MultigetItemDetailsRequestModel())
        
            Args:
                MultigetItemDetailsRequestModel: MultigetItemDetailsRequestModel
            Returns:
                Catalog.CatalogSearchDetailedResponseItemExtra: Catalog.CatalogSearchDetailedResponseItemExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'MultigetItemDetailsRequestModel': 'json'}
            Arguments = inspect.signature(self.PostCatalogItemsDetails)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostCatalogItemsDetailsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Catalog.roblox.com/v1/catalog/items/details", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.CatalogSearchDetailedResponseItemExtra()
        
            ReturnedJson = None
            try: ReturnedJson = PostCatalogItemsDetailsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostCatalogItemsDetailsRecivedData)
            
            return ResponseSchema
        
        def PostTopicGetTopics(self, TopicRequestModel: TopicRequestModel) -> TopicResponse:
            """
            
            
            Usage:
                import Catalog
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                CatalogApi = Catalog.CatalogApi(RobloxClient=RobloxClient)
                Response = CatalogApi.PostTopicGetTopics(TopicRequestModel=Catalog.TopicRequestModel())
        
            Args:
                TopicRequestModel: TopicRequestModel
            Returns:
                Catalog.TopicResponse: Catalog.TopicResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'TopicRequestModel': 'json'}
            Arguments = inspect.signature(self.PostTopicGetTopics)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostTopicGetTopicsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Catalog.roblox.com/v1/topic/get-topics", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Catalog.TopicResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostTopicGetTopicsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTopicGetTopicsRecivedData)
            
            return ResponseSchema
        
    class Badges:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class BadgeAwardResponse:
            def __init__(ClassObject, badgeId: int = None, awardedDate: str = None):
                ClassObject.badgeId = badgeId
                ClassObject.awardedDate = awardedDate
                ClassObject.response: requests.Response = None


        class BadgeCreatorResponse:
            def __init__(ClassObject, id: int = None, name: str = None, type: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.type = type
                ClassObject.response: requests.Response = None


        class BadgeMetadataResponse:
            def __init__(ClassObject, badgeCreationPrice: int = None, maxBadgeNameLength: int = None, maxBadgeDescriptionLength: int = None):
                ClassObject.badgeCreationPrice = badgeCreationPrice
                ClassObject.maxBadgeNameLength = maxBadgeNameLength
                ClassObject.maxBadgeDescriptionLength = maxBadgeDescriptionLength
                ClassObject.response: requests.Response = None


        class BadgeAwardStatisticsResponse:
            def __init__(ClassObject, pastDayAwardedCount: int = None, awardedCount: int = None, winRatePercentage: float = None):
                ClassObject.pastDayAwardedCount = pastDayAwardedCount
                ClassObject.awardedCount = awardedCount
                ClassObject.winRatePercentage = winRatePercentage
                ClassObject.response: requests.Response = None


        class UniverseResponse:
            def __init__(ClassObject, id: int = None, name: str = None, rootPlaceId: int = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.rootPlaceId = rootPlaceId
                ClassObject.response: requests.Response = None


        class BadgeResponse:
            def __init__(ClassObject, id: int = None, name: str = None, description: str = None, displayName: str = None, displayDescription: str = None, enabled: bool = None, iconImageId: int = None, displayIconImageId: int = None, created: str = None, updated: str = None, statistics: "RobloxClient.Badges.BadgeAwardStatisticsResponse" = None, awardingUniverse: "RobloxClient.Badges.UniverseResponse" = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.displayName = displayName
                ClassObject.displayDescription = displayDescription
                ClassObject.enabled = enabled
                ClassObject.iconImageId = iconImageId
                ClassObject.displayIconImageId = displayIconImageId
                ClassObject.created = created
                ClassObject.updated = updated
                ClassObject.statistics = statistics
                ClassObject.awardingUniverse = awardingUniverse
                ClassObject.response: requests.Response = None


        class BadgeAwarderTypeExtra:
            def __init__(ClassObject, id: int = None, type: enum.Enum = None, name: str = None):
                ClassObject.id = id
                ClassObject.type = type
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class GetBadgesByUserResponse:
            def __init__(ClassObject, creator: "RobloxClient.Badges.BadgeCreatorResponse" = None, id: int = None, name: str = None, description: str = None, displayName: str = None, displayDescription: str = None, enabled: bool = None, iconImageId: int = None, displayIconImageId: int = None, awarder: "RobloxClient.Badges.BadgeAwarderTypeExtra" = None, statistics: "RobloxClient.Badges.BadgeAwardStatisticsResponse" = None, created: str = None, updated: str = None):
                ClassObject.creator = creator
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.displayName = displayName
                ClassObject.displayDescription = displayDescription
                ClassObject.enabled = enabled
                ClassObject.iconImageId = iconImageId
                ClassObject.displayIconImageId = displayIconImageId
                ClassObject.awarder = awarder
                ClassObject.statistics = statistics
                ClassObject.created = created
                ClassObject.updated = updated
                ClassObject.response: requests.Response = None


        class UpdateBadgeRequest:
            def __init__(ClassObject, name: str = None, description: str = None, enabled: bool = None):
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.enabled = enabled
                ClassObject.response: requests.Response = None


        class StringExtra:
            def __init__(ClassObject, key: str = None, sortOrder: enum.Enum = None, pagingDirection: enum.Enum = None, pageNumber: int = None, discriminator: str = None, count: int = None):
                ClassObject.key = key
                ClassObject.sortOrder = sortOrder
                ClassObject.pagingDirection = pagingDirection
                ClassObject.pageNumber = pageNumber
                ClassObject.discriminator = discriminator
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class BadgeResponseV2:
            def __init__(ClassObject, id: int = None, name: str = None, description: str = None, displayName: str = None, displayDescription: str = None, enabled: bool = None, iconImageId: int = None, displayIconImageId: int = None, awarder: "RobloxClient.Badges.BadgeAwarderTypeExtra" = None, statistics: "RobloxClient.Badges.BadgeAwardStatisticsResponse" = None, created: str = None, updated: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.displayName = displayName
                ClassObject.displayDescription = displayDescription
                ClassObject.enabled = enabled
                ClassObject.iconImageId = iconImageId
                ClassObject.displayIconImageId = displayIconImageId
                ClassObject.awarder = awarder
                ClassObject.statistics = statistics
                ClassObject.created = created
                ClassObject.updated = updated
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class BadgeAwardResponseExtra:
            def __init__(ClassObject, data: list["RobloxClient.Badges.BadgeAwardResponse"] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class BadgeResponseExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Badges.BadgeResponse"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class GetBadgesByUserResponseExtra:
            def __init__(ClassObject, previousPageCursor: str = None, nextPageCursor: str = None, data: list["RobloxClient.Badges.GetBadgesByUserResponse"] = None):
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class Stream:
            def __init__(ClassObject, CanRead: bool = None, CanWrite: bool = None, CanSeek: bool = None, CanTimeout: bool = None, Length: int = None, Position: int = None, ReadTimeout: int = None, WriteTimeout: int = None):
                ClassObject.CanRead = CanRead
                ClassObject.CanWrite = CanWrite
                ClassObject.CanSeek = CanSeek
                ClassObject.CanTimeout = CanTimeout
                ClassObject.Length = Length
                ClassObject.Position = Position
                ClassObject.ReadTimeout = ReadTimeout
                ClassObject.WriteTimeout = WriteTimeout
                ClassObject.response: requests.Response = None


        class IUploadedFile:
            def __init__(ClassObject, Name: str = None, Stream: "RobloxClient.Badges.Stream" = None, ContentEncoding: enum.Enum = None):
                ClassObject.Name = Name
                ClassObject.Stream = Stream
                ClassObject.ContentEncoding = ContentEncoding
                ClassObject.response: requests.Response = None



        
        def GetBadgesBadgeid(self, badgeId: int) -> BadgeResponse:
            """
            Gets badge information by the badge Id.
            
            Usage:
                import Badges
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                BadgesApi = Badges.BadgesApi(RobloxClient=RobloxClient)
                Response = BadgesApi.GetBadgesBadgeid(badgeId=integer)
        
            Args:
                badgeId: int
            Returns:
                Badges.BadgeResponse: Badges.BadgeResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetBadgesBadgeidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Badges.roblox.com/v1/badges/{badgeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Badges.BadgeResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetBadgesBadgeidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetBadgesBadgeidRecivedData)
            
            return ResponseSchema
        
        def PatchBadgesBadgeid(self, badgeId: int, UpdateBadgeRequest: UpdateBadgeRequest) -> ApiEmptyResponseModel:
            """
            Updates badge configuration.
            
            Usage:
                import Badges
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                BadgesApi = Badges.BadgesApi(RobloxClient=RobloxClient)
                Response = BadgesApi.PatchBadgesBadgeid(badgeId=integer, UpdateBadgeRequest=Badges.UpdateBadgeRequest())
        
            Args:
                badgeId: int
            UpdateBadgeRequest: UpdateBadgeRequest
            Returns:
                Badges.ApiEmptyResponseModel: Badges.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateBadgeRequest': 'json'}
            Arguments = inspect.signature(self.PatchBadgesBadgeid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchBadgesBadgeidRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Badges.roblox.com/v1/badges/{badgeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Badges.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchBadgesBadgeidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchBadgesBadgeidRecivedData)
            
            return ResponseSchema
        
        def GetBadgesMetadata(self) -> BadgeMetadataResponse:
            """
            Gets metadata about the badges system.
            
            Usage:
                import Badges
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                BadgesApi = Badges.BadgesApi(RobloxClient=RobloxClient)
                Response = BadgesApi.GetBadgesMetadata()
        
            Args:
                
            Returns:
                Badges.BadgeMetadataResponse: Badges.BadgeMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetBadgesMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Badges.roblox.com/v1/badges/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Badges.BadgeMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetBadgesMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetBadgesMetadataRecivedData)
            
            return ResponseSchema
        
        def GetUniversesUniverseidBadges(self, sortBy: str, limit: int, cursor: str, sortOrder: str, universeId: int) -> BadgeResponseExtra:
            """
            Gets badges by their awarding game.
            
            Usage:
                import Badges
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                BadgesApi = Badges.BadgesApi(RobloxClient=RobloxClient)
                Response = BadgesApi.GetUniversesUniverseidBadges(sortBy=string, limit=integer, cursor=string, sortOrder=string, universeId=integer)
        
            Args:
                sortBy: str
            limit: int
            cursor: str
            sortOrder: str
            universeId: int
            Returns:
                Badges.BadgeResponseExtra: Badges.BadgeResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"sortBy": sortBy, "limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetUniversesUniverseidBadgesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Badges.roblox.com/v1/universes/{universeId}/badges", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Badges.BadgeResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUniversesUniverseidBadgesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUniversesUniverseidBadgesRecivedData)
            
            return ResponseSchema
        
        def PostUniversesUniverseidBadges(self, universeId: int, name: str, description: str, paymentSourceType: int, files: typing.IO, expectedCost: int, isActive: bool) -> BadgeResponseV2:
            """
            Creates a new badge.
            
            Usage:
                import Badges
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                BadgesApi = Badges.BadgesApi(RobloxClient=RobloxClient)
                Response = BadgesApi.PostUniversesUniverseidBadges(universeId=integer, name=string, description=string, paymentSourceType=integer, files=file, expectedCost=integer, isActive=boolean)
        
            Args:
                universeId: int
            name: str
            description: str
            paymentSourceType: int
            files: typing.IO
            expectedCost: int
            isActive: bool
            Returns:
                Badges.BadgeResponseV2: Badges.BadgeResponseV2
            """
        
            Dictinary = {"json": {},"data": {"name": name, "description": description, "paymentSourceType": paymentSourceType, "files": files, "expectedCost": expectedCost, "isActive": isActive},"params": {},"headers": {},"cookies": {}}
            
            PostUniversesUniverseidBadgesRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Badges.roblox.com/v1/universes/{universeId}/badges", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Badges.BadgeResponseV2()
        
            ReturnedJson = None
            try: ReturnedJson = PostUniversesUniverseidBadgesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUniversesUniverseidBadgesRecivedData)
            
            return ResponseSchema
        
        def GetUniversesUniverseidFreeBadgesQuota(self, universeId: int) -> requests.Response:
            """
            Gets the number of free badges left for the current UTC day by their awarding game.
            
            Usage:
                import Badges
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                BadgesApi = Badges.BadgesApi(RobloxClient=RobloxClient)
                Response = BadgesApi.GetUniversesUniverseidFreeBadgesQuota(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUniversesUniverseidFreeBadgesQuotaRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Badges.roblox.com/v1/universes/{universeId}/free-badges-quota", Dictinary=Dictinary)
            return GetUniversesUniverseidFreeBadgesQuotaRecivedData
        
        def GetUsersUseridBadges(self, limit: int, cursor: str, sortOrder: str, userId: int) -> GetBadgesByUserResponseExtra:
            """
            Gets a list of badges a user has been awarded.
            
            Usage:
                import Badges
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                BadgesApi = Badges.BadgesApi(RobloxClient=RobloxClient)
                Response = BadgesApi.GetUsersUseridBadges(limit=integer, cursor=string, sortOrder=string, userId=integer)
        
            Args:
                limit: int
            cursor: str
            sortOrder: str
            userId: int
            Returns:
                Badges.GetBadgesByUserResponseExtra: Badges.GetBadgesByUserResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"limit": limit, "cursor": cursor, "sortOrder": sortOrder},"headers": {},"cookies": {}}
            
            GetUsersUseridBadgesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Badges.roblox.com/v1/users/{userId}/badges", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Badges.GetBadgesByUserResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridBadgesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridBadgesRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridBadgesBadgeidAwardedDate(self, userId: int, badgeId: int) -> requests.Response:
            """
            Gets timestamp for when a single badge was awarded to a user.
            
            Usage:
                import Badges
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                BadgesApi = Badges.BadgesApi(RobloxClient=RobloxClient)
                Response = BadgesApi.GetUsersUseridBadgesBadgeidAwardedDate(userId=integer, badgeId=integer)
        
            Args:
                userId: int
            badgeId: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridBadgesBadgeidAwardedDateRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Badges.roblox.com/v1/users/{userId}/badges/{badgeId}/awarded-date", Dictinary=Dictinary)
            return GetUsersUseridBadgesBadgeidAwardedDateRecivedData
        
        def GetUsersUseridBadgesAwardedDates(self, badgeIds: list, userId: int) -> BadgeAwardResponseExtra:
            """
            Gets timestamps for when badges were awarded to a user.
            
            Usage:
                import Badges
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                BadgesApi = Badges.BadgesApi(RobloxClient=RobloxClient)
                Response = BadgesApi.GetUsersUseridBadgesAwardedDates(badgeIds=array, userId=integer)
        
            Args:
                badgeIds: list
            userId: int
            Returns:
                Badges.BadgeAwardResponseExtra: Badges.BadgeAwardResponseExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"badgeIds": badgeIds},"headers": {},"cookies": {}}
            
            GetUsersUseridBadgesAwardedDatesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Badges.roblox.com/v1/users/{userId}/badges/awarded-dates", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Badges.BadgeAwardResponseExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridBadgesAwardedDatesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridBadgesAwardedDatesRecivedData)
            
            return ResponseSchema
        
        def DeleteUserUseridBadgesBadgeid(self, userId: int, badgeId: int) -> ApiEmptyResponseModel:
            """
            Removes a badge from the user.
            
            Usage:
                import Badges
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                BadgesApi = Badges.BadgesApi(RobloxClient=RobloxClient)
                Response = BadgesApi.DeleteUserUseridBadgesBadgeid(userId=integer, badgeId=integer)
        
            Args:
                userId: int
            badgeId: int
            Returns:
                Badges.ApiEmptyResponseModel: Badges.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteUserUseridBadgesBadgeidRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Badges.roblox.com/v1/user/{userId}/badges/{badgeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Badges.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteUserUseridBadgesBadgeidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteUserUseridBadgesBadgeidRecivedData)
            
            return ResponseSchema
        
        def DeleteUserBadgesBadgeid(self, badgeId: int) -> ApiEmptyResponseModel:
            """
            Removes a badge from the authenticated user.
            
            Usage:
                import Badges
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                BadgesApi = Badges.BadgesApi(RobloxClient=RobloxClient)
                Response = BadgesApi.DeleteUserBadgesBadgeid(badgeId=integer)
        
            Args:
                badgeId: int
            Returns:
                Badges.ApiEmptyResponseModel: Badges.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteUserBadgesBadgeidRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Badges.roblox.com/v1/user/badges/{badgeId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Badges.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteUserBadgesBadgeidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteUserBadgesBadgeidRecivedData)
            
            return ResponseSchema
        
    class Avatar:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class EmptyResponse:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class AssetIdListModel:
            def __init__(ClassObject, assetIds: list[int] = None):
                ClassObject.assetIds = assetIds
                ClassObject.response: requests.Response = None


        class AssetPosition:
            def __init__(ClassObject, X: float = None, Y: float = None, Z: float = None):
                ClassObject.X = X
                ClassObject.Y = Y
                ClassObject.Z = Z
                ClassObject.response: requests.Response = None


        class AssetRotation:
            def __init__(ClassObject, X: float = None, Y: float = None, Z: float = None):
                ClassObject.X = X
                ClassObject.Y = Y
                ClassObject.Z = Z
                ClassObject.response: requests.Response = None


        class AssetScale:
            def __init__(ClassObject, X: float = None, Y: float = None, Z: float = None):
                ClassObject.X = X
                ClassObject.Y = Y
                ClassObject.Z = Z
                ClassObject.response: requests.Response = None


        class AssetMetaModelV1:
            def __init__(ClassObject, order: int = None, puffiness: float = None, position: "RobloxClient.Avatar.AssetPosition" = None, rotation: "RobloxClient.Avatar.AssetRotation" = None, scale: "RobloxClient.Avatar.AssetScale" = None, version: int = None):
                ClassObject.order = order
                ClassObject.puffiness = puffiness
                ClassObject.position = position
                ClassObject.rotation = rotation
                ClassObject.scale = scale
                ClassObject.version = version
                ClassObject.response: requests.Response = None


        class AssetTypeModel:
            def __init__(ClassObject, id: int = None, name: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class AssetModelV2:
            def __init__(ClassObject, id: int = None, name: str = None, assetType: "RobloxClient.Avatar.AssetTypeModel" = None, currentVersionId: int = None, meta: "RobloxClient.Avatar.AssetMetaModelV1" = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.assetType = assetType
                ClassObject.currentVersionId = currentVersionId
                ClassObject.meta = meta
                ClassObject.response: requests.Response = None


        class AssetTypeRulesModel:
            def __init__(ClassObject, maxNumber: int = None, id: int = None, name: str = None):
                ClassObject.maxNumber = maxNumber
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class AvatarApiSuccessResponse:
            def __init__(ClassObject, success: bool = None):
                ClassObject.success = success
                ClassObject.response: requests.Response = None


        class OutfitModel:
            def __init__(ClassObject, id: int = None, name: str = None, isEditable: bool = None, outfitType: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.isEditable = isEditable
                ClassObject.outfitType = outfitType
                ClassObject.response: requests.Response = None


        class OutfitModelExtra:
            def __init__(ClassObject, filteredCount: int = None, data: list["RobloxClient.Avatar.OutfitModel"] = None, total: int = None):
                ClassObject.filteredCount = filteredCount
                ClassObject.data = data
                ClassObject.total = total
                ClassObject.response: requests.Response = None


        class AvatarMetadataModel:
            def __init__(ClassObject, enableDefaultClothingMessage: bool = None, isAvatarScaleEmbeddedInTab: bool = None, isBodyTypeScaleOutOfTab: bool = None, scaleHeightIncrement: float = None, scaleWidthIncrement: float = None, scaleHeadIncrement: float = None, scaleProportionIncrement: float = None, scaleBodyTypeIncrement: float = None, supportProportionAndBodyType: bool = None, showDefaultClothingMessageOnPageLoad: bool = None, areThreeDeeThumbsEnabled: bool = None, isAvatarWearingApiCallsLockingOnFrontendEnabled: bool = None, isOutfitHandlingOnFrontendEnabled: bool = None, isJustinUiChangesEnabled: bool = None, isCategoryReorgEnabled: bool = None, LCEnabledInEditorAndCatalog: bool = None, isLCCompletelyEnabled: bool = None):
                ClassObject.enableDefaultClothingMessage = enableDefaultClothingMessage
                ClassObject.isAvatarScaleEmbeddedInTab = isAvatarScaleEmbeddedInTab
                ClassObject.isBodyTypeScaleOutOfTab = isBodyTypeScaleOutOfTab
                ClassObject.scaleHeightIncrement = scaleHeightIncrement
                ClassObject.scaleWidthIncrement = scaleWidthIncrement
                ClassObject.scaleHeadIncrement = scaleHeadIncrement
                ClassObject.scaleProportionIncrement = scaleProportionIncrement
                ClassObject.scaleBodyTypeIncrement = scaleBodyTypeIncrement
                ClassObject.supportProportionAndBodyType = supportProportionAndBodyType
                ClassObject.showDefaultClothingMessageOnPageLoad = showDefaultClothingMessageOnPageLoad
                ClassObject.areThreeDeeThumbsEnabled = areThreeDeeThumbsEnabled
                ClassObject.isAvatarWearingApiCallsLockingOnFrontendEnabled = isAvatarWearingApiCallsLockingOnFrontendEnabled
                ClassObject.isOutfitHandlingOnFrontendEnabled = isOutfitHandlingOnFrontendEnabled
                ClassObject.isJustinUiChangesEnabled = isJustinUiChangesEnabled
                ClassObject.isCategoryReorgEnabled = isCategoryReorgEnabled
                ClassObject.LCEnabledInEditorAndCatalog = LCEnabledInEditorAndCatalog
                ClassObject.isLCCompletelyEnabled = isLCCompletelyEnabled
                ClassObject.response: requests.Response = None


        class ScaleModel:
            def __init__(ClassObject, height: float = None, width: float = None, head: float = None, depth: float = None, proportion: float = None, bodyType: float = None):
                ClassObject.height = height
                ClassObject.width = width
                ClassObject.head = head
                ClassObject.depth = depth
                ClassObject.proportion = proportion
                ClassObject.bodyType = bodyType
                ClassObject.response: requests.Response = None


        class BodyColorsModel:
            def __init__(ClassObject, headColorId: int = None, torsoColorId: int = None, rightArmColorId: int = None, leftArmColorId: int = None, rightLegColorId: int = None, leftLegColorId: int = None):
                ClassObject.headColorId = headColorId
                ClassObject.torsoColorId = torsoColorId
                ClassObject.rightArmColorId = rightArmColorId
                ClassObject.leftArmColorId = leftArmColorId
                ClassObject.rightLegColorId = rightLegColorId
                ClassObject.leftLegColorId = leftLegColorId
                ClassObject.response: requests.Response = None


        class EmoteResponseModel:
            def __init__(ClassObject, assetId: int = None, assetName: str = None, position: int = None):
                ClassObject.assetId = assetId
                ClassObject.assetName = assetName
                ClassObject.position = position
                ClassObject.response: requests.Response = None


        class AvatarModelV2:
            def __init__(ClassObject, scales: "RobloxClient.Avatar.ScaleModel" = None, playerAvatarType: enum.Enum = None, bodyColors: "RobloxClient.Avatar.BodyColorsModel" = None, assets: list["RobloxClient.Avatar.AssetModelV2"] = None, defaultShirtApplied: bool = None, defaultPantsApplied: bool = None, emotes: list["RobloxClient.Avatar.EmoteResponseModel"] = None):
                ClassObject.scales = scales
                ClassObject.playerAvatarType = playerAvatarType
                ClassObject.bodyColors = bodyColors
                ClassObject.assets = assets
                ClassObject.defaultShirtApplied = defaultShirtApplied
                ClassObject.defaultPantsApplied = defaultPantsApplied
                ClassObject.emotes = emotes
                ClassObject.response: requests.Response = None


        class BodyColorModel:
            def __init__(ClassObject, brickColorId: int = None, hexColor: str = None, name: str = None):
                ClassObject.brickColorId = brickColorId
                ClassObject.hexColor = hexColor
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class DefaultClothingAssets:
            def __init__(ClassObject, defaultShirtAssetIds: list[int] = None, defaultPantAssetIds: list[int] = None):
                ClassObject.defaultShirtAssetIds = defaultShirtAssetIds
                ClassObject.defaultPantAssetIds = defaultPantAssetIds
                ClassObject.response: requests.Response = None


        class AvatarRulesModel:
            def __init__(ClassObject, playerAvatarTypes: list[int] = None, scales: typing.Dict[str, any] = None, wearableAssetTypes: list["RobloxClient.Avatar.AssetTypeRulesModel"] = None, accessoryRefinementTypes: list[int] = None, accessoryRefinementLowerBounds: dict = None, accessoryRefinementUpperBounds: dict = None, bodyColorsPalette: list["RobloxClient.Avatar.BodyColorModel"] = None, basicBodyColorsPalette: list["RobloxClient.Avatar.BodyColorModel"] = None, minimumDeltaEBodyColorDifference: float = None, proportionsAndBodyTypeEnabledForUser: bool = None, defaultClothingAssetLists: "RobloxClient.Avatar.DefaultClothingAssets" = None, bundlesEnabledForUser: bool = None, emotesEnabledForUser: bool = None):
                ClassObject.playerAvatarTypes = playerAvatarTypes
                ClassObject.scales = scales
                ClassObject.wearableAssetTypes = wearableAssetTypes
                ClassObject.accessoryRefinementTypes = accessoryRefinementTypes
                ClassObject.accessoryRefinementLowerBounds = accessoryRefinementLowerBounds
                ClassObject.accessoryRefinementUpperBounds = accessoryRefinementUpperBounds
                ClassObject.bodyColorsPalette = bodyColorsPalette
                ClassObject.basicBodyColorsPalette = basicBodyColorsPalette
                ClassObject.minimumDeltaEBodyColorDifference = minimumDeltaEBodyColorDifference
                ClassObject.proportionsAndBodyTypeEnabledForUser = proportionsAndBodyTypeEnabledForUser
                ClassObject.defaultClothingAssetLists = defaultClothingAssetLists
                ClassObject.bundlesEnabledForUser = bundlesEnabledForUser
                ClassObject.emotesEnabledForUser = emotesEnabledForUser
                ClassObject.response: requests.Response = None


        class UniverseAvatarAssetOverrideResponseModel:
            def __init__(ClassObject, assetID: int = None, assetTypeID: int = None, isPlayerChoice: bool = None):
                ClassObject.assetID = assetID
                ClassObject.assetTypeID = assetTypeID
                ClassObject.isPlayerChoice = isPlayerChoice
                ClassObject.response: requests.Response = None


        class GameStartInfoResponse:
            def __init__(ClassObject, gameAvatarType: str = None, allowCustomAnimations: str = None, universeAvatarCollisionType: str = None, universeAvatarBodyType: str = None, jointPositioningType: str = None, message: str = None, universeAvatarMinScales: "RobloxClient.Avatar.ScaleModel" = None, universeAvatarMaxScales: "RobloxClient.Avatar.ScaleModel" = None, universeAvatarAssetOverrides: list["RobloxClient.Avatar.UniverseAvatarAssetOverrideResponseModel"] = None, moderationStatus: str = None):
                ClassObject.gameAvatarType = gameAvatarType
                ClassObject.allowCustomAnimations = allowCustomAnimations
                ClassObject.universeAvatarCollisionType = universeAvatarCollisionType
                ClassObject.universeAvatarBodyType = universeAvatarBodyType
                ClassObject.jointPositioningType = jointPositioningType
                ClassObject.message = message
                ClassObject.universeAvatarMinScales = universeAvatarMinScales
                ClassObject.universeAvatarMaxScales = universeAvatarMaxScales
                ClassObject.universeAvatarAssetOverrides = universeAvatarAssetOverrides
                ClassObject.moderationStatus = moderationStatus
                ClassObject.response: requests.Response = None


        class OutfitDetailsModel:
            def __init__(ClassObject, id: int = None, universeId: int = None, name: str = None, assets: list["RobloxClient.Avatar.AssetModelV2"] = None, bodyColors: "RobloxClient.Avatar.BodyColorsModel" = None, scale: "RobloxClient.Avatar.ScaleModel" = None, playerAvatarType: str = None, outfitType: str = None, isEditable: bool = None, moderationStatus: str = None):
                ClassObject.id = id
                ClassObject.universeId = universeId
                ClassObject.name = name
                ClassObject.assets = assets
                ClassObject.bodyColors = bodyColors
                ClassObject.scale = scale
                ClassObject.playerAvatarType = playerAvatarType
                ClassObject.outfitType = outfitType
                ClassObject.isEditable = isEditable
                ClassObject.moderationStatus = moderationStatus
                ClassObject.response: requests.Response = None


        class OutfitUpdateModelV1:
            def __init__(ClassObject, name: str = None, bodyColors: "RobloxClient.Avatar.BodyColorsModel" = None, assetIds: list[int] = None, scale: "RobloxClient.Avatar.ScaleModel" = None, playerAvatarType: str = None, outfitType: enum.Enum = None):
                ClassObject.name = name
                ClassObject.bodyColors = bodyColors
                ClassObject.assetIds = assetIds
                ClassObject.scale = scale
                ClassObject.playerAvatarType = playerAvatarType
                ClassObject.outfitType = outfitType
                ClassObject.response: requests.Response = None


        class PlayerAvatarTypeModel:
            def __init__(ClassObject, playerAvatarType: enum.Enum = None):
                ClassObject.playerAvatarType = playerAvatarType
                ClassObject.response: requests.Response = None


        class RecentItemModel:
            def __init__(ClassObject, id: int = None, name: str = None, type: enum.Enum = None, assetType: "RobloxClient.Avatar.AssetTypeModel" = None, isEditable: bool = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.type = type
                ClassObject.assetType = assetType
                ClassObject.isEditable = isEditable
                ClassObject.response: requests.Response = None


        class ScaleRulesModel:
            def __init__(ClassObject, min: float = None, max: float = None, increment: float = None):
                ClassObject.min = min
                ClassObject.max = max
                ClassObject.increment = increment
                ClassObject.response: requests.Response = None


        class WearResponseModel:
            def __init__(ClassObject, invalidAssets: list["RobloxClient.Avatar.AssetModelV2"] = None, invalidAssetIds: list[int] = None, success: bool = None):
                ClassObject.invalidAssets = invalidAssets
                ClassObject.invalidAssetIds = invalidAssetIds
                ClassObject.success = success
                ClassObject.response: requests.Response = None


        class AccessoryPositionModel:
            def __init__(ClassObject, xPosition: float = None, yPosition: float = None, zPosition: float = None):
                ClassObject.xPosition = xPosition
                ClassObject.yPosition = yPosition
                ClassObject.zPosition = zPosition
                ClassObject.response: requests.Response = None


        class AccessoryRotationModel:
            def __init__(ClassObject, xRotation: float = None, yRotation: float = None, zRotation: float = None):
                ClassObject.xRotation = xRotation
                ClassObject.yRotation = yRotation
                ClassObject.zRotation = zRotation
                ClassObject.response: requests.Response = None


        class AccessoryScaleModel:
            def __init__(ClassObject, xScale: float = None, yScale: float = None, zScale: float = None):
                ClassObject.xScale = xScale
                ClassObject.yScale = yScale
                ClassObject.zScale = zScale
                ClassObject.response: requests.Response = None


        class AccessoryRefinementModel:
            def __init__(ClassObject, position: "RobloxClient.Avatar.AccessoryPositionModel" = None, rotation: "RobloxClient.Avatar.AccessoryRotationModel" = None, scale: "RobloxClient.Avatar.AccessoryScaleModel" = None):
                ClassObject.position = position
                ClassObject.rotation = rotation
                ClassObject.scale = scale
                ClassObject.response: requests.Response = None


        class RecentItemModelExtra:
            def __init__(ClassObject, data: list["RobloxClient.Avatar.RecentItemModel"] = None, total: int = None):
                ClassObject.data = data
                ClassObject.total = total
                ClassObject.response: requests.Response = None



        
        def GetAvatar(self) -> AvatarModelV2:
            """
            Returns details about the authenticated user's avatar
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.GetAvatar()
        
            Args:
                
            Returns:
                Avatar.AvatarModelV2: Avatar.AvatarModelV2
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAvatarRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Avatar.roblox.com/v1/avatar", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AvatarModelV2()
        
            ReturnedJson = None
            try: ReturnedJson = GetAvatarRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAvatarRecivedData)
            
            return ResponseSchema
        
        def GetAvatarRules(self) -> AvatarRulesModel:
            """
            Returns the business rules related to avatars
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.GetAvatarRules()
        
            Args:
                
            Returns:
                Avatar.AvatarRulesModel: Avatar.AvatarRulesModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAvatarRulesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Avatar.roblox.com/v1/avatar-rules", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AvatarRulesModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetAvatarRulesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAvatarRulesRecivedData)
            
            return ResponseSchema
        
        def GetAvatarMetadata(self) -> AvatarMetadataModel:
            """
            Returns metadata used by the avatar page of the website
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.GetAvatarMetadata()
        
            Args:
                
            Returns:
                Avatar.AvatarMetadataModel: Avatar.AvatarMetadataModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAvatarMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Avatar.roblox.com/v1/avatar/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AvatarMetadataModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetAvatarMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAvatarMetadataRecivedData)
            
            return ResponseSchema
        
        def GetGameStartInfo(self, universeId: int) -> GameStartInfoResponse:
            """
            The server will call this on game server start to request general information about the universe

This is version 1.1, which returns an entry from the UniverseAvatarType enum.

During mixed mode this may return unreliable results.
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.GetGameStartInfo(universeId=integer)
        
            Args:
                universeId: int
            Returns:
                Avatar.GameStartInfoResponse: Avatar.GameStartInfoResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"universeId": universeId},"headers": {},"cookies": {}}
            
            GetGameStartInfoRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Avatar.roblox.com/v1/game-start-info", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.GameStartInfoResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGameStartInfoRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGameStartInfoRecivedData)
            
            return ResponseSchema
        
        def GetOutfitsUseroutfitidDetails(self, userOutfitId: int) -> OutfitDetailsModel:
            """
            Unknown
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.GetOutfitsUseroutfitidDetails(userOutfitId=integer)
        
            Args:
                userOutfitId: int
            Returns:
                Avatar.OutfitDetailsModel: Avatar.OutfitDetailsModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetOutfitsUseroutfitidDetailsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Avatar.roblox.com/v1/outfits/{userOutfitId}/details", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.OutfitDetailsModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetOutfitsUseroutfitidDetailsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetOutfitsUseroutfitidDetailsRecivedData)
            
            return ResponseSchema
        
        def GetRecentItemsRecentitemlisttypeList(self, recentItemListType: int) -> RecentItemModelExtra:
            """
            Returns a list of recent items

Recent items can be Assets or Outfits
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.GetRecentItemsRecentitemlisttypeList(recentItemListType=integer)
        
            Args:
                recentItemListType: int
            Returns:
                Avatar.RecentItemModelExtra: Avatar.RecentItemModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetRecentItemsRecentitemlisttypeListRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Avatar.roblox.com/v1/recent-items/{recentItemListType}/list", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.RecentItemModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetRecentItemsRecentitemlisttypeListRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetRecentItemsRecentitemlisttypeListRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridAvatar(self, userId: int) -> AvatarModelV2:
            """
            Returns details about a specified user's avatar
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.GetUsersUseridAvatar(userId=integer)
        
            Args:
                userId: int
            Returns:
                Avatar.AvatarModelV2: Avatar.AvatarModelV2
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridAvatarRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Avatar.roblox.com/v1/users/{userId}/avatar", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AvatarModelV2()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridAvatarRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridAvatarRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridCurrentlyWearing(self, userId: int) -> AssetIdListModel:
            """
            Gets a list of asset ids that the user is currently wearing
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.GetUsersUseridCurrentlyWearing(userId=integer)
        
            Args:
                userId: int
            Returns:
                Avatar.AssetIdListModel: Avatar.AssetIdListModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridCurrentlyWearingRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Avatar.roblox.com/v1/users/{userId}/currently-wearing", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AssetIdListModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridCurrentlyWearingRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridCurrentlyWearingRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridOutfits(self, outfitType: str, page: int, itemsPerPage: int, isEditable: bool, userId: int) -> OutfitModelExtra:
            """
            Deprecated, user v2.

Gets a list of outfits for the specified user.
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.GetUsersUseridOutfits(outfitType=string, page=integer, itemsPerPage=integer, isEditable=boolean, userId=integer)
        
            Args:
                outfitType: str
            page: int
            itemsPerPage: int
            isEditable: bool
            userId: int
            Returns:
                Avatar.OutfitModelExtra: Avatar.OutfitModelExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {"outfitType": outfitType, "page": page, "itemsPerPage": itemsPerPage, "isEditable": isEditable},"headers": {},"cookies": {}}
            
            GetUsersUseridOutfitsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Avatar.roblox.com/v1/users/{userId}/outfits", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.OutfitModelExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridOutfitsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridOutfitsRecivedData)
            
            return ResponseSchema
        
        def PostAvatarAssetsAssetidRemove(self, assetId: int) -> AvatarApiSuccessResponse:
            """
            Removes the asset from the authenticated user's avatar.
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.PostAvatarAssetsAssetidRemove(assetId=integer)
        
            Args:
                assetId: int
            Returns:
                Avatar.AvatarApiSuccessResponse: Avatar.AvatarApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostAvatarAssetsAssetidRemoveRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Avatar.roblox.com/v1/avatar/assets/{assetId}/remove", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AvatarApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAvatarAssetsAssetidRemoveRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAvatarAssetsAssetidRemoveRecivedData)
            
            return ResponseSchema
        
        def PostAvatarAssetsAssetidWear(self, assetId: int) -> AvatarApiSuccessResponse:
            """
            Puts the asset on the authenticated user's avatar.

- Flagged as obsolete, does not support layered clothing meta params
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.PostAvatarAssetsAssetidWear(assetId=integer)
        
            Args:
                assetId: int
            Returns:
                Avatar.AvatarApiSuccessResponse: Avatar.AvatarApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostAvatarAssetsAssetidWearRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Avatar.roblox.com/v1/avatar/assets/{assetId}/wear", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AvatarApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAvatarAssetsAssetidWearRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAvatarAssetsAssetidWearRecivedData)
            
            return ResponseSchema
        
        def PostAvatarRedrawThumbnail(self) -> EmptyResponse:
            """
            Requests the authenticated user's thumbnail be redrawn
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.PostAvatarRedrawThumbnail()
        
            Args:
                
            Returns:
                Avatar.EmptyResponse: Avatar.EmptyResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostAvatarRedrawThumbnailRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Avatar.roblox.com/v1/avatar/redraw-thumbnail", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.EmptyResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAvatarRedrawThumbnailRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAvatarRedrawThumbnailRecivedData)
            
            return ResponseSchema
        
        def PostAvatarSetBodyColors(self, BodyColorsModel: BodyColorsModel) -> AvatarApiSuccessResponse:
            """
            Sets the authenticated user's body colors
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.PostAvatarSetBodyColors(BodyColorsModel=Avatar.BodyColorsModel())
        
            Args:
                BodyColorsModel: BodyColorsModel
            Returns:
                Avatar.AvatarApiSuccessResponse: Avatar.AvatarApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'BodyColorsModel': 'json'}
            Arguments = inspect.signature(self.PostAvatarSetBodyColors)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostAvatarSetBodyColorsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Avatar.roblox.com/v1/avatar/set-body-colors", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AvatarApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAvatarSetBodyColorsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAvatarSetBodyColorsRecivedData)
            
            return ResponseSchema
        
        def PostAvatarSetPlayerAvatarType(self, PlayerAvatarTypeModel: PlayerAvatarTypeModel) -> AvatarApiSuccessResponse:
            """
            Sets the authenticated user's player avatar type (e.g. R6 or R15).
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.PostAvatarSetPlayerAvatarType(PlayerAvatarTypeModel=Avatar.PlayerAvatarTypeModel())
        
            Args:
                PlayerAvatarTypeModel: PlayerAvatarTypeModel
            Returns:
                Avatar.AvatarApiSuccessResponse: Avatar.AvatarApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PlayerAvatarTypeModel': 'json'}
            Arguments = inspect.signature(self.PostAvatarSetPlayerAvatarType)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostAvatarSetPlayerAvatarTypeRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Avatar.roblox.com/v1/avatar/set-player-avatar-type", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AvatarApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAvatarSetPlayerAvatarTypeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAvatarSetPlayerAvatarTypeRecivedData)
            
            return ResponseSchema
        
        def PostAvatarSetScales(self, ScaleModel: ScaleModel) -> AvatarApiSuccessResponse:
            """
            Sets the authenticated user's scales
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.PostAvatarSetScales(ScaleModel=Avatar.ScaleModel())
        
            Args:
                ScaleModel: ScaleModel
            Returns:
                Avatar.AvatarApiSuccessResponse: Avatar.AvatarApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'ScaleModel': 'json'}
            Arguments = inspect.signature(self.PostAvatarSetScales)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostAvatarSetScalesRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Avatar.roblox.com/v1/avatar/set-scales", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AvatarApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAvatarSetScalesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAvatarSetScalesRecivedData)
            
            return ResponseSchema
        
        def PostAvatarSetWearingAssets(self, AssetIdListModel: AssetIdListModel) -> WearResponseModel:
            """
            Sets the avatar's current assets to the list

- Flagged as obsolete, does not support layered clothing meta params
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.PostAvatarSetWearingAssets(AssetIdListModel=Avatar.AssetIdListModel())
        
            Args:
                AssetIdListModel: AssetIdListModel
            Returns:
                Avatar.WearResponseModel: Avatar.WearResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'AssetIdListModel': 'json'}
            Arguments = inspect.signature(self.PostAvatarSetWearingAssets)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostAvatarSetWearingAssetsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Avatar.roblox.com/v1/avatar/set-wearing-assets", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.WearResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostAvatarSetWearingAssetsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAvatarSetWearingAssetsRecivedData)
            
            return ResponseSchema
        
        def PostOutfitsUseroutfitidDelete(self, userOutfitId: int) -> AvatarApiSuccessResponse:
            """
            Deletes the outfit
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.PostOutfitsUseroutfitidDelete(userOutfitId=integer)
        
            Args:
                userOutfitId: int
            Returns:
                Avatar.AvatarApiSuccessResponse: Avatar.AvatarApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostOutfitsUseroutfitidDeleteRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Avatar.roblox.com/v1/outfits/{userOutfitId}/delete", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AvatarApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostOutfitsUseroutfitidDeleteRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostOutfitsUseroutfitidDeleteRecivedData)
            
            return ResponseSchema
        
        def PostOutfitsUseroutfitidUpdate(self, userOutfitId: int, OutfitUpdateModelV1: OutfitUpdateModelV1) -> AvatarApiSuccessResponse:
            """
            Updates the contents of the outfit. Deprecated. There are no calls to this API
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.PostOutfitsUseroutfitidUpdate(userOutfitId=integer, OutfitUpdateModelV1=Avatar.OutfitUpdateModelV1())
        
            Args:
                userOutfitId: int
            OutfitUpdateModelV1: OutfitUpdateModelV1
            Returns:
                Avatar.AvatarApiSuccessResponse: Avatar.AvatarApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'OutfitUpdateModelV1': 'json'}
            Arguments = inspect.signature(self.PostOutfitsUseroutfitidUpdate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostOutfitsUseroutfitidUpdateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Avatar.roblox.com/v1/outfits/{userOutfitId}/update", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AvatarApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostOutfitsUseroutfitidUpdateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostOutfitsUseroutfitidUpdateRecivedData)
            
            return ResponseSchema
        
        def PostOutfitsCreate(self, OutfitUpdateModelV1: OutfitUpdateModelV1) -> AvatarApiSuccessResponse:
            """
            Creates a new outfit.
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.PostOutfitsCreate(OutfitUpdateModelV1=Avatar.OutfitUpdateModelV1())
        
            Args:
                OutfitUpdateModelV1: OutfitUpdateModelV1
            Returns:
                Avatar.AvatarApiSuccessResponse: Avatar.AvatarApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'OutfitUpdateModelV1': 'json'}
            Arguments = inspect.signature(self.PostOutfitsCreate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostOutfitsCreateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Avatar.roblox.com/v1/outfits/create", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.AvatarApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostOutfitsCreateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostOutfitsCreateRecivedData)
            
            return ResponseSchema
        
        def PatchOutfitsUseroutfitid(self, userOutfitId: int, OutfitUpdateModelV1: OutfitUpdateModelV1) -> OutfitModel:
            """
            Updates the contents of an outfit. Deprecated. There are no calls to this API
            
            Usage:
                import Avatar
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AvatarApi = Avatar.AvatarApi(RobloxClient=RobloxClient)
                Response = AvatarApi.PatchOutfitsUseroutfitid(userOutfitId=integer, OutfitUpdateModelV1=Avatar.OutfitUpdateModelV1())
        
            Args:
                userOutfitId: int
            OutfitUpdateModelV1: OutfitUpdateModelV1
            Returns:
                Avatar.OutfitModel: Avatar.OutfitModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'OutfitUpdateModelV1': 'json'}
            Arguments = inspect.signature(self.PatchOutfitsUseroutfitid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchOutfitsUseroutfitidRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Avatar.roblox.com/v1/outfits/{userOutfitId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Avatar.OutfitModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchOutfitsUseroutfitidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchOutfitsUseroutfitidRecivedData)
            
            return ResponseSchema
        
    class Auth:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class AccountPinRequest:
            def __init__(ClassObject, pin: str = None, reauthenticationToken: str = None):
                ClassObject.pin = pin
                ClassObject.reauthenticationToken = reauthenticationToken
                ClassObject.response: requests.Response = None


        class AccountPinResponse:
            def __init__(ClassObject, unlockedUntil: float = None):
                ClassObject.unlockedUntil = unlockedUntil
                ClassObject.response: requests.Response = None


        class AccountPinStatusResponse:
            def __init__(ClassObject, isEnabled: bool = None, unlockedUntil: float = None):
                ClassObject.isEnabled = isEnabled
                ClassObject.unlockedUntil = unlockedUntil
                ClassObject.response: requests.Response = None


        class AuthMetaDataResponse:
            def __init__(ClassObject, cookieLawNoticeTimeout: int = None):
                ClassObject.cookieLawNoticeTimeout = cookieLawNoticeTimeout
                ClassObject.response: requests.Response = None


        class EmailValidationResponse:
            def __init__(ClassObject, isEmailValid: bool = None):
                ClassObject.isEmailValid = isEmailValid
                ClassObject.response: requests.Response = None


        class LoginMethodModel:
            def __init__(ClassObject, method: enum.Enum = None, priority: int = None):
                ClassObject.method = method
                ClassObject.priority = priority
                ClassObject.response: requests.Response = None


        class SecureAuthenticationIntentModel:
            def __init__(ClassObject, clientPublicKey: str = None, clientEpochTimestamp: int = None, saiSignature: str = None, serverNonce: str = None):
                ClassObject.clientPublicKey = clientPublicKey
                ClassObject.clientEpochTimestamp = clientEpochTimestamp
                ClassObject.saiSignature = saiSignature
                ClassObject.serverNonce = serverNonce
                ClassObject.response: requests.Response = None


        class LoginRequest:
            def __init__(ClassObject, ctype: enum.Enum = None, cvalue: str = None, password: str = None, userId: int = None, securityQuestionSessionId: str = None, securityQuestionRedemptionToken: str = None, secureAuthenticationIntent: "RobloxClient.Auth.SecureAuthenticationIntentModel" = None, accountBlob: str = None, captchaId: str = None, captchaToken: str = None, captchaProvider: str = None, challengeId: str = None):
                ClassObject.ctype = ctype
                ClassObject.cvalue = cvalue
                ClassObject.password = password
                ClassObject.userId = userId
                ClassObject.securityQuestionSessionId = securityQuestionSessionId
                ClassObject.securityQuestionRedemptionToken = securityQuestionRedemptionToken
                ClassObject.secureAuthenticationIntent = secureAuthenticationIntent
                ClassObject.accountBlob = accountBlob
                ClassObject.captchaId = captchaId
                ClassObject.captchaToken = captchaToken
                ClassObject.captchaProvider = captchaProvider
                ClassObject.challengeId = challengeId
                ClassObject.response: requests.Response = None


        class SkinnyUserResponse:
            def __init__(ClassObject, id: int = None, name: str = None, displayName: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class TwoStepVerificationSentResponse:
            def __init__(ClassObject, mediaType: enum.Enum = None, ticket: str = None):
                ClassObject.mediaType = mediaType
                ClassObject.ticket = ticket
                ClassObject.response: requests.Response = None


        class LoginResponse:
            def __init__(ClassObject, user: "RobloxClient.Auth.SkinnyUserResponse" = None, twoStepVerificationData: "RobloxClient.Auth.TwoStepVerificationSentResponse" = None, identityVerificationLoginTicket: str = None, isBanned: bool = None, accountBlob: str = None):
                ClassObject.user = user
                ClassObject.twoStepVerificationData = twoStepVerificationData
                ClassObject.identityVerificationLoginTicket = identityVerificationLoginTicket
                ClassObject.isBanned = isBanned
                ClassObject.accountBlob = accountBlob
                ClassObject.response: requests.Response = None


        class MetadataResponse:
            def __init__(ClassObject, isUpdateUsernameEnabled: bool = None, ftuxAvatarAssetMap: str = None, IsEmailUpsellAtLogoutEnabled: bool = None, ShouldFetchEmailUpsellIXPValuesAtLogout: bool = None, IsAccountRecoveryPromptEnabled: bool = None, IsContactMethodRequiredAtSignup: bool = None, IsUserAgreementsSignupIntegrationEnabled: bool = None, IsKoreaIdVerificationEnabled: bool = None, IsPasswordRequiredForUsernameChange: bool = None, IsPasskeyFeatureEnabled: bool = None, IsAltBrowserTracker: bool = None):
                ClassObject.isUpdateUsernameEnabled = isUpdateUsernameEnabled
                ClassObject.ftuxAvatarAssetMap = ftuxAvatarAssetMap
                ClassObject.IsEmailUpsellAtLogoutEnabled = IsEmailUpsellAtLogoutEnabled
                ClassObject.ShouldFetchEmailUpsellIXPValuesAtLogout = ShouldFetchEmailUpsellIXPValuesAtLogout
                ClassObject.IsAccountRecoveryPromptEnabled = IsAccountRecoveryPromptEnabled
                ClassObject.IsContactMethodRequiredAtSignup = IsContactMethodRequiredAtSignup
                ClassObject.IsUserAgreementsSignupIntegrationEnabled = IsUserAgreementsSignupIntegrationEnabled
                ClassObject.IsKoreaIdVerificationEnabled = IsKoreaIdVerificationEnabled
                ClassObject.IsPasswordRequiredForUsernameChange = IsPasswordRequiredForUsernameChange
                ClassObject.IsPasskeyFeatureEnabled = IsPasskeyFeatureEnabled
                ClassObject.IsAltBrowserTracker = IsAltBrowserTracker
                ClassObject.response: requests.Response = None


        class PasswordChangeModel:
            def __init__(ClassObject, currentPassword: str = None, newPassword: str = None, secureAuthenticationIntent: "RobloxClient.Auth.SecureAuthenticationIntentModel" = None):
                ClassObject.currentPassword = currentPassword
                ClassObject.newPassword = newPassword
                ClassObject.secureAuthenticationIntent = secureAuthenticationIntent
                ClassObject.response: requests.Response = None


        class PasswordValidationModel:
            def __init__(ClassObject, username: str = None, password: str = None):
                ClassObject.username = username
                ClassObject.password = password
                ClassObject.response: requests.Response = None


        class PasswordValidationResponse:
            def __init__(ClassObject, code: enum.Enum = None, message: str = None):
                ClassObject.code = code
                ClassObject.message = message
                ClassObject.response: requests.Response = None


        class ProviderInfoModel:
            def __init__(ClassObject, provider: str = None, identifier: str = None):
                ClassObject.provider = provider
                ClassObject.identifier = identifier
                ClassObject.response: requests.Response = None


        class RecommendedUsernameFromDisplayNameRequest:
            def __init__(ClassObject, displayName: str = None, birthday: str = None):
                ClassObject.displayName = displayName
                ClassObject.birthday = birthday
                ClassObject.response: requests.Response = None


        class RecommendedUsernameRequest:
            def __init__(ClassObject, username: str = None, birthday: str = None):
                ClassObject.username = username
                ClassObject.birthday = birthday
                ClassObject.response: requests.Response = None


        class RecommendedUsernameResponse:
            def __init__(ClassObject, didGenerateNewUsername: bool = None, suggestedUsernames: list[str] = None):
                ClassObject.didGenerateNewUsername = didGenerateNewUsername
                ClassObject.suggestedUsernames = suggestedUsernames
                ClassObject.response: requests.Response = None


        class RecoverUsernameRequest:
            def __init__(ClassObject, targetType: enum.Enum = None, target: str = None):
                ClassObject.targetType = targetType
                ClassObject.target = target
                ClassObject.response: requests.Response = None


        class RecoverUsernameResponse:
            def __init__(ClassObject, transmissionType: enum.Enum = None):
                ClassObject.transmissionType = transmissionType
                ClassObject.response: requests.Response = None


        class RecoveryMetadataResponse:
            def __init__(ClassObject, isOnPhone: bool = None, codeLength: int = None, isPhoneFeatureEnabledForUsername: bool = None, isPhoneFeatureEnabledForPassword: bool = None, isBedev2CaptchaEnabledForPasswordReset: bool = None, isUsernameRecoveryDeprecated: bool = None):
                ClassObject.isOnPhone = isOnPhone
                ClassObject.codeLength = codeLength
                ClassObject.isPhoneFeatureEnabledForUsername = isPhoneFeatureEnabledForUsername
                ClassObject.isPhoneFeatureEnabledForPassword = isPhoneFeatureEnabledForPassword
                ClassObject.isBedev2CaptchaEnabledForPasswordReset = isBedev2CaptchaEnabledForPasswordReset
                ClassObject.isUsernameRecoveryDeprecated = isUsernameRecoveryDeprecated
                ClassObject.response: requests.Response = None


        class ReferralDataModel:
            def __init__(ClassObject, acquisitionTime: str = None, acquisitionReferrer: str = None, medium: str = None, source: str = None, campaign: str = None, adGroup: str = None, keyword: str = None, matchType: str = None, sendInfo: bool = None, requestSessionId: str = None, offerId: str = None):
                ClassObject.acquisitionTime = acquisitionTime
                ClassObject.acquisitionReferrer = acquisitionReferrer
                ClassObject.medium = medium
                ClassObject.source = source
                ClassObject.campaign = campaign
                ClassObject.adGroup = adGroup
                ClassObject.keyword = keyword
                ClassObject.matchType = matchType
                ClassObject.sendInfo = sendInfo
                ClassObject.requestSessionId = requestSessionId
                ClassObject.offerId = offerId
                ClassObject.response: requests.Response = None


        class DeletePasskeysRequest:
            def __init__(ClassObject, credentialNicknames: list[str] = None):
                ClassObject.credentialNicknames = credentialNicknames
                ClassObject.response: requests.Response = None


        class ExternalAccessRequest:
            def __init__(ClassObject, authenticationProof: str = None, identityProviderPlatformType: enum.Enum = None, additionalInfoPayload: typing.Dict[str, any] = None):
                ClassObject.authenticationProof = authenticationProof
                ClassObject.identityProviderPlatformType = identityProviderPlatformType
                ClassObject.additionalInfoPayload = additionalInfoPayload
                ClassObject.response: requests.Response = None


        class ExternalLoginAndLinkRequest:
            def __init__(ClassObject, ctype: enum.Enum = None, cvalue: str = None, password: str = None, authenticationProof: str = None, IdentityProviderPlatformType: enum.Enum = None, additionalInfoPayload: typing.Dict[str, any] = None):
                ClassObject.ctype = ctype
                ClassObject.cvalue = cvalue
                ClassObject.password = password
                ClassObject.authenticationProof = authenticationProof
                ClassObject.IdentityProviderPlatformType = IdentityProviderPlatformType
                ClassObject.additionalInfoPayload = additionalInfoPayload
                ClassObject.response: requests.Response = None


        class ExternalLoginRequest:
            def __init__(ClassObject, authenticationProof: str = None, identityProvider: enum.Enum = None, additionalInfoPayload: typing.Dict[str, any] = None):
                ClassObject.authenticationProof = authenticationProof
                ClassObject.identityProvider = identityProvider
                ClassObject.additionalInfoPayload = additionalInfoPayload
                ClassObject.response: requests.Response = None


        class ExternalSignupRequest:
            def __init__(ClassObject, username: str = None, password: str = None, birthday: str = None, locale: str = None, authenticationProof: str = None, IdentityProviderPlatformType: enum.Enum = None, additionalInfoPayload: typing.Dict[str, any] = None):
                ClassObject.username = username
                ClassObject.password = password
                ClassObject.birthday = birthday
                ClassObject.locale = locale
                ClassObject.authenticationProof = authenticationProof
                ClassObject.IdentityProviderPlatformType = IdentityProviderPlatformType
                ClassObject.additionalInfoPayload = additionalInfoPayload
                ClassObject.response: requests.Response = None


        class ExternalUnlinkRequest:
            def __init__(ClassObject, IdentityProviderPlatformType: enum.Enum = None, additionalInfoPayload: typing.Dict[str, any] = None):
                ClassObject.IdentityProviderPlatformType = IdentityProviderPlatformType
                ClassObject.additionalInfoPayload = additionalInfoPayload
                ClassObject.response: requests.Response = None


        class FinishPasskeyRegistrationRequest:
            def __init__(ClassObject, sessionId: str = None, credentialNickname: str = None, attestationResponse: str = None):
                ClassObject.sessionId = sessionId
                ClassObject.credentialNickname = credentialNickname
                ClassObject.attestationResponse = attestationResponse
                ClassObject.response: requests.Response = None


        class IdentityVerificationLoginRequest:
            def __init__(ClassObject, loginTicket: str = None, resultToken: str = None):
                ClassObject.loginTicket = loginTicket
                ClassObject.resultToken = resultToken
                ClassObject.response: requests.Response = None


        class InitializeLoginRequest:
            def __init__(ClassObject, ctype: enum.Enum = None, cvalue: str = None, captchaId: str = None, captchaToken: str = None, captchaProvider: str = None, challengeId: str = None):
                ClassObject.ctype = ctype
                ClassObject.cvalue = cvalue
                ClassObject.captchaId = captchaId
                ClassObject.captchaToken = captchaToken
                ClassObject.captchaProvider = captchaProvider
                ClassObject.challengeId = challengeId
                ClassObject.response: requests.Response = None


        class ListPasskeysRequest:
            def __init__(ClassObject, all: bool = None):
                ClassObject.all = all
                ClassObject.response: requests.Response = None


        class LogoutFromAllSessionsAndReauthenticateRequest:
            def __init__(ClassObject, SecureAuthenticationIntent: "RobloxClient.Auth.SecureAuthenticationIntentModel" = None):
                ClassObject.SecureAuthenticationIntent = SecureAuthenticationIntent
                ClassObject.response: requests.Response = None


        class OtpSessionModel:
            def __init__(ClassObject, otpSessionToken: str = None, otpContactType: enum.Enum = None):
                ClassObject.otpSessionToken = otpSessionToken
                ClassObject.otpContactType = otpContactType
                ClassObject.response: requests.Response = None


        class StartAuthenticationByUserRequest:
            def __init__(ClassObject, ctype: enum.Enum = None, cvalue: str = None):
                ClassObject.ctype = ctype
                ClassObject.cvalue = cvalue
                ClassObject.response: requests.Response = None


        class ExternalIdentityAccessResponse:
            def __init__(ClassObject, placeId: int = None, isolationContext: str = None, launchData: str = None):
                ClassObject.placeId = placeId
                ClassObject.isolationContext = isolationContext
                ClassObject.launchData = launchData
                ClassObject.response: requests.Response = None


        class GetClientAssertionResponse:
            def __init__(ClassObject, clientAssertion: str = None):
                ClassObject.clientAssertion = clientAssertion
                ClassObject.response: requests.Response = None


        class InitializeLoginResponse:
            def __init__(ClassObject, loginMethods: list["RobloxClient.Auth.LoginMethodModel"] = None):
                ClassObject.loginMethods = loginMethods
                ClassObject.response: requests.Response = None


        class PasskeyCredential:
            def __init__(ClassObject, nickname: str = None):
                ClassObject.nickname = nickname
                ClassObject.response: requests.Response = None


        class ListPasskeyCredentialResponse:
            def __init__(ClassObject, credentials: list["RobloxClient.Auth.PasskeyCredential"] = None):
                ClassObject.credentials = credentials
                ClassObject.response: requests.Response = None


        class StartAuthenticationByUserResponse:
            def __init__(ClassObject, authenticationOptions: str = None, sessionId: str = None):
                ClassObject.authenticationOptions = authenticationOptions
                ClassObject.sessionId = sessionId
                ClassObject.response: requests.Response = None


        class StartAuthenticationResponse:
            def __init__(ClassObject, authenticationOptions: str = None, sessionId: str = None):
                ClassObject.authenticationOptions = authenticationOptions
                ClassObject.sessionId = sessionId
                ClassObject.response: requests.Response = None


        class StartPasskeyRegistrationResponse:
            def __init__(ClassObject, creationOptions: str = None, sessionId: str = None):
                ClassObject.creationOptions = creationOptions
                ClassObject.sessionId = sessionId
                ClassObject.response: requests.Response = None


        class RevertAccountInfoResponse:
            def __init__(ClassObject, isTwoStepVerificationEnabled: bool = None, isEmailVerified: bool = None, isEmailChanged: bool = None, isPhoneVerified: bool = None, userId: int = None, username: str = None, ticket: str = None):
                ClassObject.isTwoStepVerificationEnabled = isTwoStepVerificationEnabled
                ClassObject.isEmailVerified = isEmailVerified
                ClassObject.isEmailChanged = isEmailChanged
                ClassObject.isPhoneVerified = isPhoneVerified
                ClassObject.userId = userId
                ClassObject.username = username
                ClassObject.ticket = ticket
                ClassObject.response: requests.Response = None


        class RevertAccountSubmitRequest:
            def __init__(ClassObject, UserId: int = None, NewPassword: str = None, NewPasswordRepeated: str = None, Ticket: str = None, TwoStepVerificationChallengeId: str = None, TwoStepVerificationToken: str = None):
                ClassObject.UserId = UserId
                ClassObject.NewPassword = NewPassword
                ClassObject.NewPasswordRepeated = NewPasswordRepeated
                ClassObject.Ticket = Ticket
                ClassObject.TwoStepVerificationChallengeId = TwoStepVerificationChallengeId
                ClassObject.TwoStepVerificationToken = TwoStepVerificationToken
                ClassObject.response: requests.Response = None


        class SignupRequest:
            def __init__(ClassObject, username: str = None, password: str = None, gender: enum.Enum = None, birthday: str = None, displayName: str = None, isTosAgreementBoxChecked: bool = None, email: str = None, locale: str = None, assetIds: list[int] = None, bodyColorId: int = None, bodyTypeScale: float = None, headScale: float = None, heightScale: float = None, widthScale: float = None, proportionScale: float = None, referralData: "RobloxClient.Auth.ReferralDataModel" = None, agreementIds: list[str] = None, identityVerificationResultToken: str = None, secureAuthenticationIntent: "RobloxClient.Auth.SecureAuthenticationIntentModel" = None, otpSession: "RobloxClient.Auth.OtpSessionModel" = None, dataToken: str = None, accountBlob: str = None, captchaId: str = None, captchaToken: str = None, captchaProvider: str = None, challengeId: str = None):
                ClassObject.username = username
                ClassObject.password = password
                ClassObject.gender = gender
                ClassObject.birthday = birthday
                ClassObject.displayName = displayName
                ClassObject.isTosAgreementBoxChecked = isTosAgreementBoxChecked
                ClassObject.email = email
                ClassObject.locale = locale
                ClassObject.assetIds = assetIds
                ClassObject.bodyColorId = bodyColorId
                ClassObject.bodyTypeScale = bodyTypeScale
                ClassObject.headScale = headScale
                ClassObject.heightScale = heightScale
                ClassObject.widthScale = widthScale
                ClassObject.proportionScale = proportionScale
                ClassObject.referralData = referralData
                ClassObject.agreementIds = agreementIds
                ClassObject.identityVerificationResultToken = identityVerificationResultToken
                ClassObject.secureAuthenticationIntent = secureAuthenticationIntent
                ClassObject.otpSession = otpSession
                ClassObject.dataToken = dataToken
                ClassObject.accountBlob = accountBlob
                ClassObject.captchaId = captchaId
                ClassObject.captchaToken = captchaToken
                ClassObject.captchaProvider = captchaProvider
                ClassObject.challengeId = challengeId
                ClassObject.response: requests.Response = None


        class SignupResponse:
            def __init__(ClassObject, userId: int = None, starterPlaceId: int = None, returnUrl: str = None, accountBlob: str = None):
                ClassObject.userId = userId
                ClassObject.starterPlaceId = starterPlaceId
                ClassObject.returnUrl = returnUrl
                ClassObject.accountBlob = accountBlob
                ClassObject.response: requests.Response = None


        class SocialAuthenticationDisconnectRequest:
            def __init__(ClassObject, Password: str = None):
                ClassObject.Password = Password
                ClassObject.response: requests.Response = None


        class SocialProvidersResponse:
            def __init__(ClassObject, providers: list["RobloxClient.Auth.ProviderInfoModel"] = None):
                ClassObject.providers = providers
                ClassObject.response: requests.Response = None


        class TwoStepVerificationMetadataResponse:
            def __init__(ClassObject, codeLength: int = None, loadingImageUrl: str = None, supportUrl: str = None):
                ClassObject.codeLength = codeLength
                ClassObject.loadingImageUrl = loadingImageUrl
                ClassObject.supportUrl = supportUrl
                ClassObject.response: requests.Response = None


        class TwoStepVerificationTicketRequest:
            def __init__(ClassObject, username: str = None, ticket: str = None, actionType: enum.Enum = None):
                ClassObject.username = username
                ClassObject.ticket = ticket
                ClassObject.actionType = actionType
                ClassObject.response: requests.Response = None


        class TwoStepVerificationVerifyRequest:
            def __init__(ClassObject, username: str = None, ticket: str = None, code: str = None, rememberDevice: bool = None, actionType: enum.Enum = None):
                ClassObject.username = username
                ClassObject.ticket = ticket
                ClassObject.code = code
                ClassObject.rememberDevice = rememberDevice
                ClassObject.actionType = actionType
                ClassObject.response: requests.Response = None


        class UsernameChangeRequest:
            def __init__(ClassObject, username: str = None, password: str = None):
                ClassObject.username = username
                ClassObject.password = password
                ClassObject.response: requests.Response = None


        class UsernameValidationRequest:
            def __init__(ClassObject, username: str = None, birthday: str = None, context: enum.Enum = None):
                ClassObject.username = username
                ClassObject.birthday = birthday
                ClassObject.context = context
                ClassObject.response: requests.Response = None


        class UsernameValidationResponse:
            def __init__(ClassObject, code: enum.Enum = None, message: str = None):
                ClassObject.code = code
                ClassObject.message = message
                ClassObject.response: requests.Response = None


        class UsernamesResponse:
            def __init__(ClassObject, usernames: list[str] = None):
                ClassObject.usernames = usernames
                ClassObject.response: requests.Response = None


        class XboxUserModel:
            def __init__(ClassObject, Id: str = None, UserId: int = None, Username: str = None):
                ClassObject.Id = Id
                ClassObject.UserId = UserId
                ClassObject.Username = Username
                ClassObject.response: requests.Response = None


        class XboxCollectionsOfUserResponse:
            def __init__(ClassObject, Users: list["RobloxClient.Auth.XboxUserModel"] = None):
                ClassObject.Users = Users
                ClassObject.response: requests.Response = None


        class XboxConnectionModel:
            def __init__(ClassObject, hasConnectedXboxAccount: bool = None):
                ClassObject.hasConnectedXboxAccount = hasConnectedXboxAccount
                ClassObject.response: requests.Response = None


        class XboxLoginConsecutiveDaysResponse:
            def __init__(ClassObject, count: int = None):
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class XboxTranslateRequest:
            def __init__(ClassObject, ids: list[str] = None):
                ClassObject.ids = ids
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class ApiSuccessResponse:
            def __init__(ClassObject, success: bool = None):
                ClassObject.success = success
                ClassObject.response: requests.Response = None



        
        def DeleteAccountPin(self, AccountPinRequest: AccountPinRequest) -> ApiSuccessResponse:
            """
            Request for deletes the account pin from the account.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.DeleteAccountPin(AccountPinRequest=Auth.AccountPinRequest())
        
            Args:
                AccountPinRequest: AccountPinRequest
            Returns:
                Auth.ApiSuccessResponse: Auth.ApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'AccountPinRequest': 'json'}
            Arguments = inspect.signature(self.DeleteAccountPin)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            DeleteAccountPinRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://Auth.roblox.com/v1/account/pin", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteAccountPinRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteAccountPinRecivedData)
            
            return ResponseSchema
        
        def GetAccountPin(self) -> AccountPinStatusResponse:
            """
            Gets the account pin status. If the account pin is valid, this returns the time in seconds until when the account pin is unlocked.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetAccountPin()
        
            Args:
                
            Returns:
                Auth.AccountPinStatusResponse: Auth.AccountPinStatusResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAccountPinRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/account/pin", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.AccountPinStatusResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAccountPinRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAccountPinRecivedData)
            
            return ResponseSchema
        
        def PatchAccountPin(self, AccountPinRequest: AccountPinRequest) -> ApiSuccessResponse:
            """
            Request made to update the account pin on the account.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PatchAccountPin(AccountPinRequest=Auth.AccountPinRequest())
        
            Args:
                AccountPinRequest: AccountPinRequest
            Returns:
                Auth.ApiSuccessResponse: Auth.ApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'AccountPinRequest': 'json'}
            Arguments = inspect.signature(self.PatchAccountPin)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchAccountPinRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://Auth.roblox.com/v1/account/pin", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PatchAccountPinRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchAccountPinRecivedData)
            
            return ResponseSchema
        
        def PostAccountPin(self, AccountPinRequest: AccountPinRequest) -> ApiSuccessResponse:
            """
            Reuqest to create the account pin.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostAccountPin(AccountPinRequest=Auth.AccountPinRequest())
        
            Args:
                AccountPinRequest: AccountPinRequest
            Returns:
                Auth.ApiSuccessResponse: Auth.ApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'AccountPinRequest': 'json'}
            Arguments = inspect.signature(self.PostAccountPin)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostAccountPinRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/account/pin", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAccountPinRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAccountPinRecivedData)
            
            return ResponseSchema
        
        def GetAuthMetadata(self) -> AuthMetaDataResponse:
            """
            Gets Auth meta data
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetAuthMetadata()
        
            Args:
                
            Returns:
                Auth.AuthMetaDataResponse: Auth.AuthMetaDataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAuthMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/auth/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.AuthMetaDataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAuthMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAuthMetadataRecivedData)
            
            return ResponseSchema
        
        def GetClientAssertion(self) -> GetClientAssertionResponse:
            """
            Creates a client assertion to be used when generating an auth ticket.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetClientAssertion()
        
            Args:
                
            Returns:
                Auth.GetClientAssertionResponse: Auth.GetClientAssertionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetClientAssertionRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/client-assertion", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.GetClientAssertionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetClientAssertionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetClientAssertionRecivedData)
            
            return ResponseSchema
        
        def GetMetadata(self) -> MetadataResponse:
            """
            Get the metadata
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetMetadata()
        
            Args:
                
            Returns:
                Auth.MetadataResponse: Auth.MetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.MetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetMetadataRecivedData)
            
            return ResponseSchema
        
        def GetPasswordsValidate(self, Username: str, Password: str) -> PasswordValidationResponse:
            """
            Endpoint for checking if a password is valid.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetPasswordsValidate(Username=string, Password=string)
        
            Args:
                Username: str
            Password: str
            Returns:
                Auth.PasswordValidationResponse: Auth.PasswordValidationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"Username": Username, "Password": Password},"headers": {},"cookies": {}}
            
            GetPasswordsValidateRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/passwords/validate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.PasswordValidationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetPasswordsValidateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPasswordsValidateRecivedData)
            
            return ResponseSchema
        
        def PostPasswordsValidate(self, PasswordValidationModel: PasswordValidationModel) -> PasswordValidationResponse:
            """
            Endpoint for checking if a password is valid.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostPasswordsValidate(PasswordValidationModel=Auth.PasswordValidationModel())
        
            Args:
                PasswordValidationModel: PasswordValidationModel
            Returns:
                Auth.PasswordValidationResponse: Auth.PasswordValidationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PasswordValidationModel': 'json'}
            Arguments = inspect.signature(self.PostPasswordsValidate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPasswordsValidateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/passwords/validate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.PasswordValidationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostPasswordsValidateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPasswordsValidateRecivedData)
            
            return ResponseSchema
        
        def GetRecoveryMetadata(self) -> RecoveryMetadataResponse:
            """
            Get metadata for forgot endpoints
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetRecoveryMetadata()
        
            Args:
                
            Returns:
                Auth.RecoveryMetadataResponse: Auth.RecoveryMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetRecoveryMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/recovery/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.RecoveryMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetRecoveryMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetRecoveryMetadataRecivedData)
            
            return ResponseSchema
        
        def GetRevertAccount(self, ticket: str) -> RevertAccountInfoResponse:
            """
            Get Revert Account ticket info
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetRevertAccount(ticket=string)
        
            Args:
                ticket: str
            Returns:
                Auth.RevertAccountInfoResponse: Auth.RevertAccountInfoResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"ticket": ticket},"headers": {},"cookies": {}}
            
            GetRevertAccountRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/revert/account", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.RevertAccountInfoResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetRevertAccountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetRevertAccountRecivedData)
            
            return ResponseSchema
        
        def PostRevertAccount(self, RevertAccountSubmitRequest: RevertAccountSubmitRequest) -> LoginResponse:
            """
            Submit Revert Account Request
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostRevertAccount(RevertAccountSubmitRequest=Auth.RevertAccountSubmitRequest())
        
            Args:
                RevertAccountSubmitRequest: RevertAccountSubmitRequest
            Returns:
                Auth.LoginResponse: Auth.LoginResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RevertAccountSubmitRequest': 'json'}
            Arguments = inspect.signature(self.PostRevertAccount)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostRevertAccountRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/revert/account", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.LoginResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostRevertAccountRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostRevertAccountRecivedData)
            
            return ResponseSchema
        
        def GetSocialConnectedProviders(self) -> SocialProvidersResponse:
            """
            Get social network user information if the given social auth method is connected to current user.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetSocialConnectedProviders()
        
            Args:
                
            Returns:
                Auth.SocialProvidersResponse: Auth.SocialProvidersResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetSocialConnectedProvidersRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/social/connected-providers", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.SocialProvidersResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetSocialConnectedProvidersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetSocialConnectedProvidersRecivedData)
            
            return ResponseSchema
        
        def GetTwostepverificationMetadata(self) -> TwoStepVerificationMetadataResponse:
            """
            Get metadata for two step verification
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetTwostepverificationMetadata()
        
            Args:
                
            Returns:
                Auth.TwoStepVerificationMetadataResponse: Auth.TwoStepVerificationMetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetTwostepverificationMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/twostepverification/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.TwoStepVerificationMetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetTwostepverificationMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetTwostepverificationMetadataRecivedData)
            
            return ResponseSchema
        
        def GetUsernames(self, username: str) -> UsernamesResponse:
            """
            Gets a list of existing usernames on Roblox based on the query parameters
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetUsernames(username=string)
        
            Args:
                username: str
            Returns:
                Auth.UsernamesResponse: Auth.UsernamesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"username": username},"headers": {},"cookies": {}}
            
            GetUsernamesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/usernames", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.UsernamesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsernamesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsernamesRecivedData)
            
            return ResponseSchema
        
        def GetUsernamesValidate(self, Username: str, Birthday: str, Context: int) -> UsernameValidationResponse:
            """
            Checks if a username is valid.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetUsernamesValidate(Username=string, Birthday=string, Context=integer)
        
            Args:
                Username: str
            Birthday: str
            Context: int
            Returns:
                Auth.UsernameValidationResponse: Auth.UsernameValidationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"Username": Username, "Birthday": Birthday, "Context": Context},"headers": {},"cookies": {}}
            
            GetUsernamesValidateRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/usernames/validate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.UsernameValidationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsernamesValidateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsernamesValidateRecivedData)
            
            return ResponseSchema
        
        def PostUsernamesValidate(self, UsernameValidationRequest: UsernameValidationRequest) -> UsernameValidationResponse:
            """
            Checks if a username is valid.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostUsernamesValidate(UsernameValidationRequest=Auth.UsernameValidationRequest())
        
            Args:
                UsernameValidationRequest: UsernameValidationRequest
            Returns:
                Auth.UsernameValidationResponse: Auth.UsernameValidationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UsernameValidationRequest': 'json'}
            Arguments = inspect.signature(self.PostUsernamesValidate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsernamesValidateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/usernames/validate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.UsernameValidationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsernamesValidateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsernamesValidateRecivedData)
            
            return ResponseSchema
        
        def GetValidatorsEmail(self, Email: str) -> EmailValidationResponse:
            """
            Tries to check if an email is valid
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetValidatorsEmail(Email=string)
        
            Args:
                Email: str
            Returns:
                Auth.EmailValidationResponse: Auth.EmailValidationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"Email": Email},"headers": {},"cookies": {}}
            
            GetValidatorsEmailRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/validators/email", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.EmailValidationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetValidatorsEmailRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetValidatorsEmailRecivedData)
            
            return ResponseSchema
        
        def GetValidatorsRecommendedusernamefromdisplayname(self, DisplayName: str, BirthDay: str) -> RecommendedUsernameResponse:
            """
            Validates the given display name, and if valid, will convert it to a valid username and return suggested username(s) if available.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetValidatorsRecommendedusernamefromdisplayname(DisplayName=string, BirthDay=string)
        
            Args:
                DisplayName: str
            BirthDay: str
            Returns:
                Auth.RecommendedUsernameResponse: Auth.RecommendedUsernameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"DisplayName": DisplayName, "BirthDay": BirthDay},"headers": {},"cookies": {}}
            
            GetValidatorsRecommendedusernamefromdisplaynameRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/validators/recommendedUsernameFromDisplayName", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.RecommendedUsernameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetValidatorsRecommendedusernamefromdisplaynameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetValidatorsRecommendedusernamefromdisplaynameRecivedData)
            
            return ResponseSchema
        
        def PostValidatorsRecommendedusernamefromdisplayname(self, RecommendedUsernameFromDisplayNameRequest: RecommendedUsernameFromDisplayNameRequest) -> RecommendedUsernameResponse:
            """
            Validates the given display name, and if valid, will convert it to a valid username and return suggested username(s) if available.

            

This is a POST request and explicitly does not receive the parameter values from the query
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostValidatorsRecommendedusernamefromdisplayname(RecommendedUsernameFromDisplayNameRequest=Auth.RecommendedUsernameFromDisplayNameRequest())
        
            Args:
                RecommendedUsernameFromDisplayNameRequest: RecommendedUsernameFromDisplayNameRequest
            Returns:
                Auth.RecommendedUsernameResponse: Auth.RecommendedUsernameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RecommendedUsernameFromDisplayNameRequest': 'json'}
            Arguments = inspect.signature(self.PostValidatorsRecommendedusernamefromdisplayname)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostValidatorsRecommendedusernamefromdisplaynameRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/validators/recommendedUsernameFromDisplayName", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.RecommendedUsernameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostValidatorsRecommendedusernamefromdisplaynameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostValidatorsRecommendedusernamefromdisplaynameRecivedData)
            
            return ResponseSchema
        
        def GetValidatorsUsername(self, Username: str, BirthDay: str) -> RecommendedUsernameResponse:
            """
            Tries to get a valid username if the current username is taken
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetValidatorsUsername(Username=string, BirthDay=string)
        
            Args:
                Username: str
            BirthDay: str
            Returns:
                Auth.RecommendedUsernameResponse: Auth.RecommendedUsernameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"Username": Username, "BirthDay": BirthDay},"headers": {},"cookies": {}}
            
            GetValidatorsUsernameRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/validators/username", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.RecommendedUsernameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetValidatorsUsernameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetValidatorsUsernameRecivedData)
            
            return ResponseSchema
        
        def PostValidatorsUsername(self, RecommendedUsernameRequest: RecommendedUsernameRequest) -> RecommendedUsernameResponse:
            """
            Tries to get a valid username if the current username is taken

This is a POST request and explicitly does not receive the parameter values from the query
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostValidatorsUsername(RecommendedUsernameRequest=Auth.RecommendedUsernameRequest())
        
            Args:
                RecommendedUsernameRequest: RecommendedUsernameRequest
            Returns:
                Auth.RecommendedUsernameResponse: Auth.RecommendedUsernameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RecommendedUsernameRequest': 'json'}
            Arguments = inspect.signature(self.PostValidatorsUsername)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostValidatorsUsernameRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/validators/username", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.RecommendedUsernameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostValidatorsUsernameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostValidatorsUsernameRecivedData)
            
            return ResponseSchema
        
        def GetXboxConnection(self) -> XboxConnectionModel:
            """
            Check if the current user has an Xbox connected.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetXboxConnection()
        
            Args:
                
            Returns:
                Auth.XboxConnectionModel: Auth.XboxConnectionModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetXboxConnectionRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/xbox/connection", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.XboxConnectionModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetXboxConnectionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetXboxConnectionRecivedData)
            
            return ResponseSchema
        
        def GetXboxGetLoginConsecutiveDays(self) -> XboxLoginConsecutiveDaysResponse:
            """
            Get the consecutive days the xbox user has been logged in.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.GetXboxGetLoginConsecutiveDays()
        
            Args:
                
            Returns:
                Auth.XboxLoginConsecutiveDaysResponse: Auth.XboxLoginConsecutiveDaysResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetXboxGetLoginConsecutiveDaysRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://Auth.roblox.com/v1/xbox/get-login-consecutive-days", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.XboxLoginConsecutiveDaysResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetXboxGetLoginConsecutiveDaysRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetXboxGetLoginConsecutiveDaysRecivedData)
            
            return ResponseSchema
        
        def PostAccountPinLock(self) -> ApiSuccessResponse:
            """
            Request to locks the account which has an account pin enabled.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostAccountPinLock()
        
            Args:
                
            Returns:
                Auth.ApiSuccessResponse: Auth.ApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostAccountPinLockRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/account/pin/lock", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAccountPinLockRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAccountPinLockRecivedData)
            
            return ResponseSchema
        
        def PostAccountPinUnlock(self, AccountPinRequest: AccountPinRequest) -> AccountPinResponse:
            """
            Requests to unlock the account pin.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostAccountPinUnlock(AccountPinRequest=Auth.AccountPinRequest())
        
            Args:
                AccountPinRequest: AccountPinRequest
            Returns:
                Auth.AccountPinResponse: Auth.AccountPinResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'AccountPinRequest': 'json'}
            Arguments = inspect.signature(self.PostAccountPinUnlock)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostAccountPinUnlockRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/account/pin/unlock", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.AccountPinResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAccountPinUnlockRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAccountPinUnlockRecivedData)
            
            return ResponseSchema
        
        def PostExternalAccess(self, ExternalAccessRequest: ExternalAccessRequest) -> ExternalIdentityAccessResponse:
            """
            Signs a user up for Roblox and links the account to the authenticated external provider ID.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostExternalAccess(ExternalAccessRequest=Auth.ExternalAccessRequest())
        
            Args:
                ExternalAccessRequest: ExternalAccessRequest
            Returns:
                Auth.ExternalIdentityAccessResponse: Auth.ExternalIdentityAccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'ExternalAccessRequest': 'json'}
            Arguments = inspect.signature(self.PostExternalAccess)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostExternalAccessRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/external/access", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ExternalIdentityAccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostExternalAccessRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostExternalAccessRecivedData)
            
            return ResponseSchema
        
        def PostExternalLogin(self, ExternalLoginRequest: ExternalLoginRequest) -> requests.Response:
            """
            Logs in a user to Roblox based on the user's authenticated external provider session
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostExternalLogin(ExternalLoginRequest=Auth.ExternalLoginRequest())
        
            Args:
                ExternalLoginRequest: ExternalLoginRequest
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'ExternalLoginRequest': 'json'}
            Arguments = inspect.signature(self.PostExternalLogin)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostExternalLoginRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/external/login", Dictinary=Dictinary)
            return PostExternalLoginRecivedData
        
        def PostExternalLoginandlink(self, ExternalLoginAndLinkRequest: ExternalLoginAndLinkRequest) -> LoginResponse:
            """
            Logins in a user to Roblox, then links the Roblox account to the external provider ID
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostExternalLoginandlink(ExternalLoginAndLinkRequest=Auth.ExternalLoginAndLinkRequest())
        
            Args:
                ExternalLoginAndLinkRequest: ExternalLoginAndLinkRequest
            Returns:
                Auth.LoginResponse: Auth.LoginResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'ExternalLoginAndLinkRequest': 'json'}
            Arguments = inspect.signature(self.PostExternalLoginandlink)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostExternalLoginandlinkRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/external/loginAndLink", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.LoginResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostExternalLoginandlinkRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostExternalLoginandlinkRecivedData)
            
            return ResponseSchema
        
        def PostExternalSignup(self, ExternalSignupRequest: ExternalSignupRequest) -> requests.Response:
            """
            Signs a user up for Roblox and links the account to the authenticated external provider ID
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostExternalSignup(ExternalSignupRequest=Auth.ExternalSignupRequest())
        
            Args:
                ExternalSignupRequest: ExternalSignupRequest
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'ExternalSignupRequest': 'json'}
            Arguments = inspect.signature(self.PostExternalSignup)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostExternalSignupRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/external/signup", Dictinary=Dictinary)
            return PostExternalSignupRecivedData
        
        def PostExternalUnlink(self, ExternalUnlinkRequest: ExternalUnlinkRequest) -> requests.Response:
            """
            Unlink the logged in Roblox account from the current external provider ID
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostExternalUnlink(ExternalUnlinkRequest=Auth.ExternalUnlinkRequest())
        
            Args:
                ExternalUnlinkRequest: ExternalUnlinkRequest
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'ExternalUnlinkRequest': 'json'}
            Arguments = inspect.signature(self.PostExternalUnlink)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostExternalUnlinkRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/external/unlink", Dictinary=Dictinary)
            return PostExternalUnlinkRecivedData
        
        def PostIdentityVerificationLogin(self, IdentityVerificationLoginRequest: IdentityVerificationLoginRequest) -> ApiEmptyResponseModel:
            """
            Endpoint for login with identity verification
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostIdentityVerificationLogin(IdentityVerificationLoginRequest=Auth.IdentityVerificationLoginRequest())
        
            Args:
                IdentityVerificationLoginRequest: IdentityVerificationLoginRequest
            Returns:
                Auth.ApiEmptyResponseModel: Auth.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'IdentityVerificationLoginRequest': 'json'}
            Arguments = inspect.signature(self.PostIdentityVerificationLogin)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostIdentityVerificationLoginRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/identity-verification/login", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostIdentityVerificationLoginRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostIdentityVerificationLoginRecivedData)
            
            return ResponseSchema
        
        def PostIdentityInitializeLogin(self, InitializeLoginRequest: InitializeLoginRequest) -> InitializeLoginResponse:
            """
            Initiates identifier-first login flow by returning a list of login methods for user(s).
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostIdentityInitializeLogin(InitializeLoginRequest=Auth.InitializeLoginRequest())
        
            Args:
                InitializeLoginRequest: InitializeLoginRequest
            Returns:
                Auth.InitializeLoginResponse: Auth.InitializeLoginResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'InitializeLoginRequest': 'json'}
            Arguments = inspect.signature(self.PostIdentityInitializeLogin)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostIdentityInitializeLoginRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/identity/initialize-login", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.InitializeLoginResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostIdentityInitializeLoginRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostIdentityInitializeLoginRecivedData)
            
            return ResponseSchema
        
        def PostLogin(self, LoginRequest: LoginRequest) -> LoginResponse:
            """
            Authenticates a user.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostLogin(LoginRequest=Auth.LoginRequest())
        
            Args:
                LoginRequest: LoginRequest
            Returns:
                Auth.LoginResponse: Auth.LoginResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'LoginRequest': 'json'}
            Arguments = inspect.signature(self.PostLogin)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostLoginRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/login", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.LoginResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostLoginRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostLoginRecivedData)
            
            return ResponseSchema
        
        def PostLogout(self) -> ApiEmptyResponseModel:
            """
            Destroys the current authentication session.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostLogout()
        
            Args:
                
            Returns:
                Auth.ApiEmptyResponseModel: Auth.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostLogoutRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/logout", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostLogoutRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostLogoutRecivedData)
            
            return ResponseSchema
        
        def PostLogoutfromallsessionsandreauthenticate(self, LogoutFromAllSessionsAndReauthenticateRequest: LogoutFromAllSessionsAndReauthenticateRequest) -> ApiEmptyResponseModel:
            """
            Logs out user from all other sessions.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostLogoutfromallsessionsandreauthenticate(LogoutFromAllSessionsAndReauthenticateRequest=Auth.LogoutFromAllSessionsAndReauthenticateRequest())
        
            Args:
                LogoutFromAllSessionsAndReauthenticateRequest: LogoutFromAllSessionsAndReauthenticateRequest
            Returns:
                Auth.ApiEmptyResponseModel: Auth.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'LogoutFromAllSessionsAndReauthenticateRequest': 'json'}
            Arguments = inspect.signature(self.PostLogoutfromallsessionsandreauthenticate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostLogoutfromallsessionsandreauthenticateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/logoutfromallsessionsandreauthenticate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostLogoutfromallsessionsandreauthenticateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostLogoutfromallsessionsandreauthenticateRecivedData)
            
            return ResponseSchema
        
        def PostPasskeyDeletecredentialbatch(self, DeletePasskeysRequest: DeletePasskeysRequest) -> ApiEmptyResponseModel:
            """
            Disables a batch of credentials for the specified user.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostPasskeyDeletecredentialbatch(DeletePasskeysRequest=Auth.DeletePasskeysRequest())
        
            Args:
                DeletePasskeysRequest: DeletePasskeysRequest
            Returns:
                Auth.ApiEmptyResponseModel: Auth.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'DeletePasskeysRequest': 'json'}
            Arguments = inspect.signature(self.PostPasskeyDeletecredentialbatch)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPasskeyDeletecredentialbatchRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/passkey/DeleteCredentialBatch", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPasskeyDeletecredentialbatchRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPasskeyDeletecredentialbatchRecivedData)
            
            return ResponseSchema
        
        def PostPasskeyFinishregistration(self, FinishPasskeyRegistrationRequest: FinishPasskeyRegistrationRequest) -> ApiEmptyResponseModel:
            """
            Complete Passkey registration by providing credential creation options.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostPasskeyFinishregistration(FinishPasskeyRegistrationRequest=Auth.FinishPasskeyRegistrationRequest())
        
            Args:
                FinishPasskeyRegistrationRequest: FinishPasskeyRegistrationRequest
            Returns:
                Auth.ApiEmptyResponseModel: Auth.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'FinishPasskeyRegistrationRequest': 'json'}
            Arguments = inspect.signature(self.PostPasskeyFinishregistration)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPasskeyFinishregistrationRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/passkey/FinishRegistration", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPasskeyFinishregistrationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPasskeyFinishregistrationRecivedData)
            
            return ResponseSchema
        
        def PostPasskeyListcredentials(self, ListPasskeysRequest: ListPasskeysRequest) -> ListPasskeyCredentialResponse:
            """
            List a user's registered passkeys.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostPasskeyListcredentials(ListPasskeysRequest=Auth.ListPasskeysRequest())
        
            Args:
                ListPasskeysRequest: ListPasskeysRequest
            Returns:
                Auth.ListPasskeyCredentialResponse: Auth.ListPasskeyCredentialResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'ListPasskeysRequest': 'json'}
            Arguments = inspect.signature(self.PostPasskeyListcredentials)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPasskeyListcredentialsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/passkey/ListCredentials", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ListPasskeyCredentialResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostPasskeyListcredentialsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPasskeyListcredentialsRecivedData)
            
            return ResponseSchema
        
        def PostPasskeyStartAuthenticationByUser(self, StartAuthenticationByUserRequest: StartAuthenticationByUserRequest) -> StartAuthenticationByUserResponse:
            """
            Initializes passkey authentication for the user(s) corresponding to the identifier provided.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostPasskeyStartAuthenticationByUser(StartAuthenticationByUserRequest=Auth.StartAuthenticationByUserRequest())
        
            Args:
                StartAuthenticationByUserRequest: StartAuthenticationByUserRequest
            Returns:
                Auth.StartAuthenticationByUserResponse: Auth.StartAuthenticationByUserResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'StartAuthenticationByUserRequest': 'json'}
            Arguments = inspect.signature(self.PostPasskeyStartAuthenticationByUser)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPasskeyStartAuthenticationByUserRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/passkey/start-authentication-by-user", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.StartAuthenticationByUserResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostPasskeyStartAuthenticationByUserRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPasskeyStartAuthenticationByUserRecivedData)
            
            return ResponseSchema
        
        def PostPasskeyStartauthentication(self) -> StartAuthenticationResponse:
            """
            Provides a challenge for the Passkey to authenticate.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostPasskeyStartauthentication()
        
            Args:
                
            Returns:
                Auth.StartAuthenticationResponse: Auth.StartAuthenticationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostPasskeyStartauthenticationRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/passkey/StartAuthentication", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.StartAuthenticationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostPasskeyStartauthenticationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPasskeyStartauthenticationRecivedData)
            
            return ResponseSchema
        
        def PostPasskeyStartregistration(self) -> StartPasskeyRegistrationResponse:
            """
            Initiates  Passkey registration by providing credential creation options.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostPasskeyStartregistration()
        
            Args:
                
            Returns:
                Auth.StartPasskeyRegistrationResponse: Auth.StartPasskeyRegistrationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostPasskeyStartregistrationRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/passkey/StartRegistration", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.StartPasskeyRegistrationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostPasskeyStartregistrationRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPasskeyStartregistrationRecivedData)
            
            return ResponseSchema
        
        def PostSignup(self, SignupRequest: SignupRequest) -> SignupResponse:
            """
            Endpoint for signing up a new user
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostSignup(SignupRequest=Auth.SignupRequest())
        
            Args:
                SignupRequest: SignupRequest
            Returns:
                Auth.SignupResponse: Auth.SignupResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SignupRequest': 'json'}
            Arguments = inspect.signature(self.PostSignup)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostSignupRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/signup", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.SignupResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostSignupRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostSignupRecivedData)
            
            return ResponseSchema
        
        def PostSocialProviderDisconnect(self, provider: str, SocialAuthenticationDisconnectRequest: SocialAuthenticationDisconnectRequest) -> ApiEmptyResponseModel:
            """
            Removes the given social authentication method from current Roblox user if it is connected.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostSocialProviderDisconnect(provider=string, SocialAuthenticationDisconnectRequest=Auth.SocialAuthenticationDisconnectRequest())
        
            Args:
                provider: str
            SocialAuthenticationDisconnectRequest: SocialAuthenticationDisconnectRequest
            Returns:
                Auth.ApiEmptyResponseModel: Auth.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SocialAuthenticationDisconnectRequest': 'json'}
            Arguments = inspect.signature(self.PostSocialProviderDisconnect)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostSocialProviderDisconnectRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/social/{provider}/disconnect", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostSocialProviderDisconnectRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostSocialProviderDisconnectRecivedData)
            
            return ResponseSchema
        
        def PostTwostepverificationResend(self, TwoStepVerificationTicketRequest: TwoStepVerificationTicketRequest) -> TwoStepVerificationSentResponse:
            """
            Resends a two step verification code.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostTwostepverificationResend(TwoStepVerificationTicketRequest=Auth.TwoStepVerificationTicketRequest())
        
            Args:
                TwoStepVerificationTicketRequest: TwoStepVerificationTicketRequest
            Returns:
                Auth.TwoStepVerificationSentResponse: Auth.TwoStepVerificationSentResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'TwoStepVerificationTicketRequest': 'json'}
            Arguments = inspect.signature(self.PostTwostepverificationResend)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostTwostepverificationResendRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/twostepverification/resend", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.TwoStepVerificationSentResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostTwostepverificationResendRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTwostepverificationResendRecivedData)
            
            return ResponseSchema
        
        def PostTwostepverificationVerify(self, TwoStepVerificationVerifyRequest: TwoStepVerificationVerifyRequest) -> ApiEmptyResponseModel:
            """
            Verifies a two step verification code.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostTwostepverificationVerify(TwoStepVerificationVerifyRequest=Auth.TwoStepVerificationVerifyRequest())
        
            Args:
                TwoStepVerificationVerifyRequest: TwoStepVerificationVerifyRequest
            Returns:
                Auth.ApiEmptyResponseModel: Auth.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'TwoStepVerificationVerifyRequest': 'json'}
            Arguments = inspect.signature(self.PostTwostepverificationVerify)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostTwostepverificationVerifyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/twostepverification/verify", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostTwostepverificationVerifyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTwostepverificationVerifyRecivedData)
            
            return ResponseSchema
        
        def PostUserPasswordsChange(self, PasswordChangeModel: PasswordChangeModel) -> ApiEmptyResponseModel:
            """
            Changes the password for the authenticated user.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostUserPasswordsChange(PasswordChangeModel=Auth.PasswordChangeModel())
        
            Args:
                PasswordChangeModel: PasswordChangeModel
            Returns:
                Auth.ApiEmptyResponseModel: Auth.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PasswordChangeModel': 'json'}
            Arguments = inspect.signature(self.PostUserPasswordsChange)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUserPasswordsChangeRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/user/passwords/change", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUserPasswordsChangeRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUserPasswordsChangeRecivedData)
            
            return ResponseSchema
        
        def PostUsername(self, UsernameChangeRequest: UsernameChangeRequest) -> ApiEmptyResponseModel:
            """
            Change the user's username
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostUsername(UsernameChangeRequest=Auth.UsernameChangeRequest())
        
            Args:
                UsernameChangeRequest: UsernameChangeRequest
            Returns:
                Auth.ApiEmptyResponseModel: Auth.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UsernameChangeRequest': 'json'}
            Arguments = inspect.signature(self.PostUsername)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsernameRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/username", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsernameRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsernameRecivedData)
            
            return ResponseSchema
        
        def PostUsernamesRecover(self, RecoverUsernameRequest: RecoverUsernameRequest) -> RecoverUsernameResponse:
            """
            Sends an email of all accounts belonging to an email
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostUsernamesRecover(RecoverUsernameRequest=Auth.RecoverUsernameRequest())
        
            Args:
                RecoverUsernameRequest: RecoverUsernameRequest
            Returns:
                Auth.RecoverUsernameResponse: Auth.RecoverUsernameResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'RecoverUsernameRequest': 'json'}
            Arguments = inspect.signature(self.PostUsernamesRecover)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostUsernamesRecoverRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/usernames/recover", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.RecoverUsernameResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsernamesRecoverRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsernamesRecoverRecivedData)
            
            return ResponseSchema
        
        def PostXboxDisconnect(self) -> ApiSuccessResponse:
            """
            Unlink the current ROBLOX account from the Xbox live account.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostXboxDisconnect()
        
            Args:
                
            Returns:
                Auth.ApiSuccessResponse: Auth.ApiSuccessResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostXboxDisconnectRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/xbox/disconnect", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.ApiSuccessResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostXboxDisconnectRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostXboxDisconnectRecivedData)
            
            return ResponseSchema
        
        def PostXboxTranslate(self, XboxTranslateRequest: XboxTranslateRequest) -> XboxCollectionsOfUserResponse:
            """
            Translate the xbox user to roblox user.
            
            Usage:
                import Auth
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AuthApi = Auth.AuthApi(RobloxClient=RobloxClient)
                Response = AuthApi.PostXboxTranslate(XboxTranslateRequest=Auth.XboxTranslateRequest())
        
            Args:
                XboxTranslateRequest: XboxTranslateRequest
            Returns:
                Auth.XboxCollectionsOfUserResponse: Auth.XboxCollectionsOfUserResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'XboxTranslateRequest': 'json'}
            Arguments = inspect.signature(self.PostXboxTranslate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostXboxTranslateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Auth.roblox.com/v1/xbox/translate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.Auth.XboxCollectionsOfUserResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostXboxTranslateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostXboxTranslateRecivedData)
            
            return ResponseSchema
        
    class AssetDelivery:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class AssetContentRepresentationSpecifier:
            def __init__(ClassObject, format: str = None, majorVersion: str = None, fidelity: str = None):
                ClassObject.format = format
                ClassObject.majorVersion = majorVersion
                ClassObject.fidelity = fidelity
                ClassObject.response: requests.Response = None


        class IAssetItemError:
            def __init__(ClassObject, Code: int = None, Message: str = None, CustomErrorCode: enum.Enum = None):
                ClassObject.Code = Code
                ClassObject.Message = Message
                ClassObject.CustomErrorCode = CustomErrorCode
                ClassObject.response: requests.Response = None


        class AssetResponseItemV1:
            def __init__(ClassObject, location: str = None, errors: list["RobloxClient.AssetDelivery.IAssetItemError"] = None, requestId: str = None, IsHashDynamic: bool = None, IsCopyrightProtected: bool = None, isArchived: bool = None, assetTypeId: int = None, contentRepresentationSpecifier: "RobloxClient.AssetDelivery.AssetContentRepresentationSpecifier" = None):
                ClassObject.location = location
                ClassObject.errors = errors
                ClassObject.requestId = requestId
                ClassObject.IsHashDynamic = IsHashDynamic
                ClassObject.IsCopyrightProtected = IsCopyrightProtected
                ClassObject.isArchived = isArchived
                ClassObject.assetTypeId = assetTypeId
                ClassObject.contentRepresentationSpecifier = contentRepresentationSpecifier
                ClassObject.response: requests.Response = None


        class BatchAssetRequestItem:
            def __init__(ClassObject, assetName: str = None, assetType: str = None, clientInsert: bool = None, placeId: int = None, requestId: str = None, scriptInsert: bool = None, serverPlaceId: int = None, universeId: int = None, accept: str = None, encoding: str = None, hash: str = None, userAssetId: int = None, assetId: int = None, version: int = None, assetVersionId: int = None, modulePlaceId: int = None, assetFormat: str = None, robloxassetFormat: str = None, contentRepresentationPriorityList: str = None, doNotFallbackToBaselineRepresentation: bool = None):
                ClassObject.assetName = assetName
                ClassObject.assetType = assetType
                ClassObject.clientInsert = clientInsert
                ClassObject.placeId = placeId
                ClassObject.requestId = requestId
                ClassObject.scriptInsert = scriptInsert
                ClassObject.serverPlaceId = serverPlaceId
                ClassObject.universeId = universeId
                ClassObject.accept = accept
                ClassObject.encoding = encoding
                ClassObject.hash = hash
                ClassObject.userAssetId = userAssetId
                ClassObject.assetId = assetId
                ClassObject.version = version
                ClassObject.assetVersionId = assetVersionId
                ClassObject.modulePlaceId = modulePlaceId
                ClassObject.assetFormat = assetFormat
                ClassObject.robloxassetFormat = robloxassetFormat
                ClassObject.contentRepresentationPriorityList = contentRepresentationPriorityList
                ClassObject.doNotFallbackToBaselineRepresentation = doNotFallbackToBaselineRepresentation
                ClassObject.response: requests.Response = None



        
        def GetAliasAlias(self, skipSigningScripts: bool, clientInsert: int, scriptinsert: int, modulePlaceId: int, serverplaceid: int, expectedAssetType: str, alias: str, Accept_Encoding: str, Roblox_Place_Id: int, AssetType: str, Accept: str, AssetFormat: str, Roblox_AssetFormat: str) -> AssetResponseItemV1:
            """
            Retrieves an asset by its alias (universeID/name)
            
            Usage:
                import AssetDelivery
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AssetDeliveryApi = AssetDelivery.AssetDeliveryApi(RobloxClient=RobloxClient)
                Response = AssetDeliveryApi.GetAliasAlias(skipSigningScripts=boolean, clientInsert=integer, scriptinsert=integer, modulePlaceId=integer, serverplaceid=integer, expectedAssetType=string, alias=string, Accept_Encoding=string, Roblox_Place_Id=integer, AssetType=string, Accept=string, AssetFormat=string, Roblox_AssetFormat=string)
        
            Args:
                skipSigningScripts: bool
            clientInsert: int
            scriptinsert: int
            modulePlaceId: int
            serverplaceid: int
            expectedAssetType: str
            alias: str
            Accept_Encoding: str
            Roblox_Place_Id: int
            AssetType: str
            Accept: str
            AssetFormat: str
            Roblox_AssetFormat: str
            Returns:
                AssetDelivery.AssetResponseItemV1: AssetDelivery.AssetResponseItemV1
            """
        
            Dictinary = {"json": {},"data": {},"params": {"skipSigningScripts": skipSigningScripts, "clientInsert": clientInsert, "scriptinsert": scriptinsert, "modulePlaceId": modulePlaceId, "serverplaceid": serverplaceid, "expectedAssetType": expectedAssetType},"headers": {"Accept_Encoding": Accept_Encoding, "Roblox_Place_Id": Roblox_Place_Id, "AssetType": AssetType, "Accept": Accept, "AssetFormat": AssetFormat, "Roblox_AssetFormat": Roblox_AssetFormat},"cookies": {}}
            
            GetAliasAliasRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AssetDelivery.roblox.com/v1/alias/{alias}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AssetDelivery.AssetResponseItemV1()
        
            ReturnedJson = None
            try: ReturnedJson = GetAliasAliasRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAliasAliasRecivedData)
            
            return ResponseSchema
        
        def GetAsset(self, id: int, userAssetId: int, assetVersionId: int, version: int, universeId: int, clientInsert: int, scriptinsert: int, modulePlaceId: int, serverplaceid: str, assetName: str, hash: str, marAssetHash: str, marCheckSum: str, expectedAssetType: str, skipSigningScripts: bool, permissionContext: str, doNotFallbackToBaselineRepresentation: bool, contentRepresentationPriorityList: str, Accept_Encoding: str, Roblox_Place_Id: int, AssetType: str, Accept: str, AssetFormat: str, Roblox_AssetFormat: str) -> requests.Response:
            """
            Unknown
            
            Usage:
                import AssetDelivery
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AssetDeliveryApi = AssetDelivery.AssetDeliveryApi(RobloxClient=RobloxClient)
                Response = AssetDeliveryApi.GetAsset(id=integer, userAssetId=integer, assetVersionId=integer, version=integer, universeId=integer, clientInsert=integer, scriptinsert=integer, modulePlaceId=integer, serverplaceid=string, assetName=string, hash=string, marAssetHash=string, marCheckSum=string, expectedAssetType=string, skipSigningScripts=boolean, permissionContext=string, doNotFallbackToBaselineRepresentation=boolean, contentRepresentationPriorityList=string, Accept_Encoding=string, Roblox_Place_Id=integer, AssetType=string, Accept=string, AssetFormat=string, Roblox_AssetFormat=string)
        
            Args:
                id: int
            userAssetId: int
            assetVersionId: int
            version: int
            universeId: int
            clientInsert: int
            scriptinsert: int
            modulePlaceId: int
            serverplaceid: str
            assetName: str
            hash: str
            marAssetHash: str
            marCheckSum: str
            expectedAssetType: str
            skipSigningScripts: bool
            permissionContext: str
            doNotFallbackToBaselineRepresentation: bool
            contentRepresentationPriorityList: str
            Accept_Encoding: str
            Roblox_Place_Id: int
            AssetType: str
            Accept: str
            AssetFormat: str
            Roblox_AssetFormat: str
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"id": id, "userAssetId": userAssetId, "assetVersionId": assetVersionId, "version": version, "universeId": universeId, "clientInsert": clientInsert, "scriptinsert": scriptinsert, "modulePlaceId": modulePlaceId, "serverplaceid": serverplaceid, "assetName": assetName, "hash": hash, "marAssetHash": marAssetHash, "marCheckSum": marCheckSum, "expectedAssetType": expectedAssetType, "skipSigningScripts": skipSigningScripts, "permissionContext": permissionContext, "doNotFallbackToBaselineRepresentation": doNotFallbackToBaselineRepresentation, "contentRepresentationPriorityList": contentRepresentationPriorityList},"headers": {"Accept_Encoding": Accept_Encoding, "Roblox_Place_Id": Roblox_Place_Id, "AssetType": AssetType, "Accept": Accept, "AssetFormat": AssetFormat, "Roblox_AssetFormat": Roblox_AssetFormat},"cookies": {}}
            
            GetAssetRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AssetDelivery.roblox.com/v1/asset", Dictinary=Dictinary)
            return GetAssetRecivedData
        
        def GetAssetidAssetid(self, skipSigningScripts: bool, clientInsert: int, scriptinsert: int, modulePlaceId: int, serverplaceid: int, expectedAssetType: str, doNotFallbackToBaselineRepresentation: bool, contentRepresentationPriorityList: str, assetId: int, Accept_Encoding: str, Roblox_Place_Id: int, AssetType: str, Accept: str, AssetFormat: str, Roblox_AssetFormat: str) -> AssetResponseItemV1:
            """
            Retrieves an asset by its ID
            
            Usage:
                import AssetDelivery
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AssetDeliveryApi = AssetDelivery.AssetDeliveryApi(RobloxClient=RobloxClient)
                Response = AssetDeliveryApi.GetAssetidAssetid(skipSigningScripts=boolean, clientInsert=integer, scriptinsert=integer, modulePlaceId=integer, serverplaceid=integer, expectedAssetType=string, doNotFallbackToBaselineRepresentation=boolean, contentRepresentationPriorityList=string, assetId=integer, Accept_Encoding=string, Roblox_Place_Id=integer, AssetType=string, Accept=string, AssetFormat=string, Roblox_AssetFormat=string)
        
            Args:
                skipSigningScripts: bool
            clientInsert: int
            scriptinsert: int
            modulePlaceId: int
            serverplaceid: int
            expectedAssetType: str
            doNotFallbackToBaselineRepresentation: bool
            contentRepresentationPriorityList: str
            assetId: int
            Accept_Encoding: str
            Roblox_Place_Id: int
            AssetType: str
            Accept: str
            AssetFormat: str
            Roblox_AssetFormat: str
            Returns:
                AssetDelivery.AssetResponseItemV1: AssetDelivery.AssetResponseItemV1
            """
        
            Dictinary = {"json": {},"data": {},"params": {"skipSigningScripts": skipSigningScripts, "clientInsert": clientInsert, "scriptinsert": scriptinsert, "modulePlaceId": modulePlaceId, "serverplaceid": serverplaceid, "expectedAssetType": expectedAssetType, "doNotFallbackToBaselineRepresentation": doNotFallbackToBaselineRepresentation, "contentRepresentationPriorityList": contentRepresentationPriorityList},"headers": {"Accept_Encoding": Accept_Encoding, "Roblox_Place_Id": Roblox_Place_Id, "AssetType": AssetType, "Accept": Accept, "AssetFormat": AssetFormat, "Roblox_AssetFormat": Roblox_AssetFormat},"cookies": {}}
            
            GetAssetidAssetidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AssetDelivery.roblox.com/v1/assetId/{assetId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AssetDelivery.AssetResponseItemV1()
        
            ReturnedJson = None
            try: ReturnedJson = GetAssetidAssetidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAssetidAssetidRecivedData)
            
            return ResponseSchema
        
        def GetAssetidAssetidVersionVersion(self, skipSigningScripts: bool, clientInsert: int, scriptinsert: int, modulePlaceId: int, serverplaceid: int, expectedAssetType: str, doNotFallbackToBaselineRepresentation: bool, contentRepresentationPriorityList: str, assetId: int, version: int, Accept_Encoding: str, Roblox_Place_Id: int, AssetType: str, Accept: str, AssetFormat: str, Roblox_AssetFormat: str) -> AssetResponseItemV1:
            """
            Retrieves an asset by its ID and its version.
            
            Usage:
                import AssetDelivery
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AssetDeliveryApi = AssetDelivery.AssetDeliveryApi(RobloxClient=RobloxClient)
                Response = AssetDeliveryApi.GetAssetidAssetidVersionVersion(skipSigningScripts=boolean, clientInsert=integer, scriptinsert=integer, modulePlaceId=integer, serverplaceid=integer, expectedAssetType=string, doNotFallbackToBaselineRepresentation=boolean, contentRepresentationPriorityList=string, assetId=integer, version=integer, Accept_Encoding=string, Roblox_Place_Id=integer, AssetType=string, Accept=string, AssetFormat=string, Roblox_AssetFormat=string)
        
            Args:
                skipSigningScripts: bool
            clientInsert: int
            scriptinsert: int
            modulePlaceId: int
            serverplaceid: int
            expectedAssetType: str
            doNotFallbackToBaselineRepresentation: bool
            contentRepresentationPriorityList: str
            assetId: int
            version: int
            Accept_Encoding: str
            Roblox_Place_Id: int
            AssetType: str
            Accept: str
            AssetFormat: str
            Roblox_AssetFormat: str
            Returns:
                AssetDelivery.AssetResponseItemV1: AssetDelivery.AssetResponseItemV1
            """
        
            Dictinary = {"json": {},"data": {},"params": {"skipSigningScripts": skipSigningScripts, "clientInsert": clientInsert, "scriptinsert": scriptinsert, "modulePlaceId": modulePlaceId, "serverplaceid": serverplaceid, "expectedAssetType": expectedAssetType, "doNotFallbackToBaselineRepresentation": doNotFallbackToBaselineRepresentation, "contentRepresentationPriorityList": contentRepresentationPriorityList},"headers": {"Accept_Encoding": Accept_Encoding, "Roblox_Place_Id": Roblox_Place_Id, "AssetType": AssetType, "Accept": Accept, "AssetFormat": AssetFormat, "Roblox_AssetFormat": Roblox_AssetFormat},"cookies": {}}
            
            GetAssetidAssetidVersionVersionRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AssetDelivery.roblox.com/v1/assetId/{assetId}/version/{version}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AssetDelivery.AssetResponseItemV1()
        
            ReturnedJson = None
            try: ReturnedJson = GetAssetidAssetidVersionVersionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAssetidAssetidVersionVersionRecivedData)
            
            return ResponseSchema
        
        def GetAssetversionidAssetversionid(self, skipSigningScripts: bool, clientInsert: int, scriptinsert: int, modulePlaceId: int, serverplaceid: int, expectedAssetType: str, assetVersionId: int, Accept_Encoding: str, Roblox_Place_Id: int, AssetType: str, Accept: str, AssetFormat: str, Roblox_AssetFormat: str) -> AssetResponseItemV1:
            """
            Unknown
            
            Usage:
                import AssetDelivery
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AssetDeliveryApi = AssetDelivery.AssetDeliveryApi(RobloxClient=RobloxClient)
                Response = AssetDeliveryApi.GetAssetversionidAssetversionid(skipSigningScripts=boolean, clientInsert=integer, scriptinsert=integer, modulePlaceId=integer, serverplaceid=integer, expectedAssetType=string, assetVersionId=integer, Accept_Encoding=string, Roblox_Place_Id=integer, AssetType=string, Accept=string, AssetFormat=string, Roblox_AssetFormat=string)
        
            Args:
                skipSigningScripts: bool
            clientInsert: int
            scriptinsert: int
            modulePlaceId: int
            serverplaceid: int
            expectedAssetType: str
            assetVersionId: int
            Accept_Encoding: str
            Roblox_Place_Id: int
            AssetType: str
            Accept: str
            AssetFormat: str
            Roblox_AssetFormat: str
            Returns:
                AssetDelivery.AssetResponseItemV1: AssetDelivery.AssetResponseItemV1
            """
        
            Dictinary = {"json": {},"data": {},"params": {"skipSigningScripts": skipSigningScripts, "clientInsert": clientInsert, "scriptinsert": scriptinsert, "modulePlaceId": modulePlaceId, "serverplaceid": serverplaceid, "expectedAssetType": expectedAssetType},"headers": {"Accept_Encoding": Accept_Encoding, "Roblox_Place_Id": Roblox_Place_Id, "AssetType": AssetType, "Accept": Accept, "AssetFormat": AssetFormat, "Roblox_AssetFormat": Roblox_AssetFormat},"cookies": {}}
            
            GetAssetversionidAssetversionidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AssetDelivery.roblox.com/v1/assetVersionId/{assetVersionId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AssetDelivery.AssetResponseItemV1()
        
            ReturnedJson = None
            try: ReturnedJson = GetAssetversionidAssetversionidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAssetversionidAssetversionidRecivedData)
            
            return ResponseSchema
        
        def GetMarassethashMarassethashMarchecksumMarchecksum(self, skipSigningScripts: bool, clientInsert: int, scriptinsert: int, modulePlaceId: int, serverplaceid: int, expectedAssetType: str, marAssetHash: str, marCheckSum: str, Accept_Encoding: str, Roblox_Place_Id: int, AssetType: str, Accept: str, AssetFormat: str, Roblox_AssetFormat: str) -> AssetResponseItemV1:
            """
            Retrieves an asset by its mar (moderation agnostic) hash and mar (moderation agnostic) checksum.
            
            Usage:
                import AssetDelivery
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AssetDeliveryApi = AssetDelivery.AssetDeliveryApi(RobloxClient=RobloxClient)
                Response = AssetDeliveryApi.GetMarassethashMarassethashMarchecksumMarchecksum(skipSigningScripts=boolean, clientInsert=integer, scriptinsert=integer, modulePlaceId=integer, serverplaceid=integer, expectedAssetType=string, marAssetHash=string, marCheckSum=string, Accept_Encoding=string, Roblox_Place_Id=integer, AssetType=string, Accept=string, AssetFormat=string, Roblox_AssetFormat=string)
        
            Args:
                skipSigningScripts: bool
            clientInsert: int
            scriptinsert: int
            modulePlaceId: int
            serverplaceid: int
            expectedAssetType: str
            marAssetHash: str
            marCheckSum: str
            Accept_Encoding: str
            Roblox_Place_Id: int
            AssetType: str
            Accept: str
            AssetFormat: str
            Roblox_AssetFormat: str
            Returns:
                AssetDelivery.AssetResponseItemV1: AssetDelivery.AssetResponseItemV1
            """
        
            Dictinary = {"json": {},"data": {},"params": {"skipSigningScripts": skipSigningScripts, "clientInsert": clientInsert, "scriptinsert": scriptinsert, "modulePlaceId": modulePlaceId, "serverplaceid": serverplaceid, "expectedAssetType": expectedAssetType},"headers": {"Accept_Encoding": Accept_Encoding, "Roblox_Place_Id": Roblox_Place_Id, "AssetType": AssetType, "Accept": Accept, "AssetFormat": AssetFormat, "Roblox_AssetFormat": Roblox_AssetFormat},"cookies": {}}
            
            GetMarassethashMarassethashMarchecksumMarchecksumRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AssetDelivery.roblox.com/v1/marAssetHash/{marAssetHash}/marCheckSum/{marCheckSum}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AssetDelivery.AssetResponseItemV1()
        
            ReturnedJson = None
            try: ReturnedJson = GetMarassethashMarassethashMarchecksumMarchecksumRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetMarassethashMarassethashMarchecksumMarchecksumRecivedData)
            
            return ResponseSchema
        
        def GetUserassetidUserassetid(self, skipSigningScripts: bool, clientInsert: int, scriptinsert: int, modulePlaceId: int, serverplaceid: int, expectedAssetType: str, userAssetId: int, Accept_Encoding: str, Roblox_Place_Id: int, AssetType: str, Accept: str, AssetFormat: str, Roblox_AssetFormat: str) -> AssetResponseItemV1:
            """
            Unknown
            
            Usage:
                import AssetDelivery
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AssetDeliveryApi = AssetDelivery.AssetDeliveryApi(RobloxClient=RobloxClient)
                Response = AssetDeliveryApi.GetUserassetidUserassetid(skipSigningScripts=boolean, clientInsert=integer, scriptinsert=integer, modulePlaceId=integer, serverplaceid=integer, expectedAssetType=string, userAssetId=integer, Accept_Encoding=string, Roblox_Place_Id=integer, AssetType=string, Accept=string, AssetFormat=string, Roblox_AssetFormat=string)
        
            Args:
                skipSigningScripts: bool
            clientInsert: int
            scriptinsert: int
            modulePlaceId: int
            serverplaceid: int
            expectedAssetType: str
            userAssetId: int
            Accept_Encoding: str
            Roblox_Place_Id: int
            AssetType: str
            Accept: str
            AssetFormat: str
            Roblox_AssetFormat: str
            Returns:
                AssetDelivery.AssetResponseItemV1: AssetDelivery.AssetResponseItemV1
            """
        
            Dictinary = {"json": {},"data": {},"params": {"skipSigningScripts": skipSigningScripts, "clientInsert": clientInsert, "scriptinsert": scriptinsert, "modulePlaceId": modulePlaceId, "serverplaceid": serverplaceid, "expectedAssetType": expectedAssetType},"headers": {"Accept_Encoding": Accept_Encoding, "Roblox_Place_Id": Roblox_Place_Id, "AssetType": AssetType, "Accept": Accept, "AssetFormat": AssetFormat, "Roblox_AssetFormat": Roblox_AssetFormat},"cookies": {}}
            
            GetUserassetidUserassetidRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AssetDelivery.roblox.com/v1/userAssetId/{userAssetId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AssetDelivery.AssetResponseItemV1()
        
            ReturnedJson = None
            try: ReturnedJson = GetUserassetidUserassetidRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUserassetidUserassetidRecivedData)
            
            return ResponseSchema
        
        def PostAssetsBatch(self, Roblox_Place_Id: int, Accept: str, Roblox_Browser_Asset_Request: str, assetRequestItems: None) -> requests.Response:
            """
            Unknown
            
            Usage:
                import AssetDelivery
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AssetDeliveryApi = AssetDelivery.AssetDeliveryApi(RobloxClient=RobloxClient)
                Response = AssetDeliveryApi.PostAssetsBatch(Roblox_Place_Id=integer, Accept=string, Roblox_Browser_Asset_Request=string, assetRequestItems=AssetDelivery.None())
        
            Args:
                Roblox_Place_Id: int
            Accept: str
            Roblox_Browser_Asset_Request: str
            assetRequestItems: None
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {"assetRequestItems": assetRequestItems},"data": {},"params": {},"headers": {"Roblox_Place_Id": Roblox_Place_Id, "Accept": Accept, "Roblox_Browser_Asset_Request": Roblox_Browser_Asset_Request},"cookies": {}}
            
            PostAssetsBatchRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AssetDelivery.roblox.com/v1/assets/batch", Dictinary=Dictinary)
            return PostAssetsBatchRecivedData
        
    class Ads:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class Stream:
            def __init__(ClassObject, CanRead: bool = None, CanWrite: bool = None, CanSeek: bool = None, CanTimeout: bool = None, Length: int = None, Position: int = None, ReadTimeout: int = None, WriteTimeout: int = None):
                ClassObject.CanRead = CanRead
                ClassObject.CanWrite = CanWrite
                ClassObject.CanSeek = CanSeek
                ClassObject.CanTimeout = CanTimeout
                ClassObject.Length = Length
                ClassObject.Position = Position
                ClassObject.ReadTimeout = ReadTimeout
                ClassObject.WriteTimeout = WriteTimeout
                ClassObject.response: requests.Response = None


        class IUploadedFile:
            def __init__(ClassObject, Name: str = None, Stream: "RobloxClient.Ads.Stream" = None, ContentEncoding: enum.Enum = None):
                ClassObject.Name = Name
                ClassObject.Stream = Stream
                ClassObject.ContentEncoding = ContentEncoding
                ClassObject.response: requests.Response = None



        
        def PostUserAdsAssetsCreate(self, assetId: int, name: str, Files: typing.IO) -> requests.Response:
            """
            Creates a user ad for an asset.
            
            Usage:
                import Ads
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdsApi = Ads.AdsApi(RobloxClient=RobloxClient)
                Response = AdsApi.PostUserAdsAssetsCreate(assetId=integer, name=string, Files=file)
        
            Args:
                assetId: int
            name: str
            Files: typing.IO
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {"name": name, "Files": Files},"params": {"assetId": assetId},"headers": {},"cookies": {}}
            
            PostUserAdsAssetsCreateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Ads.roblox.com/v1/user-ads/assets/create", Dictinary=Dictinary)
            return PostUserAdsAssetsCreateRecivedData
        
        def PostUserAdsGamePassesCreate(self, gamePassId: int, name: str, Files: typing.IO) -> requests.Response:
            """
            Creates a user ad for a game pass.
            
            Usage:
                import Ads
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdsApi = Ads.AdsApi(RobloxClient=RobloxClient)
                Response = AdsApi.PostUserAdsGamePassesCreate(gamePassId=integer, name=string, Files=file)
        
            Args:
                gamePassId: int
            name: str
            Files: typing.IO
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {"name": name, "Files": Files},"params": {"gamePassId": gamePassId},"headers": {},"cookies": {}}
            
            PostUserAdsGamePassesCreateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Ads.roblox.com/v1/user-ads/game-passes/create", Dictinary=Dictinary)
            return PostUserAdsGamePassesCreateRecivedData
        
        def PostUserAdsGroupsCreate(self, groupId: int, name: str, Files: typing.IO) -> requests.Response:
            """
            Creates a user ad for a group.
            
            Usage:
                import Ads
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdsApi = Ads.AdsApi(RobloxClient=RobloxClient)
                Response = AdsApi.PostUserAdsGroupsCreate(groupId=integer, name=string, Files=file)
        
            Args:
                groupId: int
            name: str
            Files: typing.IO
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {"name": name, "Files": Files},"params": {"groupId": groupId},"headers": {},"cookies": {}}
            
            PostUserAdsGroupsCreateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://Ads.roblox.com/v1/user-ads/groups/create", Dictinary=Dictinary)
            return PostUserAdsGroupsCreateRecivedData
        
    class AdConfiguration:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class CreateSponsoredGameV2Request:
            def __init__(ClassObject, universeId: int = None, targetGender: enum.Enum = None, targetAgeBracket: enum.Enum = None, budgetInRobux: int = None, startDate: str = None, endDate: str = None, targetDeviceType: enum.Enum = None, adName: str = None, bidAmountInRobux: int = None):
                ClassObject.universeId = universeId
                ClassObject.targetGender = targetGender
                ClassObject.targetAgeBracket = targetAgeBracket
                ClassObject.budgetInRobux = budgetInRobux
                ClassObject.startDate = startDate
                ClassObject.endDate = endDate
                ClassObject.targetDeviceType = targetDeviceType
                ClassObject.adName = adName
                ClassObject.bidAmountInRobux = bidAmountInRobux
                ClassObject.response: requests.Response = None


        class CreativeModel:
            def __init__(ClassObject, creativeId: int = None, creativeType: enum.Enum = None):
                ClassObject.creativeId = creativeId
                ClassObject.creativeType = creativeType
                ClassObject.response: requests.Response = None


        class SponsoredCampaignModel:
            def __init__(ClassObject, adId: int = None, adSetId: int = None, adName: str = None, adStatus: enum.Enum = None, creativeType: enum.Enum = None, creativeTargetId: int = None, bidAmountInRobux: int = None, budgetInRobux: int = None, adSetStatus: enum.Enum = None, startDate: str = None, endDate: str = None, targetGender: enum.Enum = None, targetAgeBracket: enum.Enum = None, targetDeviceType: enum.Enum = None, campaignTargetType: enum.Enum = None, campaignTargetId: int = None, totalSpendInRobux: int = None, totalImpressions: int = None, totalClicks: int = None, totalConversions: int = None, impressionConversions: int = None, clickConversions: int = None):
                ClassObject.adId = adId
                ClassObject.adSetId = adSetId
                ClassObject.adName = adName
                ClassObject.adStatus = adStatus
                ClassObject.creativeType = creativeType
                ClassObject.creativeTargetId = creativeTargetId
                ClassObject.bidAmountInRobux = bidAmountInRobux
                ClassObject.budgetInRobux = budgetInRobux
                ClassObject.adSetStatus = adSetStatus
                ClassObject.startDate = startDate
                ClassObject.endDate = endDate
                ClassObject.targetGender = targetGender
                ClassObject.targetAgeBracket = targetAgeBracket
                ClassObject.targetDeviceType = targetDeviceType
                ClassObject.campaignTargetType = campaignTargetType
                ClassObject.campaignTargetId = campaignTargetId
                ClassObject.totalSpendInRobux = totalSpendInRobux
                ClassObject.totalImpressions = totalImpressions
                ClassObject.totalClicks = totalClicks
                ClassObject.totalConversions = totalConversions
                ClassObject.impressionConversions = impressionConversions
                ClassObject.clickConversions = clickConversions
                ClassObject.response: requests.Response = None


        class GetSponsoredCampaignsResponse:
            def __init__(ClassObject, sponsoredCampaigns: list["RobloxClient.AdConfiguration.SponsoredCampaignModel"] = None, previousPageCursor: str = None, nextPageCursor: str = None):
                ClassObject.sponsoredCampaigns = sponsoredCampaigns
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.response: requests.Response = None


        class SponsoredGameV2Model:
            def __init__(ClassObject, adId: int = None, adSetId: int = None, adName: str = None, adStatus: enum.Enum = None, creativeType: enum.Enum = None, creativeTargetId: int = None, creativeUrl: str = None, bidAmountInRobux: int = None, budgetInRobux: int = None, adSetStatus: enum.Enum = None, startDate: str = None, endDate: str = None, targetGender: enum.Enum = None, targetAgeBracket: enum.Enum = None, targetDeviceType: enum.Enum = None, campaignTargetType: enum.Enum = None, campaignTargetId: int = None, totalSpendInRobux: int = None, totalImpressions: int = None, totalClicks: int = None, totalConversions: int = None, impressionConversions: int = None, clickConversions: int = None):
                ClassObject.adId = adId
                ClassObject.adSetId = adSetId
                ClassObject.adName = adName
                ClassObject.adStatus = adStatus
                ClassObject.creativeType = creativeType
                ClassObject.creativeTargetId = creativeTargetId
                ClassObject.creativeUrl = creativeUrl
                ClassObject.bidAmountInRobux = bidAmountInRobux
                ClassObject.budgetInRobux = budgetInRobux
                ClassObject.adSetStatus = adSetStatus
                ClassObject.startDate = startDate
                ClassObject.endDate = endDate
                ClassObject.targetGender = targetGender
                ClassObject.targetAgeBracket = targetAgeBracket
                ClassObject.targetDeviceType = targetDeviceType
                ClassObject.campaignTargetType = campaignTargetType
                ClassObject.campaignTargetId = campaignTargetId
                ClassObject.totalSpendInRobux = totalSpendInRobux
                ClassObject.totalImpressions = totalImpressions
                ClassObject.totalClicks = totalClicks
                ClassObject.totalConversions = totalConversions
                ClassObject.impressionConversions = impressionConversions
                ClassObject.clickConversions = clickConversions
                ClassObject.response: requests.Response = None


        class GetSponsoredGamesResponse:
            def __init__(ClassObject, sponsoredGames: list["RobloxClient.AdConfiguration.SponsoredGameV2Model"] = None, previousPageCursor: str = None, nextPageCursor: str = None):
                ClassObject.sponsoredGames = sponsoredGames
                ClassObject.previousPageCursor = previousPageCursor
                ClassObject.nextPageCursor = nextPageCursor
                ClassObject.response: requests.Response = None


        class CampaignTargetModel:
            def __init__(ClassObject, campaignTargetType: enum.Enum = None, campaignTargetId: int = None, name: str = None):
                ClassObject.campaignTargetType = campaignTargetType
                ClassObject.campaignTargetId = campaignTargetId
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class CreateSponsoredCampaignRequest:
            def __init__(ClassObject, campaignTargetId: int = None, campaignTargetType: enum.Enum = None, targetGender: enum.Enum = None, targetAgeBracket: enum.Enum = None, startDate: str = None, endDate: str = None, targetDeviceType: enum.Enum = None, campaignName: str = None, dailyBidAmountInRobux: int = None, placementLocation: enum.Enum = None, creativeModel: "RobloxClient.AdConfiguration.CreativeModel" = None):
                ClassObject.campaignTargetId = campaignTargetId
                ClassObject.campaignTargetType = campaignTargetType
                ClassObject.targetGender = targetGender
                ClassObject.targetAgeBracket = targetAgeBracket
                ClassObject.startDate = startDate
                ClassObject.endDate = endDate
                ClassObject.targetDeviceType = targetDeviceType
                ClassObject.campaignName = campaignName
                ClassObject.dailyBidAmountInRobux = dailyBidAmountInRobux
                ClassObject.placementLocation = placementLocation
                ClassObject.creativeModel = creativeModel
                ClassObject.response: requests.Response = None


        class GetCampaignTargetsResponse:
            def __init__(ClassObject, campaignTargetModels: list["RobloxClient.AdConfiguration.CampaignTargetModel"] = None):
                ClassObject.campaignTargetModels = campaignTargetModels
                ClassObject.response: requests.Response = None


        class GetEligibleCampaignTargetsRequest:
            def __init__(ClassObject, campaignTargetTypes: list[int] = None, groupId: int = None):
                ClassObject.campaignTargetTypes = campaignTargetTypes
                ClassObject.groupId = groupId
                ClassObject.response: requests.Response = None


        class UniverseModel:
            def __init__(ClassObject, id: int = None, name: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.response: requests.Response = None


        class GetRecentAdsRankedUniversesResponse:
            def __init__(ClassObject, universes: list["RobloxClient.AdConfiguration.UniverseModel"] = None):
                ClassObject.universes = universes
                ClassObject.response: requests.Response = None


        class StopSponsoredCampaignRequest:
            def __init__(ClassObject, adSetId: int = None):
                ClassObject.adSetId = adSetId
                ClassObject.response: requests.Response = None


        class StopSponsoredGameV2Request:
            def __init__(ClassObject, adSetId: int = None):
                ClassObject.adSetId = adSetId
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass


        
        def GetSponsoredCampaigns(self, campaignTargetType: int, campaignTargetId: int, includeReportingStats: bool, isArchived: bool, pageCursor: str) -> GetSponsoredCampaignsResponse:
            """
            Gets a page of Roblox.AdConfiguration.Api.SponsoredCampaignModel with specified input parameters.
            
            Usage:
                import AdConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdConfigurationApi = AdConfiguration.AdConfigurationApi(RobloxClient=RobloxClient)
                Response = AdConfigurationApi.GetSponsoredCampaigns(campaignTargetType=integer, campaignTargetId=integer, includeReportingStats=boolean, isArchived=boolean, pageCursor=string)
        
            Args:
                campaignTargetType: int
            campaignTargetId: int
            includeReportingStats: bool
            isArchived: bool
            pageCursor: str
            Returns:
                AdConfiguration.GetSponsoredCampaignsResponse: AdConfiguration.GetSponsoredCampaignsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"campaignTargetType": campaignTargetType, "campaignTargetId": campaignTargetId, "includeReportingStats": includeReportingStats, "isArchived": isArchived, "pageCursor": pageCursor},"headers": {},"cookies": {}}
            
            GetSponsoredCampaignsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AdConfiguration.roblox.com/v2/sponsored-campaigns", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AdConfiguration.GetSponsoredCampaignsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetSponsoredCampaignsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetSponsoredCampaignsRecivedData)
            
            return ResponseSchema
        
        def GetSponsoredCampaignsEligibleAssetTypeIds(self) -> requests.Response:
            """
            Get all asset type IDs that are eligible to be sponsored.
            
            Usage:
                import AdConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdConfigurationApi = AdConfiguration.AdConfigurationApi(RobloxClient=RobloxClient)
                Response = AdConfigurationApi.GetSponsoredCampaignsEligibleAssetTypeIds()
        
            Args:
                
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetSponsoredCampaignsEligibleAssetTypeIdsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AdConfiguration.roblox.com/v2/sponsored-campaigns/eligible-asset-type-ids", Dictinary=Dictinary)
            return GetSponsoredCampaignsEligibleAssetTypeIdsRecivedData
        
        def GetSponsoredCampaignsMultiGetCanUserSponsor(self, campaignTargetType: int, campaignTargetIds: list) -> requests.Response:
            """
            Checks whether the targets are eligible for sponsorship, and

if the user is authorized to sponsor the targets.
            
            Usage:
                import AdConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdConfigurationApi = AdConfiguration.AdConfigurationApi(RobloxClient=RobloxClient)
                Response = AdConfigurationApi.GetSponsoredCampaignsMultiGetCanUserSponsor(campaignTargetType=integer, campaignTargetIds=array)
        
            Args:
                campaignTargetType: int
            campaignTargetIds: list
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {"campaignTargetType": campaignTargetType, "campaignTargetIds": campaignTargetIds},"headers": {},"cookies": {}}
            
            GetSponsoredCampaignsMultiGetCanUserSponsorRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AdConfiguration.roblox.com/v2/sponsored-campaigns/multi-get-can-user-sponsor", Dictinary=Dictinary)
            return GetSponsoredCampaignsMultiGetCanUserSponsorRecivedData
        
        def GetSponsoredGames(self, universeId: int, includeReportingStats: bool, isArchived: bool, pageCursor: str) -> GetSponsoredGamesResponse:
            """
            Gets a page of Roblox.AdConfiguration.Api.SponsoredGameV2Model with specified input parameters.
            
            Usage:
                import AdConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdConfigurationApi = AdConfiguration.AdConfigurationApi(RobloxClient=RobloxClient)
                Response = AdConfigurationApi.GetSponsoredGames(universeId=integer, includeReportingStats=boolean, isArchived=boolean, pageCursor=string)
        
            Args:
                universeId: int
            includeReportingStats: bool
            isArchived: bool
            pageCursor: str
            Returns:
                AdConfiguration.GetSponsoredGamesResponse: AdConfiguration.GetSponsoredGamesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"universeId": universeId, "includeReportingStats": includeReportingStats, "isArchived": isArchived, "pageCursor": pageCursor},"headers": {},"cookies": {}}
            
            GetSponsoredGamesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AdConfiguration.roblox.com/v2/sponsored-games", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AdConfiguration.GetSponsoredGamesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetSponsoredGamesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetSponsoredGamesRecivedData)
            
            return ResponseSchema
        
        def GetSponsoredGamesUniverses(self, groupId: int) -> GetRecentAdsRankedUniversesResponse:
            """
            Gets a list of universes for the authenticated user, or the given group, ordered by most recently created sponsored game ads.
            
            Usage:
                import AdConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdConfigurationApi = AdConfiguration.AdConfigurationApi(RobloxClient=RobloxClient)
                Response = AdConfigurationApi.GetSponsoredGamesUniverses(groupId=integer)
        
            Args:
                groupId: int
            Returns:
                AdConfiguration.GetRecentAdsRankedUniversesResponse: AdConfiguration.GetRecentAdsRankedUniversesResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"groupId": groupId},"headers": {},"cookies": {}}
            
            GetSponsoredGamesUniversesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AdConfiguration.roblox.com/v2/sponsored-games/universes", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AdConfiguration.GetRecentAdsRankedUniversesResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetSponsoredGamesUniversesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetSponsoredGamesUniversesRecivedData)
            
            return ResponseSchema
        
        def PostSponsoredCampaignsCreate(self, CreateSponsoredCampaignRequest: CreateSponsoredCampaignRequest) -> requests.Response:
            """
            Creates a complete ad. Including ad campaign, ad set, escrow, and the ad.

Currently intended for creation of sponsorships only.
            
            Usage:
                import AdConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdConfigurationApi = AdConfiguration.AdConfigurationApi(RobloxClient=RobloxClient)
                Response = AdConfigurationApi.PostSponsoredCampaignsCreate(CreateSponsoredCampaignRequest=AdConfiguration.CreateSponsoredCampaignRequest())
        
            Args:
                CreateSponsoredCampaignRequest: CreateSponsoredCampaignRequest
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'CreateSponsoredCampaignRequest': 'json'}
            Arguments = inspect.signature(self.PostSponsoredCampaignsCreate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostSponsoredCampaignsCreateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AdConfiguration.roblox.com/v2/sponsored-campaigns/create", Dictinary=Dictinary)
            return PostSponsoredCampaignsCreateRecivedData
        
        def PostSponsoredCampaignsEligibleCampaignTargets(self, GetEligibleCampaignTargetsRequest: GetEligibleCampaignTargetsRequest) -> GetCampaignTargetsResponse:
            """
            Returns a collection of Roblox.AdConfiguration.Api.Models.CampaignTargetModel that the user is authorized to sponsor, ordered by most recently advertised
            
            Usage:
                import AdConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdConfigurationApi = AdConfiguration.AdConfigurationApi(RobloxClient=RobloxClient)
                Response = AdConfigurationApi.PostSponsoredCampaignsEligibleCampaignTargets(GetEligibleCampaignTargetsRequest=AdConfiguration.GetEligibleCampaignTargetsRequest())
        
            Args:
                GetEligibleCampaignTargetsRequest: GetEligibleCampaignTargetsRequest
            Returns:
                AdConfiguration.GetCampaignTargetsResponse: AdConfiguration.GetCampaignTargetsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'GetEligibleCampaignTargetsRequest': 'json'}
            Arguments = inspect.signature(self.PostSponsoredCampaignsEligibleCampaignTargets)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostSponsoredCampaignsEligibleCampaignTargetsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AdConfiguration.roblox.com/v2/sponsored-campaigns/eligible-campaign-targets", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AdConfiguration.GetCampaignTargetsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostSponsoredCampaignsEligibleCampaignTargetsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostSponsoredCampaignsEligibleCampaignTargetsRecivedData)
            
            return ResponseSchema
        
        def PostSponsoredCampaignsStop(self, StopSponsoredCampaignRequest: StopSponsoredCampaignRequest) -> requests.Response:
            """
            Stops a sponsored campaign / ad (ad set) from running. Initiated by a user.
            
            Usage:
                import AdConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdConfigurationApi = AdConfiguration.AdConfigurationApi(RobloxClient=RobloxClient)
                Response = AdConfigurationApi.PostSponsoredCampaignsStop(StopSponsoredCampaignRequest=AdConfiguration.StopSponsoredCampaignRequest())
        
            Args:
                StopSponsoredCampaignRequest: StopSponsoredCampaignRequest
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'StopSponsoredCampaignRequest': 'json'}
            Arguments = inspect.signature(self.PostSponsoredCampaignsStop)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostSponsoredCampaignsStopRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AdConfiguration.roblox.com/v2/sponsored-campaigns/stop", Dictinary=Dictinary)
            return PostSponsoredCampaignsStopRecivedData
        
        def PostSponsoredGamesCreate(self, CreateSponsoredGameV2Request: CreateSponsoredGameV2Request) -> ApiEmptyResponseModel:
            """
            Creates a new sponsored game ad with specified input parameters.
            
            Usage:
                import AdConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdConfigurationApi = AdConfiguration.AdConfigurationApi(RobloxClient=RobloxClient)
                Response = AdConfigurationApi.PostSponsoredGamesCreate(CreateSponsoredGameV2Request=AdConfiguration.CreateSponsoredGameV2Request())
        
            Args:
                CreateSponsoredGameV2Request: CreateSponsoredGameV2Request
            Returns:
                AdConfiguration.ApiEmptyResponseModel: AdConfiguration.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'CreateSponsoredGameV2Request': 'json'}
            Arguments = inspect.signature(self.PostSponsoredGamesCreate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostSponsoredGamesCreateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AdConfiguration.roblox.com/v2/sponsored-games/create", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AdConfiguration.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostSponsoredGamesCreateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostSponsoredGamesCreateRecivedData)
            
            return ResponseSchema
        
        def PostSponsoredGamesStop(self, StopSponsoredGameV2Request: StopSponsoredGameV2Request) -> ApiEmptyResponseModel:
            """
            To stop a sponsored-game ad (ad set) from running, initiated by a user.
            
            Usage:
                import AdConfiguration
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AdConfigurationApi = AdConfiguration.AdConfigurationApi(RobloxClient=RobloxClient)
                Response = AdConfigurationApi.PostSponsoredGamesStop(StopSponsoredGameV2Request=AdConfiguration.StopSponsoredGameV2Request())
        
            Args:
                StopSponsoredGameV2Request: StopSponsoredGameV2Request
            Returns:
                AdConfiguration.ApiEmptyResponseModel: AdConfiguration.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'StopSponsoredGameV2Request': 'json'}
            Arguments = inspect.signature(self.PostSponsoredGamesStop)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostSponsoredGamesStopRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AdConfiguration.roblox.com/v2/sponsored-games/stop", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AdConfiguration.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostSponsoredGamesStopRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostSponsoredGamesStopRecivedData)
            
            return ResponseSchema
        
    class AccountSettings:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class AppChatPrivacyRequest:
            def __init__(ClassObject, appChatPrivacy: enum.Enum = None):
                ClassObject.appChatPrivacy = appChatPrivacy
                ClassObject.response: requests.Response = None


        class AppChatPrivacyResponse:
            def __init__(ClassObject, appChatPrivacy: str = None):
                ClassObject.appChatPrivacy = appChatPrivacy
                ClassObject.response: requests.Response = None


        class EmailResponse:
            def __init__(ClassObject, emailAddress: str = None, verified: bool = None, canBypassPasswordForEmailUpdate: bool = None):
                ClassObject.emailAddress = emailAddress
                ClassObject.verified = verified
                ClassObject.canBypassPasswordForEmailUpdate = canBypassPasswordForEmailUpdate
                ClassObject.response: requests.Response = None


        class GameChatPrivacyRequest:
            def __init__(ClassObject, gameChatPrivacy: enum.Enum = None):
                ClassObject.gameChatPrivacy = gameChatPrivacy
                ClassObject.response: requests.Response = None


        class GameChatPrivacyResponse:
            def __init__(ClassObject, gameChatPrivacy: str = None):
                ClassObject.gameChatPrivacy = gameChatPrivacy
                ClassObject.response: requests.Response = None


        class InventoryPrivacyRequest:
            def __init__(ClassObject, inventoryPrivacy: enum.Enum = None):
                ClassObject.inventoryPrivacy = inventoryPrivacy
                ClassObject.response: requests.Response = None


        class InventoryPrivacyResponse:
            def __init__(ClassObject, inventoryPrivacy: enum.Enum = None):
                ClassObject.inventoryPrivacy = inventoryPrivacy
                ClassObject.response: requests.Response = None


        class InventoryPrivacyUpdateResponse:
            def __init__(ClassObject, inventoryPrivacy: enum.Enum = None, tradePrivacy: enum.Enum = None, privacySettingResponse: enum.Enum = None):
                ClassObject.inventoryPrivacy = inventoryPrivacy
                ClassObject.tradePrivacy = tradePrivacy
                ClassObject.privacySettingResponse = privacySettingResponse
                ClassObject.response: requests.Response = None


        class AccountsSettingsMetadataModel:
            def __init__(ClassObject, IsAccountsRestrictionsSpamBugFixEnabled: bool = None, MaximumParentalControlsMonthlySpendLimitInUSD: int = None, IsParentalMonthlyLimitInUIEnabled: bool = None, IsParentalNotificationSettingsInUIEnabled: bool = None, IsContentControlsEnabled: bool = None):
                ClassObject.IsAccountsRestrictionsSpamBugFixEnabled = IsAccountsRestrictionsSpamBugFixEnabled
                ClassObject.MaximumParentalControlsMonthlySpendLimitInUSD = MaximumParentalControlsMonthlySpendLimitInUSD
                ClassObject.IsParentalMonthlyLimitInUIEnabled = IsParentalMonthlyLimitInUIEnabled
                ClassObject.IsParentalNotificationSettingsInUIEnabled = IsParentalNotificationSettingsInUIEnabled
                ClassObject.IsContentControlsEnabled = IsContentControlsEnabled
                ClassObject.response: requests.Response = None


        class BlockedUser:
            def __init__(ClassObject, userId: int = None, name: str = None, displayName: str = None):
                ClassObject.userId = userId
                ClassObject.name = name
                ClassObject.displayName = displayName
                ClassObject.response: requests.Response = None


        class UserAccountCountry:
            def __init__(ClassObject, countryName: str = None, subdivisionIso: str = None, localizedSubdivision: str = None, localizedName: str = None, countryId: int = None):
                ClassObject.countryName = countryName
                ClassObject.subdivisionIso = subdivisionIso
                ClassObject.localizedSubdivision = localizedSubdivision
                ClassObject.localizedName = localizedName
                ClassObject.countryId = countryId
                ClassObject.response: requests.Response = None


        class AccountCountrySettingsResponse:
            def __init__(ClassObject, value: "RobloxClient.AccountSettings.UserAccountCountry" = None, options: list["RobloxClient.AccountSettings.UserAccountCountry"] = None, modifiable: bool = None):
                ClassObject.value = value
                ClassObject.options = options
                ClassObject.modifiable = modifiable
                ClassObject.response: requests.Response = None


        class GetBlockedUsersResponse:
            def __init__(ClassObject, blockedUserIds: list[int] = None):
                ClassObject.blockedUserIds = blockedUserIds
                ClassObject.response: requests.Response = None


        class GetDetailedBlockedUsersResponse:
            def __init__(ClassObject, blockedUsers: list["RobloxClient.AccountSettings.BlockedUser"] = None, maxBlockedUsers: int = None, total: int = None):
                ClassObject.blockedUsers = blockedUsers
                ClassObject.maxBlockedUsers = maxBlockedUsers
                ClassObject.total = total
                ClassObject.response: requests.Response = None


        class UpdateAccountCountryResponse:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class PrivateMessagePrivacyRequest:
            def __init__(ClassObject, privateMessagePrivacy: str = None):
                ClassObject.privateMessagePrivacy = privateMessagePrivacy
                ClassObject.response: requests.Response = None


        class PrivateMessagePrivacyResponse:
            def __init__(ClassObject, privateMessagePrivacy: str = None):
                ClassObject.privateMessagePrivacy = privateMessagePrivacy
                ClassObject.response: requests.Response = None


        class SendVerifyEmailRequest:
            def __init__(ClassObject, freeItem: bool = None, isAdsAccount: bool = None):
                ClassObject.freeItem = freeItem
                ClassObject.isAdsAccount = isAdsAccount
                ClassObject.response: requests.Response = None


        class ThemeConfigurationRequest:
            def __init__(ClassObject, themeType: str = None):
                ClassObject.themeType = themeType
                ClassObject.response: requests.Response = None


        class ThemeConfigurationResponse:
            def __init__(ClassObject, themeType: str = None):
                ClassObject.themeType = themeType
                ClassObject.response: requests.Response = None


        class TradePrivacyResponse:
            def __init__(ClassObject, tradePrivacy: str = None):
                ClassObject.tradePrivacy = tradePrivacy
                ClassObject.response: requests.Response = None


        class TradePrivacyUpdateResponse:
            def __init__(ClassObject, tradePrivacy: enum.Enum = None, inventoryPrivacy: enum.Enum = None, privacySettingResponse: enum.Enum = None):
                ClassObject.tradePrivacy = tradePrivacy
                ClassObject.inventoryPrivacy = inventoryPrivacy
                ClassObject.privacySettingResponse = privacySettingResponse
                ClassObject.response: requests.Response = None


        class TradeValueRequest:
            def __init__(ClassObject, tradeValue: enum.Enum = None):
                ClassObject.tradeValue = tradeValue
                ClassObject.response: requests.Response = None


        class TradeValueResponse:
            def __init__(ClassObject, tradeValue: str = None):
                ClassObject.tradeValue = tradeValue
                ClassObject.response: requests.Response = None


        class UpdateAccountCountryRequest:
            def __init__(ClassObject, targetCountryId: int = None):
                ClassObject.targetCountryId = targetCountryId
                ClassObject.response: requests.Response = None


        class UpdateEmailRequest:
            def __init__(ClassObject, password: str = None, emailAddress: str = None, skipVerificationEmail: bool = None, isAdsAccount: bool = None):
                ClassObject.password = password
                ClassObject.emailAddress = emailAddress
                ClassObject.skipVerificationEmail = skipVerificationEmail
                ClassObject.isAdsAccount = isAdsAccount
                ClassObject.response: requests.Response = None


        class UpdateTradePrivacyRequest:
            def __init__(ClassObject, tradePrivacy: enum.Enum = None):
                ClassObject.tradePrivacy = tradePrivacy
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class StringExtra:
            def __init__(ClassObject, data: list[str] = None):
                ClassObject.data = data
                ClassObject.response: requests.Response = None



        
        def GetAccountSettingsAccountCountry(self) -> AccountCountrySettingsResponse:
            """
            Get a user's current account country setting.
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetAccountSettingsAccountCountry()
        
            Args:
                
            Returns:
                AccountSettings.AccountCountrySettingsResponse: AccountSettings.AccountCountrySettingsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAccountSettingsAccountCountryRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/account/settings/account-country", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.AccountCountrySettingsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAccountSettingsAccountCountryRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAccountSettingsAccountCountryRecivedData)
            
            return ResponseSchema
        
        def PostAccountSettingsAccountCountry(self, UpdateAccountCountryRequest: UpdateAccountCountryRequest) -> UpdateAccountCountryResponse:
            """
            Updates the user's account country.
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PostAccountSettingsAccountCountry(UpdateAccountCountryRequest=AccountSettings.UpdateAccountCountryRequest())
        
            Args:
                UpdateAccountCountryRequest: UpdateAccountCountryRequest
            Returns:
                AccountSettings.UpdateAccountCountryResponse: AccountSettings.UpdateAccountCountryResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateAccountCountryRequest': 'json'}
            Arguments = inspect.signature(self.PostAccountSettingsAccountCountry)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostAccountSettingsAccountCountryRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountSettings.roblox.com/v1/account/settings/account-country", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.UpdateAccountCountryResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostAccountSettingsAccountCountryRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAccountSettingsAccountCountryRecivedData)
            
            return ResponseSchema
        
        def GetAccountSettingsMetadata(self) -> AccountsSettingsMetadataModel:
            """
            Returns metadata used by the account settings page
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetAccountSettingsMetadata()
        
            Args:
                
            Returns:
                AccountSettings.AccountsSettingsMetadataModel: AccountSettings.AccountsSettingsMetadataModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAccountSettingsMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/account/settings/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.AccountsSettingsMetadataModel()
        
            ReturnedJson = None
            try: ReturnedJson = GetAccountSettingsMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAccountSettingsMetadataRecivedData)
            
            return ResponseSchema
        
        def GetAppChatPrivacy(self) -> AppChatPrivacyResponse:
            """
            Get a user's app chat privacy setting
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetAppChatPrivacy()
        
            Args:
                
            Returns:
                AccountSettings.AppChatPrivacyResponse: AccountSettings.AppChatPrivacyResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetAppChatPrivacyRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/app-chat-privacy", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.AppChatPrivacyResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetAppChatPrivacyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetAppChatPrivacyRecivedData)
            
            return ResponseSchema
        
        def PostAppChatPrivacy(self, AppChatPrivacyRequest: AppChatPrivacyRequest) -> ApiEmptyResponseModel:
            """
            Updates a user's app chat privacy setting
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PostAppChatPrivacy(AppChatPrivacyRequest=AccountSettings.AppChatPrivacyRequest())
        
            Args:
                AppChatPrivacyRequest: AppChatPrivacyRequest
            Returns:
                AccountSettings.ApiEmptyResponseModel: AccountSettings.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'AppChatPrivacyRequest': 'json'}
            Arguments = inspect.signature(self.PostAppChatPrivacy)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostAppChatPrivacyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountSettings.roblox.com/v1/app-chat-privacy", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostAppChatPrivacyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostAppChatPrivacyRecivedData)
            
            return ResponseSchema
        
        def GetEmail(self) -> EmailResponse:
            """
            Gets the authenticated user's email address and verified status
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetEmail()
        
            Args:
                
            Returns:
                AccountSettings.EmailResponse: AccountSettings.EmailResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetEmailRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/email", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.EmailResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetEmailRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetEmailRecivedData)
            
            return ResponseSchema
        
        def PatchEmail(self, UpdateEmailRequest: UpdateEmailRequest) -> ApiEmptyResponseModel:
            """
            Updates the authenticated user's email address
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PatchEmail(UpdateEmailRequest=AccountSettings.UpdateEmailRequest())
        
            Args:
                UpdateEmailRequest: UpdateEmailRequest
            Returns:
                AccountSettings.ApiEmptyResponseModel: AccountSettings.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateEmailRequest': 'json'}
            Arguments = inspect.signature(self.PatchEmail)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchEmailRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://AccountSettings.roblox.com/v1/email", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchEmailRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchEmailRecivedData)
            
            return ResponseSchema
        
        def PostEmail(self, UpdateEmailRequest: UpdateEmailRequest) -> ApiEmptyResponseModel:
            """
            Updates the authenticated user's email address
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PostEmail(UpdateEmailRequest=AccountSettings.UpdateEmailRequest())
        
            Args:
                UpdateEmailRequest: UpdateEmailRequest
            Returns:
                AccountSettings.ApiEmptyResponseModel: AccountSettings.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateEmailRequest': 'json'}
            Arguments = inspect.signature(self.PostEmail)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostEmailRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountSettings.roblox.com/v1/email", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostEmailRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostEmailRecivedData)
            
            return ResponseSchema
        
        def GetGameChatPrivacy(self) -> GameChatPrivacyResponse:
            """
            Get a user's game chat privacy setting
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetGameChatPrivacy()
        
            Args:
                
            Returns:
                AccountSettings.GameChatPrivacyResponse: AccountSettings.GameChatPrivacyResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGameChatPrivacyRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/game-chat-privacy", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.GameChatPrivacyResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGameChatPrivacyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGameChatPrivacyRecivedData)
            
            return ResponseSchema
        
        def PostGameChatPrivacy(self, GameChatPrivacyRequest: GameChatPrivacyRequest) -> ApiEmptyResponseModel:
            """
            Updates a user's game chat privacy setting
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PostGameChatPrivacy(GameChatPrivacyRequest=AccountSettings.GameChatPrivacyRequest())
        
            Args:
                GameChatPrivacyRequest: GameChatPrivacyRequest
            Returns:
                AccountSettings.ApiEmptyResponseModel: AccountSettings.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'GameChatPrivacyRequest': 'json'}
            Arguments = inspect.signature(self.PostGameChatPrivacy)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGameChatPrivacyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountSettings.roblox.com/v1/game-chat-privacy", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGameChatPrivacyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGameChatPrivacyRecivedData)
            
            return ResponseSchema
        
        def GetInventoryPrivacy(self) -> InventoryPrivacyResponse:
            """
            Get a user's inventory privacy setting
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetInventoryPrivacy()
        
            Args:
                
            Returns:
                AccountSettings.InventoryPrivacyResponse: AccountSettings.InventoryPrivacyResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetInventoryPrivacyRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/inventory-privacy", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.InventoryPrivacyResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetInventoryPrivacyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetInventoryPrivacyRecivedData)
            
            return ResponseSchema
        
        def PostInventoryPrivacy(self, InventoryPrivacyRequest: InventoryPrivacyRequest) -> InventoryPrivacyUpdateResponse:
            """
            Updates a user's inventory privacy setting
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PostInventoryPrivacy(InventoryPrivacyRequest=AccountSettings.InventoryPrivacyRequest())
        
            Args:
                InventoryPrivacyRequest: InventoryPrivacyRequest
            Returns:
                AccountSettings.InventoryPrivacyUpdateResponse: AccountSettings.InventoryPrivacyUpdateResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'InventoryPrivacyRequest': 'json'}
            Arguments = inspect.signature(self.PostInventoryPrivacy)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostInventoryPrivacyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountSettings.roblox.com/v1/inventory-privacy", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.InventoryPrivacyUpdateResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostInventoryPrivacyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostInventoryPrivacyRecivedData)
            
            return ResponseSchema
        
        def GetPrivateMessagePrivacy(self) -> PrivateMessagePrivacyResponse:
            """
            Get a user's private message privacy setting
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetPrivateMessagePrivacy()
        
            Args:
                
            Returns:
                AccountSettings.PrivateMessagePrivacyResponse: AccountSettings.PrivateMessagePrivacyResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetPrivateMessagePrivacyRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/private-message-privacy", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.PrivateMessagePrivacyResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetPrivateMessagePrivacyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPrivateMessagePrivacyRecivedData)
            
            return ResponseSchema
        
        def PostPrivateMessagePrivacy(self, PrivateMessagePrivacyRequest: PrivateMessagePrivacyRequest) -> ApiEmptyResponseModel:
            """
            Updates a user's private message privacy setting
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PostPrivateMessagePrivacy(PrivateMessagePrivacyRequest=AccountSettings.PrivateMessagePrivacyRequest())
        
            Args:
                PrivateMessagePrivacyRequest: PrivateMessagePrivacyRequest
            Returns:
                AccountSettings.ApiEmptyResponseModel: AccountSettings.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PrivateMessagePrivacyRequest': 'json'}
            Arguments = inspect.signature(self.PostPrivateMessagePrivacy)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPrivateMessagePrivacyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountSettings.roblox.com/v1/private-message-privacy", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPrivateMessagePrivacyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPrivateMessagePrivacyRecivedData)
            
            return ResponseSchema
        
        def GetThemesConsumertypeConsumerid(self, consumerType: int, consumerId: str) -> ThemeConfigurationResponse:
            """
            returns the theme type for a specific consumer.
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetThemesConsumertypeConsumerid(consumerType=integer, consumerId=string)
        
            Args:
                consumerType: int
            consumerId: str
            Returns:
                AccountSettings.ThemeConfigurationResponse: AccountSettings.ThemeConfigurationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetThemesConsumertypeConsumeridRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/themes/{consumerType}/{consumerId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.ThemeConfigurationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetThemesConsumertypeConsumeridRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetThemesConsumertypeConsumeridRecivedData)
            
            return ResponseSchema
        
        def PatchThemesConsumertypeConsumerid(self, consumerType: int, consumerId: int, ThemeConfigurationRequest: ThemeConfigurationRequest) -> ApiEmptyResponseModel:
            """
            Modify the theme type for consumer.
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PatchThemesConsumertypeConsumerid(consumerType=integer, consumerId=integer, ThemeConfigurationRequest=AccountSettings.ThemeConfigurationRequest())
        
            Args:
                consumerType: int
            consumerId: int
            ThemeConfigurationRequest: ThemeConfigurationRequest
            Returns:
                AccountSettings.ApiEmptyResponseModel: AccountSettings.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'ThemeConfigurationRequest': 'json'}
            Arguments = inspect.signature(self.PatchThemesConsumertypeConsumerid)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PatchThemesConsumertypeConsumeridRecivedData = self._RobloxClient._MakeRequest(method="patch", url=f"https://AccountSettings.roblox.com/v1/themes/{consumerType}/{consumerId}", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PatchThemesConsumertypeConsumeridRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PatchThemesConsumertypeConsumeridRecivedData)
            
            return ResponseSchema
        
        def GetThemesTypes(self) -> StringExtra:
            """
            returns all the enabled theme types.
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetThemesTypes()
        
            Args:
                
            Returns:
                AccountSettings.StringExtra: AccountSettings.StringExtra
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetThemesTypesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/themes/types", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.StringExtra()
        
            ReturnedJson = None
            try: ReturnedJson = GetThemesTypesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetThemesTypesRecivedData)
            
            return ResponseSchema
        
        def GetTradePrivacy(self) -> TradePrivacyResponse:
            """
            Get a user's trade privacy setting
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetTradePrivacy()
        
            Args:
                
            Returns:
                AccountSettings.TradePrivacyResponse: AccountSettings.TradePrivacyResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetTradePrivacyRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/trade-privacy", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.TradePrivacyResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetTradePrivacyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetTradePrivacyRecivedData)
            
            return ResponseSchema
        
        def PostTradePrivacy(self, UpdateTradePrivacyRequest: UpdateTradePrivacyRequest) -> TradePrivacyUpdateResponse:
            """
            Updates a user's trade privacy setting
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PostTradePrivacy(UpdateTradePrivacyRequest=AccountSettings.UpdateTradePrivacyRequest())
        
            Args:
                UpdateTradePrivacyRequest: UpdateTradePrivacyRequest
            Returns:
                AccountSettings.TradePrivacyUpdateResponse: AccountSettings.TradePrivacyUpdateResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'UpdateTradePrivacyRequest': 'json'}
            Arguments = inspect.signature(self.PostTradePrivacy)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostTradePrivacyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountSettings.roblox.com/v1/trade-privacy", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.TradePrivacyUpdateResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostTradePrivacyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTradePrivacyRecivedData)
            
            return ResponseSchema
        
        def GetTradeValue(self) -> TradeValueResponse:
            """
            Get a user's trade quality filter setting
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetTradeValue()
        
            Args:
                
            Returns:
                AccountSettings.TradeValueResponse: AccountSettings.TradeValueResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetTradeValueRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/trade-value", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.TradeValueResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetTradeValueRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetTradeValueRecivedData)
            
            return ResponseSchema
        
        def PostTradeValue(self, TradeValueRequest: TradeValueRequest) -> ApiEmptyResponseModel:
            """
            Updates a user's trade quality filter setting
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PostTradeValue(TradeValueRequest=AccountSettings.TradeValueRequest())
        
            Args:
                TradeValueRequest: TradeValueRequest
            Returns:
                AccountSettings.ApiEmptyResponseModel: AccountSettings.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'TradeValueRequest': 'json'}
            Arguments = inspect.signature(self.PostTradeValue)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostTradeValueRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountSettings.roblox.com/v1/trade-value", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostTradeValueRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostTradeValueRecivedData)
            
            return ResponseSchema
        
        def GetUsersGetBlockedUsers(self) -> GetBlockedUsersResponse:
            """
            Gets all blocked users.
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetUsersGetBlockedUsers()
        
            Args:
                
            Returns:
                AccountSettings.GetBlockedUsersResponse: AccountSettings.GetBlockedUsersResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersGetBlockedUsersRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/users/get-blocked-users", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.GetBlockedUsersResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersGetBlockedUsersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersGetBlockedUsersRecivedData)
            
            return ResponseSchema
        
        def GetUsersGetDetailedBlockedUsers(self) -> GetDetailedBlockedUsersResponse:
            """
            Gets all blocked users with details.
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.GetUsersGetDetailedBlockedUsers()
        
            Args:
                
            Returns:
                AccountSettings.GetDetailedBlockedUsersResponse: AccountSettings.GetDetailedBlockedUsersResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersGetDetailedBlockedUsersRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountSettings.roblox.com/v1/users/get-detailed-blocked-users", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.GetDetailedBlockedUsersResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersGetDetailedBlockedUsersRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersGetDetailedBlockedUsersRecivedData)
            
            return ResponseSchema
        
        def PostEmailVerify(self, SendVerifyEmailRequest: SendVerifyEmailRequest) -> ApiEmptyResponseModel:
            """
            Send verify email to the authenticated user's email address
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PostEmailVerify(SendVerifyEmailRequest=AccountSettings.SendVerifyEmailRequest())
        
            Args:
                SendVerifyEmailRequest: SendVerifyEmailRequest
            Returns:
                AccountSettings.ApiEmptyResponseModel: AccountSettings.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'SendVerifyEmailRequest': 'json'}
            Arguments = inspect.signature(self.PostEmailVerify)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostEmailVerifyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountSettings.roblox.com/v1/email/verify", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostEmailVerifyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostEmailVerifyRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridBlock(self, userId: int) -> ApiEmptyResponseModel:
            """
            Blocks another user.
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PostUsersUseridBlock(userId=integer)
        
            Args:
                userId: int
            Returns:
                AccountSettings.ApiEmptyResponseModel: AccountSettings.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostUsersUseridBlockRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountSettings.roblox.com/v1/users/{userId}/block", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridBlockRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridBlockRecivedData)
            
            return ResponseSchema
        
        def PostUsersUseridUnblock(self, userId: int) -> ApiEmptyResponseModel:
            """
            Unblocks a previously blocked user.
            
            Usage:
                import AccountSettings
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountSettingsApi = AccountSettings.AccountSettingsApi(RobloxClient=RobloxClient)
                Response = AccountSettingsApi.PostUsersUseridUnblock(userId=integer)
        
            Args:
                userId: int
            Returns:
                AccountSettings.ApiEmptyResponseModel: AccountSettings.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            PostUsersUseridUnblockRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountSettings.roblox.com/v1/users/{userId}/unblock", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountSettings.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostUsersUseridUnblockRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostUsersUseridUnblockRecivedData)
            
            return ResponseSchema
        
    class AccountInformation:
        def __init__(self, RobloxClient: "RobloxClient"):
            self._RobloxClient = RobloxClient
        class BirthdateRequest:
            def __init__(ClassObject, birthMonth: int = None, birthDay: int = None, birthYear: int = None, password: str = None):
                ClassObject.birthMonth = birthMonth
                ClassObject.birthDay = birthDay
                ClassObject.birthYear = birthYear
                ClassObject.password = password
                ClassObject.response: requests.Response = None


        class BirthdateResponse:
            def __init__(ClassObject, birthMonth: int = None, birthDay: int = None, birthYear: int = None):
                ClassObject.birthMonth = birthMonth
                ClassObject.birthDay = birthDay
                ClassObject.birthYear = birthYear
                ClassObject.response: requests.Response = None


        class ConsecutiveLoginDaysResponse:
            def __init__(ClassObject, count: int = None):
                ClassObject.count = count
                ClassObject.response: requests.Response = None


        class DescriptionRequest:
            def __init__(ClassObject, description: str = None):
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class DescriptionResponse:
            def __init__(ClassObject, description: str = None):
                ClassObject.description = description
                ClassObject.response: requests.Response = None


        class EmptyRequest:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass

        class GenderRequest:
            def __init__(ClassObject, gender: str = None):
                ClassObject.gender = gender
                ClassObject.response: requests.Response = None


        class GenderResponse:
            def __init__(ClassObject, gender: int = None):
                ClassObject.gender = gender
                ClassObject.response: requests.Response = None


        class MetadataResponse:
            def __init__(ClassObject, isAllowedNotificationsEndpointDisabled: bool = None, isAccountSettingsPolicyEnabled: bool = None, isPhoneNumberEnabled: bool = None, MaxUserDescriptionLength: int = None, isUserDescriptionEnabled: bool = None, isUserBlockEndpointsUpdated: bool = None, isPasswordRequiredForAgingDown: bool = None, shouldUsePersonaForIdVerification: bool = None, shouldDisplaySessionManagement: bool = None):
                ClassObject.isAllowedNotificationsEndpointDisabled = isAllowedNotificationsEndpointDisabled
                ClassObject.isAccountSettingsPolicyEnabled = isAccountSettingsPolicyEnabled
                ClassObject.isPhoneNumberEnabled = isPhoneNumberEnabled
                ClassObject.MaxUserDescriptionLength = MaxUserDescriptionLength
                ClassObject.isUserDescriptionEnabled = isUserDescriptionEnabled
                ClassObject.isUserBlockEndpointsUpdated = isUserBlockEndpointsUpdated
                ClassObject.isPasswordRequiredForAgingDown = isPasswordRequiredForAgingDown
                ClassObject.shouldUsePersonaForIdVerification = shouldUsePersonaForIdVerification
                ClassObject.shouldDisplaySessionManagement = shouldDisplaySessionManagement
                ClassObject.response: requests.Response = None


        class PhoneRequest:
            def __init__(ClassObject, countryCode: str = None, prefix: str = None, phone: str = None, password: str = None, verificationChannel: str = None):
                ClassObject.countryCode = countryCode
                ClassObject.prefix = prefix
                ClassObject.phone = phone
                ClassObject.password = password
                ClassObject.verificationChannel = verificationChannel
                ClassObject.response: requests.Response = None


        class PhoneResponse:
            def __init__(ClassObject, countryCode: str = None, prefix: str = None, phone: str = None, isVerified: bool = None, verificationCodeLength: int = None, canBypassPasswordForPhoneUpdate: bool = None):
                ClassObject.countryCode = countryCode
                ClassObject.prefix = prefix
                ClassObject.phone = phone
                ClassObject.isVerified = isVerified
                ClassObject.verificationCodeLength = verificationCodeLength
                ClassObject.canBypassPasswordForPhoneUpdate = canBypassPasswordForPhoneUpdate
                ClassObject.response: requests.Response = None


        class PromotionChannelsByUserIdResponse:
            def __init__(ClassObject, facebook: str = None, twitter: str = None, youtube: str = None, twitch: str = None, guilded: str = None):
                ClassObject.facebook = facebook
                ClassObject.twitter = twitter
                ClassObject.youtube = youtube
                ClassObject.twitch = twitch
                ClassObject.guilded = guilded
                ClassObject.response: requests.Response = None


        class PromotionChannelsRequest:
            def __init__(ClassObject, facebook: str = None, twitter: str = None, youtube: str = None, twitch: str = None, guilded: str = None, promotionChannelsVisibilityPrivacy: str = None):
                ClassObject.facebook = facebook
                ClassObject.twitter = twitter
                ClassObject.youtube = youtube
                ClassObject.twitch = twitch
                ClassObject.guilded = guilded
                ClassObject.promotionChannelsVisibilityPrivacy = promotionChannelsVisibilityPrivacy
                ClassObject.response: requests.Response = None


        class PromotionChannelsResponse:
            def __init__(ClassObject, promotionChannelsVisibilityPrivacy: str = None, facebook: str = None, twitter: str = None, youtube: str = None, twitch: str = None, guilded: str = None):
                ClassObject.promotionChannelsVisibilityPrivacy = promotionChannelsVisibilityPrivacy
                ClassObject.facebook = facebook
                ClassObject.twitter = twitter
                ClassObject.youtube = youtube
                ClassObject.twitch = twitch
                ClassObject.guilded = guilded
                ClassObject.response: requests.Response = None


        class StarCodeAffiliateRequest:
            def __init__(ClassObject, code: str = None):
                ClassObject.code = code
                ClassObject.response: requests.Response = None


        class StarCodeAffiliateResponse:
            def __init__(ClassObject, userId: int = None, name: str = None, code: str = None):
                ClassObject.userId = userId
                ClassObject.name = name
                ClassObject.code = code
                ClassObject.response: requests.Response = None


        class VerifyEmailRequest:
            def __init__(ClassObject, ticket: str = None):
                ClassObject.ticket = ticket
                ClassObject.response: requests.Response = None


        class VerifyEmailResponse:
            def __init__(ClassObject, verifiedUserHatAssetId: int = None):
                ClassObject.verifiedUserHatAssetId = verifiedUserHatAssetId
                ClassObject.response: requests.Response = None


        class VerifyPhoneRequest:
            def __init__(ClassObject, code: str = None):
                ClassObject.code = code
                ClassObject.response: requests.Response = None


        class RobloxBadgeResponse:
            def __init__(ClassObject, id: int = None, name: str = None, description: str = None, imageUrl: str = None):
                ClassObject.id = id
                ClassObject.name = name
                ClassObject.description = description
                ClassObject.imageUrl = imageUrl
                ClassObject.response: requests.Response = None


        class PendingVerificationResponse:
            def __init__(ClassObject, verificationChannel: str = None, data: str = None):
                ClassObject.verificationChannel = verificationChannel
                ClassObject.data = data
                ClassObject.response: requests.Response = None


        class ApiEmptyResponseModel:
            def __init__(ClassObject):
                ClassObject.response: requests.Response = None
                pass


        
        def GetBirthdate(self) -> BirthdateResponse:
            """
            Get the user's birthdate
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.GetBirthdate()
        
            Args:
                
            Returns:
                AccountInformation.BirthdateResponse: AccountInformation.BirthdateResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetBirthdateRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountInformation.roblox.com/v1/birthdate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.BirthdateResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetBirthdateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetBirthdateRecivedData)
            
            return ResponseSchema
        
        def PostBirthdate(self, BirthdateRequest: BirthdateRequest) -> ApiEmptyResponseModel:
            """
            Update the user's birthdate
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.PostBirthdate(BirthdateRequest=AccountInformation.BirthdateRequest())
        
            Args:
                BirthdateRequest: BirthdateRequest
            Returns:
                AccountInformation.ApiEmptyResponseModel: AccountInformation.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'BirthdateRequest': 'json'}
            Arguments = inspect.signature(self.PostBirthdate)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostBirthdateRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountInformation.roblox.com/v1/birthdate", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostBirthdateRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostBirthdateRecivedData)
            
            return ResponseSchema
        
        def GetDescription(self) -> DescriptionResponse:
            """
            Get the user's description
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.GetDescription()
        
            Args:
                
            Returns:
                AccountInformation.DescriptionResponse: AccountInformation.DescriptionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetDescriptionRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountInformation.roblox.com/v1/description", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.DescriptionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetDescriptionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetDescriptionRecivedData)
            
            return ResponseSchema
        
        def PostDescription(self, DescriptionRequest: DescriptionRequest) -> DescriptionResponse:
            """
            Update the user's description
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.PostDescription(DescriptionRequest=AccountInformation.DescriptionRequest())
        
            Args:
                DescriptionRequest: DescriptionRequest
            Returns:
                AccountInformation.DescriptionResponse: AccountInformation.DescriptionResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'DescriptionRequest': 'json'}
            Arguments = inspect.signature(self.PostDescription)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostDescriptionRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountInformation.roblox.com/v1/description", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.DescriptionResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostDescriptionRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostDescriptionRecivedData)
            
            return ResponseSchema
        
        def GetGender(self) -> GenderResponse:
            """
            Get the user's gender
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.GetGender()
        
            Args:
                
            Returns:
                AccountInformation.GenderResponse: AccountInformation.GenderResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetGenderRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountInformation.roblox.com/v1/gender", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.GenderResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetGenderRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetGenderRecivedData)
            
            return ResponseSchema
        
        def PostGender(self, GenderRequest: GenderRequest) -> ApiEmptyResponseModel:
            """
            Update the user's gender
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.PostGender(GenderRequest=AccountInformation.GenderRequest())
        
            Args:
                GenderRequest: GenderRequest
            Returns:
                AccountInformation.ApiEmptyResponseModel: AccountInformation.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'GenderRequest': 'json'}
            Arguments = inspect.signature(self.PostGender)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostGenderRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountInformation.roblox.com/v1/gender", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostGenderRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostGenderRecivedData)
            
            return ResponseSchema
        
        def GetMetadata(self) -> MetadataResponse:
            """
            Get the metadata
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.GetMetadata()
        
            Args:
                
            Returns:
                AccountInformation.MetadataResponse: AccountInformation.MetadataResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetMetadataRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountInformation.roblox.com/v1/metadata", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.MetadataResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetMetadataRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetMetadataRecivedData)
            
            return ResponseSchema
        
        def GetPhone(self) -> PhoneResponse:
            """
            Get Verified Phone Number
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.GetPhone()
        
            Args:
                
            Returns:
                AccountInformation.PhoneResponse: AccountInformation.PhoneResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetPhoneRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountInformation.roblox.com/v1/phone", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.PhoneResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetPhoneRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPhoneRecivedData)
            
            return ResponseSchema
        
        def PostPhone(self, PhoneRequest: PhoneRequest) -> PendingVerificationResponse:
            """
            Set Phone Number
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.PostPhone(PhoneRequest=AccountInformation.PhoneRequest())
        
            Args:
                PhoneRequest: PhoneRequest
            Returns:
                AccountInformation.PendingVerificationResponse: AccountInformation.PendingVerificationResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PhoneRequest': 'json'}
            Arguments = inspect.signature(self.PostPhone)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPhoneRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountInformation.roblox.com/v1/phone", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.PendingVerificationResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostPhoneRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPhoneRecivedData)
            
            return ResponseSchema
        
        def GetPromotionChannels(self, alwaysReturnUrls: bool, filterLink: bool, onlyShortenTwitter: bool) -> PromotionChannelsResponse:
            """
            Get the user's promotion channels
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.GetPromotionChannels(alwaysReturnUrls=boolean, filterLink=boolean, onlyShortenTwitter=boolean)
        
            Args:
                alwaysReturnUrls: bool
            filterLink: bool
            onlyShortenTwitter: bool
            Returns:
                AccountInformation.PromotionChannelsResponse: AccountInformation.PromotionChannelsResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"alwaysReturnUrls": alwaysReturnUrls, "filterLink": filterLink, "onlyShortenTwitter": onlyShortenTwitter},"headers": {},"cookies": {}}
            
            GetPromotionChannelsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountInformation.roblox.com/v1/promotion-channels", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.PromotionChannelsResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetPromotionChannelsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetPromotionChannelsRecivedData)
            
            return ResponseSchema
        
        def PostPromotionChannels(self, PromotionChannelsRequest: PromotionChannelsRequest) -> ApiEmptyResponseModel:
            """
            Update the user's promotion channels
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.PostPromotionChannels(PromotionChannelsRequest=AccountInformation.PromotionChannelsRequest())
        
            Args:
                PromotionChannelsRequest: PromotionChannelsRequest
            Returns:
                AccountInformation.ApiEmptyResponseModel: AccountInformation.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PromotionChannelsRequest': 'json'}
            Arguments = inspect.signature(self.PostPromotionChannels)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPromotionChannelsRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountInformation.roblox.com/v1/promotion-channels", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPromotionChannelsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPromotionChannelsRecivedData)
            
            return ResponseSchema
        
        def DeleteStarCodeAffiliates(self) -> ApiEmptyResponseModel:
            """
            Removes the star code affiliate supporter for the authenticated user
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.DeleteStarCodeAffiliates()
        
            Args:
                
            Returns:
                AccountInformation.ApiEmptyResponseModel: AccountInformation.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            DeleteStarCodeAffiliatesRecivedData = self._RobloxClient._MakeRequest(method="delete", url=f"https://AccountInformation.roblox.com/v1/star-code-affiliates", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = DeleteStarCodeAffiliatesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", DeleteStarCodeAffiliatesRecivedData)
            
            return ResponseSchema
        
        def GetStarCodeAffiliates(self) -> StarCodeAffiliateResponse:
            """
            Gets a star code affiliate supporter for the authenticated user
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.GetStarCodeAffiliates()
        
            Args:
                
            Returns:
                AccountInformation.StarCodeAffiliateResponse: AccountInformation.StarCodeAffiliateResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetStarCodeAffiliatesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountInformation.roblox.com/v1/star-code-affiliates", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.StarCodeAffiliateResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetStarCodeAffiliatesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetStarCodeAffiliatesRecivedData)
            
            return ResponseSchema
        
        def PostStarCodeAffiliates(self, StarCodeAffiliateRequest: StarCodeAffiliateRequest) -> StarCodeAffiliateResponse:
            """
            Adds a star code affiliate supporter for the authenticated user
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.PostStarCodeAffiliates(StarCodeAffiliateRequest=AccountInformation.StarCodeAffiliateRequest())
        
            Args:
                StarCodeAffiliateRequest: StarCodeAffiliateRequest
            Returns:
                AccountInformation.StarCodeAffiliateResponse: AccountInformation.StarCodeAffiliateResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'StarCodeAffiliateRequest': 'json'}
            Arguments = inspect.signature(self.PostStarCodeAffiliates)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostStarCodeAffiliatesRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountInformation.roblox.com/v1/star-code-affiliates", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.StarCodeAffiliateResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostStarCodeAffiliatesRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostStarCodeAffiliatesRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridPromotionChannels(self, alwaysReturnUrls: bool, filterLink: bool, userId: int) -> PromotionChannelsByUserIdResponse:
            """
            Get promotion channels for a given user ID
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.GetUsersUseridPromotionChannels(alwaysReturnUrls=boolean, filterLink=boolean, userId=integer)
        
            Args:
                alwaysReturnUrls: bool
            filterLink: bool
            userId: int
            Returns:
                AccountInformation.PromotionChannelsByUserIdResponse: AccountInformation.PromotionChannelsByUserIdResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {"alwaysReturnUrls": alwaysReturnUrls, "filterLink": filterLink},"headers": {},"cookies": {}}
            
            GetUsersUseridPromotionChannelsRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountInformation.roblox.com/v1/users/{userId}/promotion-channels", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.PromotionChannelsByUserIdResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetUsersUseridPromotionChannelsRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetUsersUseridPromotionChannelsRecivedData)
            
            return ResponseSchema
        
        def GetUsersUseridRobloxBadges(self, userId: int) -> requests.Response:
            """
            Returns a list of Roblox badges belonging to a user.
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.GetUsersUseridRobloxBadges(userId=integer)
        
            Args:
                userId: int
            Returns:
                requests.Response: requests.Response
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetUsersUseridRobloxBadgesRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountInformation.roblox.com/v1/users/{userId}/roblox-badges", Dictinary=Dictinary)
            return GetUsersUseridRobloxBadgesRecivedData
        
        def GetXboxLiveConsecutiveLoginDays(self) -> ConsecutiveLoginDaysResponse:
            """
            Returns number of consecutive login days for xbox users
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.GetXboxLiveConsecutiveLoginDays()
        
            Args:
                
            Returns:
                AccountInformation.ConsecutiveLoginDaysResponse: AccountInformation.ConsecutiveLoginDaysResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            GetXboxLiveConsecutiveLoginDaysRecivedData = self._RobloxClient._MakeRequest(method="get", url=f"https://AccountInformation.roblox.com/v1/xbox-live/consecutive-login-days", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.ConsecutiveLoginDaysResponse()
        
            ReturnedJson = None
            try: ReturnedJson = GetXboxLiveConsecutiveLoginDaysRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", GetXboxLiveConsecutiveLoginDaysRecivedData)
            
            return ResponseSchema
        
        def PostEmailVerify(self, VerifyEmailRequest: VerifyEmailRequest) -> VerifyEmailResponse:
            """
            Verify the user's email address from token
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.PostEmailVerify(VerifyEmailRequest=AccountInformation.VerifyEmailRequest())
        
            Args:
                VerifyEmailRequest: VerifyEmailRequest
            Returns:
                AccountInformation.VerifyEmailResponse: AccountInformation.VerifyEmailResponse
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VerifyEmailRequest': 'json'}
            Arguments = inspect.signature(self.PostEmailVerify)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostEmailVerifyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountInformation.roblox.com/v1/email/verify", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.VerifyEmailResponse()
        
            ReturnedJson = None
            try: ReturnedJson = PostEmailVerifyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostEmailVerifyRecivedData)
            
            return ResponseSchema
        
        def PostPhoneDelete(self, PhoneRequest: PhoneRequest) -> ApiEmptyResponseModel:
            """
            Delete Phone
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.PostPhoneDelete(PhoneRequest=AccountInformation.PhoneRequest())
        
            Args:
                PhoneRequest: PhoneRequest
            Returns:
                AccountInformation.ApiEmptyResponseModel: AccountInformation.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'PhoneRequest': 'json'}
            Arguments = inspect.signature(self.PostPhoneDelete)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPhoneDeleteRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountInformation.roblox.com/v1/phone/delete", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPhoneDeleteRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPhoneDeleteRecivedData)
            
            return ResponseSchema
        
        def PostPhoneResend(self, EmptyRequest: EmptyRequest) -> ApiEmptyResponseModel:
            """
            Resend Phone code
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.PostPhoneResend(EmptyRequest=AccountInformation.EmptyRequest())
        
            Args:
                EmptyRequest: EmptyRequest
            Returns:
                AccountInformation.ApiEmptyResponseModel: AccountInformation.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'EmptyRequest': 'json'}
            Arguments = inspect.signature(self.PostPhoneResend)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPhoneResendRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountInformation.roblox.com/v1/phone/resend", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPhoneResendRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPhoneResendRecivedData)
            
            return ResponseSchema
        
        def PostPhoneVerify(self, VerifyPhoneRequest: VerifyPhoneRequest) -> ApiEmptyResponseModel:
            """
            Verify Phone
            
            Usage:
                import AccountInformation
            
                RobloxClient = RobloxClient(RobloSecurity="YOUR COOKIE")
                AccountInformationApi = AccountInformation.AccountInformationApi(RobloxClient=RobloxClient)
                Response = AccountInformationApi.PostPhoneVerify(VerifyPhoneRequest=AccountInformation.VerifyPhoneRequest())
        
            Args:
                VerifyPhoneRequest: VerifyPhoneRequest
            Returns:
                AccountInformation.ApiEmptyResponseModel: AccountInformation.ApiEmptyResponseModel
            """
        
            Dictinary = {"json": {},"data": {},"params": {},"headers": {},"cookies": {}}
            
            Schemas = {'VerifyPhoneRequest': 'json'}
            Arguments = inspect.signature(self.PostPhoneVerify)
            for Name, Value in Arguments.parameters.items():
                SchemaPlace = Schemas.get(Name)
                if not SchemaPlace: continue
                ObjectDictinary = locals().get(Name).__dict__
                Dictinary[SchemaPlace].update(ObjectDictinary)
    
            PostPhoneVerifyRecivedData = self._RobloxClient._MakeRequest(method="post", url=f"https://AccountInformation.roblox.com/v1/phone/verify", Dictinary=Dictinary)
            
            ResponseSchema = RobloxClient.AccountInformation.ApiEmptyResponseModel()
        
            ReturnedJson = None
            try: ReturnedJson = PostPhoneVerifyRecivedData.json() 
            except: ReturnedJson = {} 
        
            self._RobloxClient._SyncSchema(Schema=ResponseSchema, Json=ReturnedJson)
            setattr(ResponseSchema, "response", PostPhoneVerifyRecivedData)
            
            return ResponseSchema
        
